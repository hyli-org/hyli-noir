{"noir_version":"1.0.0-beta.4+3a5a15ac70e52b4e67edc69e8aa5ad7780523f87","hash":"10506797123286179500","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut ret = false;\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n\n            // Need to use println to avoid DIE removing the write operation.\n            crate::println(vec.get(0));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::wrapping_mul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test(should_fail)]\n    fn test_wrapping_mul() {\n        // This currently fails.\n        // See: https://github.com/noir-lang/noir/issues/7528\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, wrapping_mul(zero, one));\n\n        // 0*1==0\n        assert_eq(zero, wrapping_mul(one, zero));\n\n        // 1*1==1\n        assert_eq(one, wrapping_mul(one, one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, wrapping_mul(zero, two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, wrapping_mul(two_pow_64, zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(two_pow_64, one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, wrapping_mul(one, two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, wrapping_mul(two_pow_64, two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, wrapping_mul(u128_max, u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n","path":"/home/alexandre/Documents/repos/hyli-noir/check-secret/src/main.nr"},"53":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/home/alexandre/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}