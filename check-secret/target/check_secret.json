{"noir_version":"1.0.0-beta.12+9a5b3695b42e391fa27c48e87b9bbb07523d664d","hash":"9748277210122308683","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> =\n        BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u32 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n","path":"/home/maximilien/hyli-noir/check-secret/src/main.nr"},"59":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n","path":"/home/maximilien/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block_helper","encode_len","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}