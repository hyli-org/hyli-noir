{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"10871151069518277438","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"13961910192783449429":{"error_kind":"string","string":"extend_from_array out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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OBfOhXPhXDgXzoVz4Vw4F86Fc+FcOBfOhXPhXDgXzoVz4Vw4F86Fc+FcOBfOhXPhXDgXzoVz4Vw4F86Fc+FcOBfOhXPhXDgXzoVz4Vw4F86Fc+FcOBfOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e54zxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfOA+eB88B54DxwHjgPnAfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfOKW8t2luL+taiv7UocC0aXIsK16LDtShxLVpcixrXose1KHItmlyLKteiy7Uocy3aXIs616LPtSh0LRpdi0rXeut07WtypmDaTOf1h7vXlEw108t5T88MX9dkTGJypmDaTIcpmaqnq+TV02IyJjE5UzBtpsOUTGQsMhYZi4xFxiJjkbHIWGQsMhYZRoaRYWQYGUaGkWFkGBlGhpEhMkSGyBAZIkNkiAyRITJEhpPhZDgZToaT4WQ4GU6Gk+FkBBlBRpARZAQZQUaQEWQEGUHGJmOTscnYZGwyNhmbjE3GJmOTccg4ZBwyDhmHjEPGIeOQccg4ZCQZSUaSkWQkGUlGkpFkJBlJRpGB84Pzg/OD84Pzg/OD84Pzg/PEeeI8cZ44T5wnzhPnifPEeeI8cZ44T5wnzhPnifPEeeI8cZ44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m+i+ie6bFs7pvmnhnO6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+aeGc7pvovonumxbO6b5p4Zzum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovmnhnO6b6L6J7psWzum+aeGc7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L5p4Zzum+i+ie6bFs7pvmnhnO6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+yXBO901030T3TYZzum8ynNN9E9030X0T3TfRfRPdN9F9E9030X0T3TfRfRPdN9F9E9030X0T3TfRfRPdNxnO6b6J7pvovslwTvdNhnO6b6L7Jrpvovsmum+i+ya6b6L7Jrpvovsmum+i+ya6b6L7Jrpvovsmum+i+ybDOd030X0T3TcZzum+yXBO901030T3TXTfRPdNdN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNdN9kOKf7JrpvovsmwzndNxnO6b6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7pvovonum+i+ie6bhHO6b6L7JrpvEs7pvkk4p/smum+i+ya6b6L7Jrpvovsmum+i+ya6b6L7Jrpvovsmum+i+ya6b6L7JrpvEs6v7tvrXoau7tvrXoE0f6kizV+qSPOXKtL8pYo0f6kizV+qSPOXKtL8pYo0f6kiiQyRITKcDCfDyXAyvO9gSPOXKtL8pYo0f6mit+7btbf5SxVp/lJFmr9U0Vvj7XFNzhRMm4lXGt003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN5E40003kTjTTTeRONNNN7k6KbxJhpvovEm5yxO403OWdyn2Soab6LxJhpvcs7iNN7knMVpvInGm2i8yTmL03iTcxan8SYab6LxJucsTuNNzlmcxptovInGm5yzOI03OWdxD15znDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e549xx7jh3nDvOHeeOc8e545zum+i+ie6bHOd03xQ4p/smum+i+6bAOd03Bc7pvonum+i+ie6b6L6J7pvovonum+i+ie6b6L6J7psC53TfRPdNdN8UOKf7psA53TfRfRPdNwXO6b4pcE73TXTfRPdNdN9E901030T3TXTfRPdNdN9E90103xQ4p/smum+i+6bAOd03Bc7pvonum+i+KXBO902Bc7pvovsmum+i+ya6b6L7Jrpvovsmum+i+ya6b6L7psA53TfRfRPdNwXO6b4pcE73TXTfRPdNgXO6bwqc030T3TfRfRPdN9F9E9030X0T3TfRfRPdN9F9E903Bc7pvonum+i+KXBO900b53TfRPdNdN+0cU73TRvndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNG+d030T3TXTftHFO900b53TfRPdNdN+0cU73TRvndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNG+d030T3TXTftHFO900b53TfRPdNdN+0cU73TRvndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNG+d030T3TXTftHFO900b53TfRPdNdN+0cU73TRvndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNG+d030T3TXTftHFO900H53TfRPdNdN90cE73TQfndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNB+d030T3TXTfdHBO900H53TfRPdNdN90cE73TQfndN9E901030T3TXTfRPdNdN9E901030T3TXTfRPdNB+d030T3TXTfdHBO900H53TfRPdNdN90cE73TQfnZ/5SRVf37bz925rp+kuVt2kxGZOYnCmYNtNhemXkNdVML+c9LaZXRl2TmJwpmF4rn2tKpprppbun58qv/yN2XY23nsTkTM+V8zouL909Hf5tMtVML909rfmKl+6eyCgyXrp72kyHr0imybgabz0tJmNSf8XVeOvplXGuafN5hymZyHjpfvvatZjIWGJypmDafMVhImORYezD2IfNsboabz2RYWQY+zD2YclX1Ewv3W87FxliH2IfIkPB17IPkSH2Ifbh7MM5Vs4+nAwnw9mHsw/nWDn7cDKCjGAfwT6CYxW85sFrHmQE+wj2EWRsXvPNPjYZm31s9rHZx+ZYbfaxydhkHPZx2MfhWB32ccg4ZBz2cdjH4VgdXvPkNcd54jxxnjhPnCfOE+eJ88R54jxxnjhPnCfOE+eJ88R54jxxXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnBfOC+eF88J54bxwXjgvnF/dt7fPKzKKDJxf3bf+PPaB86v71hP7uJw/n70/xrk/xrk/xrk/xrlf3bf+WDBtpsPnJR+rmRYZ49wfi4xx7o9Fxgo+b88zXYd/S8Yiwx7zFcY+jAwjw5zPYx/GPoyMce5X9+3tY2IfIkM2n3c5v56p2IfIEBniWIl9iAwnwzlWzj6cfTgZzrFyMpx9OBle83nxmGca7CPICDKCYxXsI8gIMoJjFexjs49NxuZYbTI2+9hkjHO/um9vz3Szj03GIeNwrA77OGQcMg7H6rCPwz4OGYdjlWQk+0gyEh+X8+uZJvtIMpKM5Fgl+ygyioziWBX7KPZRZBTHqsgo9jHnc7+6b9fnXd2365kunF/dt56cKfiKzccOUzLNsVo4v7pvPZGxxOeRMedzv7pvPR0+L+eZ4nwZGThfcz73q/uWdU3OFEyb6TAlU810OX+bFpMxkSEyRIbIEBkiQ2S8nNf17F/OezImMTlTMG2mw5RMNVOQEWQEGUFGkBFkBBlBRpARZGwyNhmbjE3GJmOTscnYZGwyNhmHjEPGIePlvOyanCmYNtMrw68pmWqml/OKa1pMr4x9TWJyplfG9d35ct7TYUqmmunlvPKaFpNN2st5Xd8bL+c9BdNmemY8OV9j3mPNeNXfZlz3aPeoe/R7jHvc93juMe/xTlt32rrT1p227rQ1G7vKcD1tpsOUTDXTC35Pi8mYxESGkWFkGBl27causRj1uMdrN9fnvvA/38muUffo9xj3uO/x3GPeYzG+3gRmXPd4p/md5nea32l+p/md5nea32lxp8WdFnda3Glxp8WVdq5x3+O5x7zHYtyPe1z3aPeoe/R7vNP2nbbvtH2n7Tvt3GnnTjt32rnTzp127rRzp5077dxp507LOy3vtLzT8k7LOy3vtLzT8k7LOy3vtLrT6k6rO63utLrT6k6rO63utLrTirSrVDfjuke7x1earWt8pZldY9zjvsdzj3mPxXi9e/S47tHuUfd4p607bd1p605bd9q60+xOszvN7jS70+xOszvN7jS70+xOsztNd5ruNN1putN0p+lOu95LzK/xSotrvNL2NV5p18tyvZdYXuO6R7tH3eMrTY9rjHvc93ju8ZWm6+lc7yXSa7zeS3Q9s+u9RNczu95LFD9/+ea/vv3p+2//8MN3//nNb/72/Md//+uPf/zL93/6sf/xL//nz/Nv/vDT9z/88P1//P7PP/3pj9/9219/+u73P/zpj69/983j9T/P5/zb5wv/5fly/O7LN6/vlt8+z9pfnu/Zv3t+8ZpPef4k8DzFzGc8JX55snp9hrGI7y/P39zPpzx/X/Dl+RuA16eow37rz/v9Xud3X96+wPTl+QqRuh9ffMfrH9f1j/XFz3p9vb++/vocrS/arw8Fz8ufz8vv57W/PAn/7ueff/7dz/8X","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_vectors() {\n        let vector_1 = &[0, 1, 2, 3];\n        let vector_2 = &[0, 1, 2];\n        assert(!vector_1.eq(vector_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_vectors() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a built-in vector except that it\n/// is bounded with a maximum possible length. `BoundedVec` is also not\n/// subject to the same restrictions vectors are (notably, nested vectors are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over vectors when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given vector to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_vector(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_vector(&mut self, vector: [T]) {\n        let new_len = self.len + vector.len();\n        assert(new_len <= MaxLen, \"extend_from_vector out of bounds\");\n        for i in 0..vector.len() {\n            self.storage[self.len + i] = vector[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_vector out of bounds\")]\n        fn extend_vector_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_vector(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_vector(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod vector;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nmod primitive_docs;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n","path":"std/lib.nr"},"51":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let identity_bytes = identity.as_bytes();\n    let mut id_array: [u8; 289] = [0; 289];\n\n    for i in 0..256 {\n        if i < identity_len as u32 {\n            id_array[i] = identity_bytes[i];\n        }\n    }\n\n    let mut id: BoundedVec<u8, 289> = BoundedVec::from_parts(id_array, identity_len as u32);\n    id.extend_from_array([58]); // ':'\n    id.extend_from_array(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u32 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n","path":"/home/maximilien/hyli-noir/check-secret/src/main.nr"},"60":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n","path":"/home/maximilien/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr"}},"expression_width":{"Bounded":{"width":4}}}