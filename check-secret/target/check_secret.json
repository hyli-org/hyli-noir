{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"1219329721828661781","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"1837938722211649573":{"error_kind":"string","string":"extend_from_slice out of bounds"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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32LQ/bDt579dzW8z6G5q+/lvV/NYBt2P2H7+29U8kUF3M9vPf7uapzLoftT289+u5pkMuh+z/fy3q3kug+7HbT//7WpewKC7ue3nv13N7zPobmH7+W9X80cMup+w/fy3q/kzBt1P2n7+29W8lEF3pu3nv13NXzLozrL9/LereRWD7mzbz3+7mr9h0N3S9vPfruZvGXTn2H7+29W8iUF3ru3nv13NPzDofsr289+u5u0Mup+2/fy3q/knBt2tbD//7Wr+hUH3M7af/3Y1H2DQ/azt579dzUcYdLe2/fy3q/k4g+42tp//djX/zqC7re3nv13NfzLofs7289+u5nMMup+3/fy3q9mJxOtuZ/v5b1dzAQbd7W0//+1qjmTQ/YLt579dzTEMul+0/fy3q/lKBt0dbD//7WouwqC7o+3nv13N1zDofsn289+u5usYdHey/fy3q7k0g+6XbT//7Wq+kUF3Z9vPf7uab2bQ/Yrt579dzbcw6O5i+/lvV3NVBt1dbT//7WpOZtDdzfbz367mdAbdr9p+/tvVfAeD7u62n/9Wf5edQXcP289/u5prMejuafv5b1dzXQbdr9l+/tvV3IBBdy/bz3+7mu9n0N3b9vPfruaHGHT3sf38t6v5EQbdfW0//+1qfpxBdz/bz3+7mp9k0N3f9vPfruaWDLoH2H7+29X8NIPugbaf/3Y1t2bQPcj289+u5ucZdA+2/fy3q/lFBt1DbD//7WruxKD7ddvPf7uauzDofsP289+u5u4Muofafv7b1dyLQfcw289/u5r7Meh+0/bz367mQQy637L9/Ler+Q0G3cNtP//tan6LQfcIoO78zj9bj/5X5Ej3P7ztfke539Hud4z7Het+x7nf8e53gvud6H4nud/J7neK+53qfqe53+nud4b7nel+Z7nf2e53jvud637nud/57vcd97vA/S50v++63/fc7/vud5H7/cD9fuh+P3K/H7vfT9zvp+73M/e72P0ucb+fu9+l7neZ+13ufr9wv1+63xXud6X7/cr9rnK/q93vGvf7tfv9xv2udb/r3O969/ut+93gfje63+/c7yb3u9n9fu9+t7jfH9zvVve7zf3+6H63u98d7nen+93lfn9yv7vd7x73+7P7/cX97nW/+9zvfvd7wP0edL+H3O9h93vE/R51v8fc76/u97j7PeF+f3O/J93v7+73lPs97X7/cL9/ut8z7ves+/3L/Z5zv+fd7wX3+7fqLLf/r3C/+dxvfvdbwP2Gud9w9xvhfiPdb0H3G+V+o91vjPuNdb9x7jfe/V7pfgu538Lu9yr3W8T9FnW/6u/Kq7+xrv7euPrb2+rvUKu/yaz+PrH6W73q79aqv+Gq/p6p+tue6u9cqr/5qP7+ofpbgOrv4qm/Eaf+Xpr622Hq72ipvyml/r6S+ltD6u/uqL9Bo/4ei/rbJOrvdKi/WaH+foP6Wwbqvf7qHffqfe/q3efqPeDqndjq/dDqXcnqvcH/vEPX/ap3q6r3jKp3bqr3T6p3Mar3Eqp39Kn31al3t6n3mKl3eqn3W6l3Pan3Hql3AKn34ah3w6j3pKh3hqj3Z6h3Saj3Kqh3DKjz9ursuTqHrc4kq/O56qyqOrepzjCq83zqbJs656XOPKnzP+osjDoXos5IqPMCau+82keu9lSr/cVqr63ad6r2YKr9iGpvntqnpvZsqf1Lai+P2tei9nio/Q7qd//q9+Dqd8Lq96Pqd4Xq92bqd0jq9ynqdwtqnV2tOav1V7UWqdbl1BqVWq9RaxfqOV4906rnO/Wso3K/ysAqD6pspHKCmjPV/KFYqriiPvkCTDA+KC4GrgffX+Zg5wOOGmPz42v8X6dx3cxQJ6yRBVF1JSaoDsmvO0Zdt7T7zwLOP38/6X/3IPiDnnwBWhIC/5coF3Nt9xN8L97WA3tUQX1DAjdwlL6BwZ/8jDfs/+O1EvW1Et4uiKtrFFNHog33dkE8edXHZmCMBmoO9ru6bqQjd4YD3he2Ge7FfEJmuNFAmIxhMuwY4YYdI8CwHfKiYcfiOiYx2LBjhRt2rADDdsyLhh2H65ikYMOOE27YcQIM+1JeNOx4XMckBxt2vHDDjhdg2E550bATcB2TEmzYCcINO0GAYV/Oi4adiOuY1GDDThRu2IkCDNs5Lxp2Eq5j0oINO0m4YScJMOwredGwk3Edkx5s2MnCDTtZgGG75EXDTsF1TEawYacIN+wUAYbtmhcNOxXXMZnBhp0q3LBTBRi2W1407DRcx2QFG3aacMNOE2DYV/OiYafjOiY72LDThRt2ugDDds+Lhp2B65iWwYadIdywMwQYtkdeNOxMXMfkBBt2pnDDzhRg2J550bCzcB2TG2zYWcINO0uAYV/Li4adDeuYhKrBhp0t3LCzBRi2V1407BycYS/ZDztHuGHnCDBs77xo2Lk4w16yH3aucMPOFWDYPnnRsPNwhr1kP+w84YadJ8CwffOiYefjDHvJftj5wg07X4Bh++VFw76DM+wl+2HfEW7YdwQYtn9eNOwCnGEv2Q+7QLhhFwgw7IC8aNiFOMNesh92oXDDLhRg2IF50bDv4gx7yX7Yd4Ub9l0Bhh2UFw37Hs6wl+yHfU+4Yd8TYNjBedGw7+MMe8l+2PeFG/Z9AYYdkhcNuwhn2Ev2wy4SbthFAgz7el407Ac4w16yH/YD4Yb9QIBh38iLhv0QZ9hL9sN+KNywHwow7NC8aNiPcIa9ZD/sR8IN+5EAww7Li4b9GGfYS/bDfizcsB8LMOybSMMW0Bcq4Fz+gypc3YgirP8byRk8101NZrpuCtN1c3ium8Z1H5j6javeNKZ6kzJ5rptYlek+ZPFcN9Ufxxev649j1nq5xnFaS4f4YK59cR79X6rQH3TIiHHsD0KxAmqME1BjvIAarxRQYyEBNRYWUONVAmosIqDGogJqLCagxqsF1HiNgBqLC6ixhIAarxVQ43UCaiwpoMZSAmq8XkCNpQXUWEZAjWUF1HiDgBpvFFBjOQE1lhdQ400CarxZQI0VBNRYUUCNlQTUeIuAGisLqLGKgBpvFVBjVQE1JgioMVFAjUkCakwWUGOKgBpTBdSYJqDGdAE1Zgio8TYBNd4uoMY7BNRYTUCN1QXUeKeAGu8SUGMNATXWFFDj3QJqrCWgxtoCaqwjoMZ7BNRYV0CN9QTUWF9AjfcKqLGBgBobCqixkYAa7xNQ4/0CanxAQI2NBdT4oIAaHxJQYxMBNT4soMamAmp8RECNzQTU+KiAGh8TUOPjAmpsLqDGFgJqfEJAjU8KqDFTQI1ZAmrMFlBjSwE15gioMVdAjU8JqPFpATW2ElDjMwJqfFZAja0F1NhGQI1tBdT4nIAanxdQYzsBNbYXUOMLAmp8UUCNHQTU2FFAjS8JqLGTgBpfFlBjZwE1viKgxi4CauwqoMZuAmp8VUCN3QXU2ENAjT0F1PiagBp7Caixt4Aa+wiosa+AGvsJqLG/gBoHCKhxoIAaBwmocbCAGocIqPF1ATW+IaDGoQJqHCagxjcF1PiWgBqHC6hxhIAaRwqo8W0BNY4SUONoATWOEVDjWAE1jhNQ43gBNU4QUONEATVOElDjZAE1ThFQ41QBNU4TUON0ATXOEFDjTAE1zhJQ42wBNc4RUONcATXOE1DjfAE1viOgxgUCalwooMZ3BdT4noAa3xdQ4yIBNX4goMYPBdT4kYAaPxZQ4ycCavxUQI2fCahxsYAalwio8XMBNS4VUOMyATUuF1DjFwJq/FJAjSsE1LhSQI1fCahxlYAaVwuocY2AGr8WUOM3AmpcK6DGdQJqXC+gxm8F1LhBQI0bBdT4nYAaNwmocbOAGr8XUOMWATX+IKDGrQJq3Cagxh8F1LhdQI07BNS4U0CNuwTU+JOAGncLqHGPgBp/FlDjLwJq3Cugxn0CatwvoMYDAmo8KKDGQwJqPCygxiMCajwqoMZjAmr8VUCNxwXUeEJAjb8JqPGkgBp/F1DjKQE1nhZQ4x8CavxTQI1nBNR4VkCNfwmo8ZyAGs8LqPGCgBr/FlCjuqDtNV4hoMZ8AmrML6DGAgJqDBNQY7iAGiME1BgpoMaCAmqMElBjNEONTgFdaAHn8h+UAPW/U4T1fyOlKs91UxN4rpuWJOy6aUz3N5ep3kSmepN5rpuUyXPdRKZxkZbFdF1/HPNe1x/HF+tlGsdpLR3ig7n2xXm0tHFtdNh4MZ/9gaiDgBo7CqjxJQE1dhJQ48sCauwsoMZXBNTYRUCNXQXU2E1Aja8KqLG7gBp7CKixp4AaXxNQYy8BNfYWUGMfATX2FVBjPwE19hdQ4wABNQ4UUOMgATUOFlDjEAE1vi6gxjcE1DhUQI3DBNT4JkON//wC0b2uE+Zc/oMSoG5IIdb/jdQUnuumpTNdl2khm+s+pOYwXVfafWCql+sXfqkZsu6D/wvVix9p/cb7CzQ1T0Ua10ZPsiMLMkyywZ984IKjg66V5HZsck5aYk5CUkJm1cSMrPSUqskpWanpCekJKekpLRPTk5Jy0pPT0zKyMtKqZiQkJ+Uk5KZkJOXqi30CE5/4z2SfX3dQ4LoqbEQE3QPOjvyEuSNDvHZC4Ifge/FpwYv//KygviGBG6j+RWmj7bOC//51cn7Gm/j/0VyJ2lwJnxbEGfUzYOf+/2NKC+pOCPxfxyNTLtamXGKacsn/CwMib1ioBlwMNOASpo5EG24xbqAkeEnvz+ymt/4kXzJQPtcDZak5UNS/KGG0qf9SuFEUmt6AwZOUk6s+2QmfAwfPUjC91X0z7yW+sy+uX9zK+r/hr19c/PjrF/q6/vrFxXr99Yt/PuLWL1oy1cu0wTqVaYN1GtN9SMxmuq7vs4vX5ZqPhR084DqAwTXeuPotheugBFe/Mc2baUzzG9t48/n7z8ef53W9TNyRxge25zeuA3tMB8rSJP4+LMmL34fJWIgzNrQEFoXUx79J//e5Ikj/lfrnZW7ty93vF+73S/e7wv2udL9fud9V7ne1+13jfr92v9+437Xud537Xe9+vzVXOpcRv6daTrR9QbR9SbStINpWEm1fEW2riLbVRNsaou1rou0bom0t0baOaFtPtH2r29R/jkJ2iPP/3y9arfmdVlXvfqe1Qd+njaaB1b+4wmjbKOz3XBuAS/UbC2I7INKBd/D/PoHroen+dj77a/wOOQNR9EBR4+Lvky6a9LuC4BvhWg16I/BmJWm0SdNos0kj9S8ijbbNQTTi6hToLyKNTgmVbpuAdNuc17eRqFc1Ot6Y/Htt8i2myb8nptwtwqbc74Gm3ALsXKlT7hgBU+4P6JkGTQlFt+8L4q/buihWOLo+pVl1TgFwhwNni0vME6rercC6kH0bDPStGujULJkP2U8JF/t/M2zr00W4b2WIqlsL4iEX/Anx2uQsvk3P4j+as/g2Iqr+yBhVA50CHeRGp4SaCrYBB/mPQEMjB7nQ2JtIlMsyYLbrAbPDHDDbidi7Q1js3Q40+A5g50qNveMExN6dtsdeRcrtDLG3neWxV2neyRB7fyzIY55Q9e4C1tWOKfbu8jD2qv5HpgR1vV0MsXdXQTzkgj8hXpucxX/Ss/hucxb/iYi9uxljb6BT0LF3FzAV/AQc5LuBhm7nx94kolyWAbNHD5ifzQGzh4i9PwuLvXuABv8Z2LlSY+8EAbH3F9tjryLlHobY29Hy2Ks0/8IQe3cX5DFPqHr3AuvqyBR79zIkoOD+3ov+HbV7L/YC+2hfQXvHX+CTD9wvyF1H+4Ee59CqtuhtAPtlf0H8pLWMeX8D+tFQ3dN9Bf/v+qjaHeIT4rXJ1HtA137QTL0HiMfEg/8PkKwayifoRoKM/7/kewBo+oPM5nQuc28tehxLdjwy5iFtzMOmMQ8Rj2OHhT2OHQKa8jCwc6U+jk0S8Dh2xPbHMUW3QwyPY10sfxxTmo8wPI4BZ4tLzBOq3qPAurowPY4d9fC3EKr/DwIXbdX1jjL8FuJoQTzkgj8hXpucxY/pWfxXcxY/RsTLXxl/CxHoFPRvIY4CU8Ex4CD/FWjoLv5vIVKIclkGzHE9YE6YA+Y4EXtPCIu9x4EGPwHsXKmxd4qA2Pub7bFXkfI4Q+ztYXnsVZp/Y4i9vxbkMU+oek8C6+rBFHtPehh7Vf8jU4K63kmG2HuyIB5ywZ8Qr03O4r/rWfyUOYv/TsTeU4yxN9Ap6Nh7EpgKfgcO8lNAQ/fwY28qUS7LgDmtB8wf5oA5TcTeP4TF3tNAg/8B7FypsXeagNj7p+2xV5HyNEPs7WN57FWa/2SIvacK8pgnVL1ngHX1YYq9ZzyMvar/kSlBXe8MQ+w9UxAPueBPiNcmZ/Gzehb/y5zFzxKx9y/G2BvoFHTsPQNMBWeBg/wvoKH7+LE3jSiXZcCc0wPmvDlgzhGx97yw2HsOaPDzwM6VGntnCIi9F2yPvYqU5xhi70DLY6/SfIEh9v5VkMc8oer9G1jXQKbY+zfXdkq35v2X2Z8b6n1V7/1E3QsF4ijn3x/U9R2me4u8B1w1XhFlOYgVkNQAQB+K+BsIkXxR9k4Q0OdiDYwrgHrV9fJF4Qe1V5v6OWp3iE+I1yYfK/Lr2gtEOZc+Qqh/YT6Hq/9SaeYbaZo11EeL/ECjFojiNadzmXtr0fNuuuORMcO0McNNY6p/YT7vhkfJet4NA5oyPArXuVKfd2cJeN6NsD1mKboFBhfyukMtf95VmlXnoJ93gbPFJeYJVW8ksK6hTM+7kVHe/ZpH9X8BwP0NrIqr60VG4RNSZBQecsGfEK9NzuIF9SweZc7iBYl4GRXF92ueQKegf80TGYVLBQWBgzwKaOih/q95MohyWQZMtB4wMeaAiSZib4yw2BsNNHgMLvZmSI29cwTE3ljbY68iZTRD7B1heexVmmMZYm9UFI95QtUbB6xrBFPsjfMw9qr+R6YEdb04htgbJzD2xutZ/EpzFo8nYu+VjLE30Cno2BsHjL3xwEF+JdDQI/zYm0mUyzJgCukBU9gcMIWI2FtYWOwtBDR4YVzszZQae+cJiL1X2R57FSkLMcTeMZbHXqX5KobYe2UUj3lC1VsEWNcYpthbxMPYq/ofmRLU9YowxN4iAmNvUT2LFzNn8aJE7C3GGHsDnYKOvUWAsbcocJAXAxp6jB97s4hyWQbM1XrAXGMOmKuJ2HuNsNh7NdDg1+Bib5bU2PuOgNhb3PbYq0h5NUPsnWh57FWaizPE3mJRPOYJVW8JYF0TmWJvCa7tlEGb+vMxXBfVR1OYx0zV0D7//MF46h6GqvtaoDdtv4fq/l3LwNvr/MMlCddF2V9jSdsDgZoYFYjRh0tKACezUlH2BhWOCaYk+HBJqSieQS1lwrnezgkngeMeqvt3PcOEUxoIsuAQWJoxBHL5qYylAcarA19cPDE/IV6bXHIqq2u/wVxyKkus0d7AfOCrFMOBr7LAyeOGKF5zOpe5txathWY7HhnzRm3McqYxbyTWQssJWwu9EWjKcri10Gypa6ELBayFlrf90UfR7UaGqDTD8rVQpbk8w1oocLa4xDyh6r0JWNcMprXQmzzcAqD6/wbgb0zV9W5i2AJwUxQecsGfEK9NzuI361m8gjmL30zEywqMWwACnYLeAnATcAvAzcBBXgFo6Bn+FoCWRLksA6aiHjCVzAFTkYi9lYTF3opAg1fCxd6WUmPvewJi7y22x15FyooMsXeu5bFXab6FIfZWiOIxT6h6KwPrmssUeyt7GHtV/yNTgrpeZYbYW1lg7K2iZ/FbzVm8ChF7b2WMvYFOQcfeysDYWwU4yG8FGnquH3tziHJZBkxVPWASzAFTlYi9CcJib1WgwRNwsTdHauxdJCD2JtoeexUpqzLE3oWWx16lOZEh9t4axWOeUPUmAetayBR7kzyMvar/kSlBXS+JIfYmCYy9yXoWTzFn8WQi9qYwxt5Ap6BjbxIw9iYDB3kK0NAL/dibS5TLMmBS9YBJMwdMKhF704TF3lSgwdNwsTdXauz9UEDsTbc99ipSpjLE3g8sj71KczpD7E2J4jFPqHozgHV9wBR7M5j3+pZh8PnHAg4YlWbQ/UlRPHwdBz+B3wb0PbCvEz4R4JvbGHxzO3BCVMElyvn3B3lfOe7t7VH213iH7cFFTeAZDAfTMoCTbrUoewMVdB1JA+MOoF51vWpRfINafdCTTfX//mTDdiitOsNkcycQYsFB9U4PVh7uygPBxasDadwcAV2bXBKroWuvaS6J1SDWkGsyH0irxnAgrQZw0qgZxWtO5zL31p612gTPjHm3NmYt05h3E2u1tYSt1d4NNGWtKFznSl2r/VjAWm1t2x95FN3uZohJSyxfq1WaazOs1QJni0vME6reOsC6ljCt1dbxcIuC6v+awN/oquvVYdiiUCcKD7ngT4jXJmfxe/QsXtecxe8h4mVdxi0KgU5Bb1GoA9yicA9wkNcFGnpJnt+ikJBAlMsyYOrpAVPfHDD1iNhbX1jsrQc0eH1c7E2QGns/FRB777U99ipS1mOIvV9YHnuV5nsZYm/dKB7zhKq3AbCuL5hibwMPY6/qf2RKUNdrwBB7GwiMvQ31LN7InMUbErG3EWPsDXQKOvY2AMbehsBB3gho6C/82JtIlMsyYO7TA+Z+c8DcR8Te+4XF3vuABr8fF3sTpcbexQJi7wO2x15FyvsYYu8qy2Ov0vwAQ+xtFMVjnlD1NgbWtYop9jb2MPaq/kemBHW9xgyxt7HA2PugnsUfMmfxB4nY+xBj7A10Cjr2NgbG3geBg/whoKFX+bE3iSiXZcA00QPmYXPANCFi78PCYm8ToMEfxsXeJKmx93MBsbep7bFXkbIJQ+xda3nsVZqbMsTeh6J4zBOq3keAda1lir2PcG2n1AfS7mLw+bcCDhbdyaB7g5ADac2Avgf2dcIGAb5pxuCbR4ETogouUc6/P8j7ynFvH42yv8bHbA8uagJ/hOFA2iPASffxKHsDFXQdSQPjMaBedb3Ho/gGtfqgJ5vm//3Jhu1AWnOGyaYFEGLBQbWFBysPT+SB4OLVgTRujoCuTS6JPalrzzSXxJ4k1pAzmQ+kPc5wIO1J4KSRGcVrTucy99aitdpkxyNjZmljZpvGzCLWarOFrdVmAU2ZjVurTZa6VrtMwFptS9sfeRTdshhi0mbL12qV5pYMa7XA2eIS84SqNwdY12amtdocD7coqP7PBP5GV10vh2GLQk4UHnLBnxCvTc7iuXoWf8qcxXOJePkU4xaFQKegtyjkALco5AIH+VNAQ2/2tyikEOWyDJin9YBpZQ6Yp4nY20pY7H0aaPBWuNibIjX2fiEg9j5je+xVpHyaIfZuszz2Ks3PMMTep6J4zBOq3meBdW1jir3Pehh7Vf8jU4K63rMMsfdZgbG3tZ7F25izeGsi9rZhjL2BTkHH3meBsbc1cJC3ARp6mx97U4lyWQZMWz1gnjMHTFsi9j4nLPa2BRr8OVzsTZUae1cIiL3P2x57FSnbMsTeXZbHXqX5eYbY2yaKxzyh6m0HrGsXU+xt52HsVf2PTAnqeu0YYm87gbG3vZ7FXzBn8fZE7H2BMfYGOgUde9sBY2974CB/AWjoXX7sTSPKZRkwL+oB08EcMC8SsbeDsNj7ItDgHXCxN01q7P1KQOztaHvsVaR8kSH2/mJ57FWaOzLE3heieMwTqt6XgHX9whR7X+LaTqkPpD3B4PP9Ag4WtWDQfUDIgbROQN8D+zrhgADfdGLwzcvACVEFlyjn3x/kfeW4ty9H2V9jZ9uDi5rAX2I4kPYScNJ9JcreQAVdR9LA6AzUq673ShTfoFYf9GTT5b8/2bAdSOvCMNl0BUIsOKh29WDloVseCC5eHUjj5gjo2uSS2Ku69u7mktirxBpyd+YDaa8wHEh7FThpdI/iNadzmXtr0VptuuORMXtoY/Y0jdmDWKvtKWyttgfQlD1xa7XpUtdqVwtYq33N9kceRbceDDHpiOVrtUrzawxrtcDZ4hLzhKq3F7CuI0xrtb083KKg+r878De66nq9GLYo9IrCQy74E+K1yVm8t57F+5izeG8iXvZh3KIQ6BT0FoVewC0KvYGDvA/Q0Ef8LQoZRLksA6avHjD9zAHTl4i9/YTF3r5Ag/fDxd4MqbH3awGxt7/tsVeRsi9D7D1heexVmvszxN4+UTzmCVXvAGBdJ5hi7wAPY6/qf2RKUNcbwBB7BwiMvQP1LD7InMUHErF3EGPsDXQKOvYOAMbegcBBPgho6BN+7M0kymUZMIP1gBliDpjBROwdIiz2DgYafAgu9mZKjb1rBcTe122PvYqUgxli72nLY6/S/DpD7B0UxWOeUPW+AazrNFPsfcPD2Kv6H5kS1PXeYIi9bwiMvUP1LD7MnMWHErF3GGPsDXQKOva+AYy9Q4GDfBjQ0Kf92JtFlMsyYN7UA+Ytc8C8ScTet4TF3jeBBn8LF3uzpMbe9QJi73DbY68i5ZsMsfcvy2Ov0jycIfYOi+IxT6h6RwDr+osp9o7g2k6pD6R1Y/D5BQEHi7oy6P5byIG0kUDfA/s64W8BvhnJ4Ju3gROiCi5Rzr8/yPvKcW/fjrK/xlG2Bxc1gY9gOJA2Ajjpjo6yN1BB15E0MEYB9arrjY7iG9Tqg55sxvz3Jxu2A2ljGCabsUCIBQfVsR6sPIzLA8HFqwNp3BwBXZtcEhuva59gLomNJ9aQJzAfSBvNcCBtPHDSmBDFa07nMvfWorXabMcjY07UxpxkGnMisVY7Sdha7USgKSfh1mqzpa7VbhCwVjvZ9kceRbeJDDEpfzG712qV5skMa7XA2eIS84SqdwqwLmTfBgN9iodbFFT/TwD+RlddbwrDFoUpUXjIBX9CvDY5i0/Vs/g0cxafSsTLaYxbFAKdgt6iMAW4RWEqcJBPAxoaOciFxt6WRLksA2a6HjAzzAEznYi9M4TF3ulAg8/Axd6WUmPvdwJi70zbY68i5XSG2BtpeexVmmcyxN5pUTzmCVXvLGBdkUyxd5aHsVf1PzIlqOvNYoi9swTG3tl6Fp9jzuKzidg7hzH2BjoFHXtnAWPvbOAgnwM0dKQfe3OIclkGzFw9YOaZA2YuEXvnCYu9c4EGn4eLvTlSY+9mAbF3vu2xV5FyLkPsjbU89irN8xli75woHvOEqvcdYF2xTLH3HQ9jr+p/ZEpQ13uHIfa+IzD2LtCz+EJzFl9AxN6FjLE30Cno2PsOMPYuAA7yhUBDx/qxN5col2XAvKsHzHvmgHmXiL3vCYu97wIN/h4u9uZKjb1bBMTe922PvYqU7zLE3sKWx16l+X2G2Lswisc8oepdBKyrMFPsXcS1nVIfSBvH4POizD6vGtrnn73eYxl0FyuGh6/j4CfwD4C+B/Z1QjEBvvmAwTcfAidEFVyinH9/kPeV495+GGV/jR/ZHlzUBL6I4UDaIuCk+3GUvYEKuo6kgfERUK+63sdRfINafdCTzSf//cmG7UDaJwyTzadAiAUH1U+9WHnIA8HFqwNp3BwBXZtcElusa19iLoktJtaQlzAfSPuY4UDaYuCksSSK15zOZe6tPWu1iZ4Z83NtzKWmMT8n1mqXClur/RxoyqVRuM6Vula7VcBa7TLbH3kU3T5niEklLF+rVZqXMazVAmeLS8wTqt7lwLpKMK3VLvdwi4Lq/yXA3+iq6y1n2KKwPAoPueBPiNcmZ/Ev9Cz+pTmLf0HEyy8ZtygEOgW9RWE5cIvCF8BB/iXQ0CXy/BaFxASiXJYBs0IPmJXmgFlBxN6VwmLvCqDBV+Jib4LU2PujgNj7le2xV5FyBUPsvd7y2Ks0f8UQe7+M4jFPqHpXAeu6nin2rvIw9qr+R6YEdb1VDLF3lcDYu1rP4mvMWXw1EXvXMMbeQKegY+8qYOxdDRzka4CGvt6PvYlEuSwD5ms9YL4xB8zXROz9Rljs/Rpo8G9wsTdRauzdISD2rrU99ipSfs0Qe2+0PPYqzWsZYu+aKB7zhKp3HbCuG5li7zoPY6/qf2RKUNdbxxB71wmMvev1LP6tOYuvJ2Lvt4yxN9Ap6Ni7Dhh71wMH+bdAQ9/ox94kolyWAbNBD5iN5oDZQMTejcJi7wagwTfiYm+S1Ni7S0Ds/c722KtIuYEh9lawPPYqzd8xxN5vo3jME6reTcC6KjDF3k1c2yn1gbTPGHx+i4CDRZ8y6K4s5EDaZqDvgX2dUFmAbzYz+OZ74ISogkuU8+8P8r5y3Nvvo+yvcYvtwUVN4JsYDqRtAk66P0TZG6ig60gaGFuAetX1fojiG9Tqg55stv73Jxu2A2lbGSabbUCIBQfVbR6sPPyYB4KLVwfSuDkCuja5JLZd177DXBLbTqwh72A+kPYDw4G07cBJY0cUrzmdy9xbi9Zqkx2PjLlTG3OXacydxFrtLmFrtTuBptyFW6tNlrpWu1vAWu1Ptj/yKLrtZIhJCZav1SrNPzGs1QJni0vME6re3cC6EpjWand7uEVB9f8O4G901fV2M2xR2B2Fh1zwJ8Rrk7P4Hj2L/2zO4nuIePkz4xaFQKegtyjsBm5R2AMc5D8DDZ3gb1FIIcplGTC/6AGz1xwwvxCxd6+w2PsL0OB7cbE3RWrs/VlA7N1ne+xVpPyFIfamWh57leZ9DLH35yge84S84g+sK5Up9u73MPaq/kemBHW9/Qyxd7/A2HtAz+IHzVn8ABF7DzLG3kCnoGPvfmDsPQAc5AeBhk71Y28qUS7LgDmkB8xhc8AcImLvYWGx9xDQ4IdxsTdVauzdKyD2HrE99ipSHmKIvbdbHnuV5iMMsfdgFI95QtV7FFjX7Uyx96iHsVf1PzIlqOsdZYi9RwXG3mN6Fv/VnMWPEbH3V8bYG+gUdOw9Coy9x4CD/FegoW/3Y28aUS7LgDmuB8wJc8AcJ2LvCWGx9zjQ4CdwsTdNauzdLyD2/mZ77FWkPM4Qe++yPPYqzb8xxN5fo3jME6rek8C67mKKvSe5tlPqA2k/Mvj8bgEHi7Yx6K4l5EDa70DfA/s6oZYA3/zO4JtTwAlRBZco598f5H3luLenouyv8bTtwUVN4CcZDqSdBE66f0TZG6ig60gaGKeRv552r/dHFN+gVh/0ZPPnf3+yYTuQ9ifDZHMGCLHgoHrGg5WHs3kguHh1II2bI6Brk0tif+naz5lLYn8Ra8jnmA+k/cFwIO0v4KRxLorXnM5l7q1Fa7XpjkfGPK+NecE05nlirfaCsLXa80BTXsCt1aZLXas9KGCt9m/bH3kU3c4zxKS6lq/VKs1/M6zVAmeLS8wTql4nGldXXaa1WlVjacebLQqq/88Bf6P7z8wVjU9IwH7zLF5eEa37LNq5dMZW/8KMl/mi+bYoBDoFvUUhuFNCTQVXROMGeb5o3L2r629RyCDKZRkw+fWAKWAOmPzR/469BaJlxd78QIMXiMZ1rtTYe1hA7A1Dz1poSihS5o/GX7eh5bFXaQ6LxsfefNE85glVbziwroZMsTfcw9ir+h+ZEtT1whlib7jA2BuhZ/FIcxaPIGJvJGPsDXQKOvaGA2NvBHCQRwIN3dCPvZlEuSwDpqAeMFHmgClIxN4oYbG3INDgUbjYmyk19h4VEHujbY+9ipQFGWJvY8tjr9IczRB7I6N5zBOq3hhgXY2ZYm+Mh7FX9T8yJajrxTDE3hiBsTdWz+Jx5iweS8TeOMbYG+gUdOyNAcbeWOAgjwMaurEfe7OIclkGTLweMFeaAyaeiL1XCou98UCDX4mLvVlSY++vAmJvIdtjryJlPEPsbWp57FWaCzHE3rhoHvOEqrcwsK6mTLG3cDTvgbSzDJt5HhVwsOgMg+7HhBxIuwroe2BfJzwmwDdXMcwLRYATogouEg+kFYm2v8aitgcXNYGrCQN9IK0wcNItFm1voIKuI2lgFAXqVdcrFu2wDWr1QU82V//3Jxu2A2lXM0w21wAhFhxUr/Fg5aF4HgguXh1I4+YI6NrkklgJXfu15pJYCWIN+VquJ6igG5kPY/T/LYuVAE4a10bzmtO5zL21aK022/HImNdpY5Y0jXkdsVZbUtha7XVAU5bErdVmS12rPSFgrbaU7Y88im7XMcSkJyxfq1WaSzGs1QJni0vME6re64F1PcG0Vnu9h1sUVP9fC/yNrrre9QxbFK6PxkMu+BPitclZvLSexcuYs3hpIl6WYdyiEOgU9BaF64FbFEoDB3kZoKGf8LcotCTKZRkwZfWAucEcMGWJ2HuDsNhbFmjwG3Cxt6XU2HtSQOy90fbYq0hZliH2trQ89irNNzLE3jLRPOYJVW85YF0tmWJvOQ9jr+p/ZEpQ1yvHEHvLCYy95fUsfpM5i5cnYu9NjLE30Cno2FsOGHvLAwf5TUBDt/Rjbw5RLsuAuVkPmArmgLmZiL0VhMXem4EGr4CLvTlSY+8pAbG3ou2xV5HyZobY28ry2Ks0V2SIvTdF85gnVL2VgHW1Yoq9lTyMvar/kSlBXa8SQ+ytJDD23qJn8crmLH4LEXsrM8beQKegY28lYOy9BTjIKwMN3cqPvblEuSwDpooeMLeaA6YKEXtvFRZ7qwANfisu9uZKjb1/CIi9VW2PvYqUVRhib1vLY6/SXJUh9laO5jFPqHoTgHW1ZYq9CVzbKfWBtOIMPm8n4GDRNQy62ws5kJYI9D2wrxPaC/BNIoNvkoATogouEg+kJUXbX2Oy7cFFTeAJDAfSEoCTbkq0vYEKuo6kgZEM1KuulxLtsA1q9UFPNqn//cmG7UBaKsNkkwaEWHBQTfNg5SE9DwQXrw6kcXMEdG1ySSxD136buSSWQawh38Z8IC2F4UBaBnDSuC2a15zOZe6tPWu1SZ4Z83ZtzDtMY95OrNXeIWyt9nagKe+IxnWu1LXaMwLWaqvZ/sij6HY7Q0zqaPlardJcjWGtFjhbXGKeUPVWB9bVkWmttrqHWxRU/98G/I2uul51hi0K1aPxkAv+hHhtcha/U8/id5mz+J1EvLyLcYtCoFPQWxSqA7co3Akc5HcBDd0xz29RSEogymUZMDX0gKlpDpgaROytKSz21gAavCYu9iZIjb1/CYi9d9seexUpazDE3lcsj71K890MsfeuaB7zhKq3FrCuV5hiby0PY+8/MAamBHW9Wgyxt5bA2Ftbz+J1zFm8NhF76zDG3kCnoGNvLWDsrQ0c5HWAhn7Fj72JRLksA+YePWDqmgPmHiL21hUWe+8BGrwuLvYmSo295wXE3nq2x15FynsYYm93y2Ov0lyPIfbWieYxT6h66wPr6s4Ue+t7GHtV/yNTgrpefYbYW19g7L1Xz+INzFn8XiL2NmCMvYFOQcfe+sDYey9wkDcAGrq7H3uTiHJZBkxDPWAamQOmIRF7GwmLvQ2BBm+Ei71JUmPv3wJi7322x15FyoYMsbe35bFXab6PIfY2iOYxT6h67wfW1Zsp9t7PtZ1SH0hLZ/B5PwEHi9IYdPcXciDtAaDvgX2d0F+Abx5g8E1j4ISogovEA2mNo+2v8UHbg4uawO9nOJB2P3DSfSja3kAFXUfSwHgQqFdd76Foh21Qqw96smny359s2A6kNWGYbB4GQiw4qD7swcpD0zwQXLw6kMbNEdC1ySWxR3TtzcwlsUeINeRmzAfSHmI4kPYIcNJoFs1rTucy99aitdpkxyNjPqqN+ZhpzEeJtdrHhK3VPgo05WO4tdpkqWu1V+S3v8bHbX/kUXR7lCEmDbZ8rVZpfpxhrRY4W1xinlD1NgfWNZhprba5h1sUVP83A/5GV12vOcMWhebReMgFf0K8NjmLt9Cz+BPmLN6CiJdPMG5RCHQKeotCc+AWhRbAQf4E0NCD/S0KKUS5LAPmST1gMs0B8yQRezOFxd4ngQbPxMXeFKmxN7+A2Jtle+xVpHySIfYOszz2Ks1ZDLH3iWge84SqNxtY1zCm2JvtYexV/Y9MCep62QyxN1tg7G2pZ/EccxZvScTeHMbYG+gUdOzNBsbelsBBngM09DA/9qYS5bIMmFw9YJ4yB0wuEXufEhZ7c4EGfwoXe1Olxt4wAbH3adtjryJlLkPsHWl57FWan2aIvTnRPOYJ+S/WAesayRR7W3kYe1X/I1OCul4rhtjbSmDsfUbP4s+as/gzROx9ljH2BjoFHXtbAWPvM8BB/izQ0CP92JtGlMsyYFrrAdPGHDCtidjbRljsbQ00eBtc7E2TGnsjBMTetrbHXkXK1gyxd6zlsVdpbssQe5+N5jFPqHqfA9Y1lin2Pse1nVIfSGvK4PMJAg4WPcyge6KQA2nPA30P7OuEiQJ88zyDb9oBJ0QVXCQeSGsXbX+N7W0PLmoCf47hQNpzwEn3hWh7AxV0HUkDoz1Qr7reC9EO26BWH/Rk8+J/f7JhO5D2IsNk0wEIseCg2sGDlYeOeSC4eHUgjZsjoGuTS2Iv6do7mUtiLxFryJ2YD6S9wHAg7SXgpNEpmteczmXurUVrtemOR8Z8WRuzs2nMl4m12s7C1mpfBpqyM26tNl3qWm1BAWu1r9j+yKPo9jJDTJpq+Vqt0vwKw1otcLa4xDyh6u0CrGsq01ptFw+3KKj+7wT8ja66XheGLQpdovGQC/6EeG1yFu+qZ/Fu5izelYiX3Ri3KAQ6Bb1FoQtwi0JX4CDvBjT0VH+LQgZRLsuAeVUPmO7mgHmViL3dhcXeV4EG746LvRlSY2+0gNjbw/bYq0j5KkPsnWV57FWaezDE3m7RPOYJVW9PYF2zmGJvTw9jr+p/ZEpQ1+vJEHt7Coy9r+lZvJc5i79GxN5ejLE30Cno2NsTGHtfAw7yXkBDz/JjbyZRLsuA6a0HTB9zwPQmYm8fYbG3N9DgfXCxN1Nq7I0VEHv72h57FSl7M8Te+ZbHXqW5L0Ps7RXNY56Q/6QBsK75TLG3n4exV/U/MiWo6/VjiL39BMbe/noWH2DO4v2J2DuAMfYGOgUde/sBY29/4CAfADT0fD/2ZhHlsgyYgXrADDIHzEAi9g4SFnsHAg0+CBd7s6TG3ngBsXew7bFXkXIgQ+x9z/LYqzQPZoi9A6J5zBOq3iHAut5jir1DuLZT6gNpHRl8/oGAg0UdGHR/KORA2utA3wP7OuFDAb55ncE3bwAnRBVcJB5IeyPa/hqH2h5c1AQ+hOFA2hDgpDss2t5ABV1H0sAYCtSrrjcs2mEb1OqDnmze/O9PNmwH0t5kmGzeAkIsOKi+5cHKw/A8EFy8OpDGzRHQtcklsRG69pHmktgIYg15JPOBtGEMB9JGACeNkdG85nQuc28tWqvNdjwy5tvamKNMY75NrNWOErZW+zbQlKNwa7XZUtdqCwlYqx1t+yOPotvbDDHpU8vXapXm0QxrtcDZ4hLzhKp3DLCuT5nWasd4uEVB9f9I4G901fXGMGxRGBONh1zwJ8Rrk7P4WD2LjzNn8bFEvBzHuEUh0CnoLQpjgFsUxgIH+TigoT/1tyi0JMplGTDj9YCZYA6Y8UTsnSAs9o4HGnwCLva2lBp7rxIQeyfaHnsVKcczxN6llsdepXkiQ+wdF81jnlD1TgLWtZQp9k7yMPaq/kemBHW9SQyxd5LA2DtZz+JTzFl8MhF7pzDG3kCnoGPvJGDsnQwc5FOAhl7qx94colyWATNVD5hp5oCZSsTeacJi71SgwafhYm+O1NhbVEDsnW577FWknMoQe1dYHnuV5ukMsXdKNI95QtU7A1jXCqbYO8PD2Kv6H5kS1PVmMMTeGQJj70w9i88yZ/GZROydxRh7A52Cjr0zgLF3JnCQzwIaeoUfe3OJclkGzGw9YOaYA2Y2EXvnCIu9s4EGn4OLvblSY+/VAmLvXNtjryLlbIbYu8by2Ks0z2WIvbOiecwTqt55wLrWMMXeeVzbKfWBtOEMPl8r4GDRWwy61wk5kDYf6HtgXyesE+Cb+Qy+eQc4IargIvFA2jvR9te4wPbgoibweQwH0uYBJ92F0fYGKug6kgbGAqBedb2F0Q7boFYf9GTz7n9/smE7kPYuw2TzHhBiwUH1PWLlAV37+4DaUzOrZuSkpqZx1rkIUGdWVmpaZk56CmedHwDqTMpOzclNSkvkrPNDQJ2ZKcm5uSmXvj4VXedHgDpTEqrmpCSm5XLW+TGgzoysqimp6enZnHV+AqgzITc9qWVGZhZnnZ8i+j0rp2p2y4QMVdtVusZlBS8yVf28POjnL4J+/jLo5xVBP68M+vmroJ9XBf28OujnNUE/fx308zdBP68N+nld0M/rg37+Nujn96P/7+dFQT9/EPTzh0E/fxT088dBP38S9POn+ufP3H8udr9L3O/n7nep+13mfpe73y/0Ipaam8Kdy3/uCrHPAhZTdd3K+r+RmsJz3bR0pusmy7oPqTlM15V2H5jqTazKVG+GrPvw79e3231/07KY7m9LpnqTmOpNY6qX6T4kZjNd1/fZxetyzcdJsq6bmsB0XabxxtVvKbnC+o1p3kxjmt/YxpvP338+/jyv62XijjQ+sD2/Mc0Xl64/2n8f0jgOiwc+SdTuNfTvJwBbKf/34bsXyf937QLO/y0KqY9/kwKf5KpXBOm/Uv/8pbuItsL9rnS/X7nfVe53tftd436/dr/fuN+17ned+13vfr91vxvc70b3+525V/XLoBW8QNsKom0l0fYV0baKaFtNtK0h2r4m2r4h2tYSbeuItvVE27dE2waibSPR9p1uU/85BtkhDn16IvBBr4rjNlsne3Y6YZO+T5tNA28iNltvFrbZehNwK8LmaFznUiQGdPD/PoHroeleXMBm6++Re5b+37wsNdSjJcqk30fjz0pBbwTerCSNtmga/WDSaAtxVuoHxrNSgU6BbiwzOiVUum0B0u0HoFmETrkJjkcm36pNvs00+VZiyt0mbMrdCjTlNtyUmyB1yr1WwJT7o+3bhBXdtjJsLdxo+fkmpfnHaPz5JuBscYl5QtW7HVjXRqbzTds10L041q/6/4doXCpS19vOEFW3C4yqO/QsvtOcxXcQUXUnY1QNdAr6WP92YFTdARzkO4GG3pjnj/UnJxLlsgyYXXrA/GQOmF1E7P1JWOzdBTT4T7jYmyg19pYUEHt32x57FSl3McTeLZbHXqV5N0Ps3RnNY55Q9e4B1rWFKfbu8TD2qv5HpgR1vT0MsXePwNj7s57FfzFn8Z+J2PsLY+wNdAo69u4Bxt6fgYP8F6Cht/ixN4kol2XA7NUDZp85YPYSsXefsNi7F2jwfbjYmyQ19l4vIPbutz32KlLuZYi92y2PvUrzfobY+0s0j3lC1XsAWNd2pth7gCEBBff3AfTvqN17cQDYRwej7R1/gU8+cL8gdx0dAnqcQ6vaorcJ7JdD0fhJ60vm/Q3oR0N1Tw9G/9/1UbU7xCfEa5Op97Cu/YiZeg8Tj4lH/h8gWTWUT9CNBBn/f8n3MND0R5jN6Vzm3lr0OJbseGTMo9qYx0xjHiUex44Jexw7CjTlMdzjWLLUx7EyAh7HfrX9cUzR7SjD49geyx/HlOZfGR7HgLPFJeYJVe9xYF17mB7Hjnv4WwjV/0eAi7bqescZfgtxPBoPueBPiNcmZ/ETehb/zZzFTxDx8jfG30IEOgX9W4jjwN9CnAAO8t+Aht7j/xYihSiXZcCc1APmd3PAnCRi7+/CYu9JoMF/x8XeFKmx9wYBsfeU7bFXkfIkQ+zdb3nsVZpPMcTe36J5zBOq3tPI344wxd7THsZe1f/IlKCud5oh9p4WGHv/0LP4n+Ys/gcRe/9kjL2BTkHH3tPA2PsHcJD/CTT0fj/2phLlsgyYM3rAnDUHzBki9p4VFnvPAA1+Fhd7U6XG3nICYu9ftsdeRcozDLH3iOWxV2n+iyH2/hnNY55Q9Z4D1nWEKfae8zD2qv5HpgR1vXMMsfecwNh7Xs/iF8xZ/DwRey8wxt5Ap6Bj7zlg7D0PHOQXgIY+4sfeNKJclgHztx4w/7xNLXhw/E3EXvVfKm0UZXPs/RtocKUd1blSY+9NAmLvFTHgGtGUUKT8myH2nrA89v6jOQYfey9E85gnVL35cEZMOMEUe/PFMG2ndGs+dJn9uaHe1/zAAa5AHOP8+4O6vsN0b/PH2F9jAdtBrICkBgD6UEQ+IETCYuydIKDPxRoYBYB61fXCYvCD2qtN/Ry1O8QnxGuTjxXhuvYI87FC/QvzOTyCaxYKupGmWUN9tAgHGjUihteczmXurUXPu+mOR8aM1MYsaBpT/QvzebegsOfdSKApC+Ked9OlPu9WEPC8G2V7zFJ0Cwwu5HX/sPx5V2mOYnjeBc4Wl5gnVL3RwLr+YHrejY7x7tc8qv8jAPc3sCqurhcdg09I0TF4yAV/Qrw2OYvH6Fk81pzFY4h4GRvD92ueQKegf80THYNLBTHAQR4LNPQf/q95MohyWQZMnB4w8eaAiSNib7yw2BsHNHg8LvZmSI29lQTE3ittj72KlHEMsfec5bFXab6SIfbGxvCYJ1S9hYB1nWOKvYU8jL2q/5EpQV2vEEPsLSQw9hbWs/hV5ixemIi9VzHG3kCnoGNvIWDsLQwc5FcBDX3Oj72ZRLksA6aIHjBFzQFThIi9RYXF3iJAgxfFxd5MqbG3soDYW8z22KtIWYQh9l5xtd2xV2kuxhB7r4rhMU+oeq8G1oXs22CgX+1h7FX9j0wJ6npXM8TeqwXG3mv0LF7cnMWvIWJvccbYG+gUdOy9Ghh7rwEO8uJAQyMHudDYm0WUyzJgSugBc605YEoQsfdaYbG3BNDg1+Jib5bU2HurgNh7ne2xV5GyBEPsDbc89irN1zHE3uIxPOYJVW9JYF3hTLG3JNd2yqBN/fkYrovqo4LMY6ZqaJ9//mD8oWj8C9ZLAb1p+z1U968UA2+vB040qn91ELvkg7yvHPf2+hj7ayxteyBQE2NJhsMlJYGTWZkYe4MKxwRTGny4pEwMz6CWMuGUtXPCSeC4h+r+lWWYcG4Agiw4BN7AGAK5/HSjpQHGqwNfXDwxPyFem1xyKqdrL28uOZUj1mjLMx/4KsNw4KsccPIoH8NrTucy99aitdBsxyNj3qSNebNpzJuItdCbha2F3gQ05c24tdBsqWuhCQLWQivY/uij6HYTQ1SKtXwtVGmuwLAWCpwtLjFPqHorAuuKZVoLrejhFgDV/+WBvzFV16vIsAWgYgwecsGfEK9NzuKV9Cx+izmLVyLi5S2MWwACnYLeAlARuAWgEnCQ3wI0dKy/BaAlUS7LgKmsB0wVc8BUJmJvFWGxtzLQ4FVwsbel1NibJCD23mp77FWkrMwQewtbHnuV5lsZYu8tMTzmCVVvVWBdhZlib1UPY6/qf2RKUNeryhB7qwqMvQl6Fk80Z/EEIvYmMsbeQKegY29VYOxNAA7yRKChC/uxN4col2XAJOkBk2wOmCQi9iYLi71JQIMn42JvjtTYmyIg9qbYHnsVKZMYYu/VlsdepTmFIfYmxvCYJ1S9qcC6rmaKvakexl7V/8iUoK6XyhB7UwXG3jQ9i6ebs3gaEXvTGWNvoFPQsTcVGHvTgIM8HWjoq/3Ym0uUyzJgMvSAuc0cMBlE7L1NWOzNABr8NlzszZUae9MExN7bbY+9ipQZDLH3Ostjr9J8O0PsTY/hMU+oeu8A1nUdU+y9g3mv740cB20EHDC6gUF36avx8HUc/AReDeh7YF8nlBbgm2oMvqkOnBBVcIlx/v1B3leOe1s9xv4a77Q9uKgJ/A6Gg2l3ACfdu2LsDVTQdSQNjDuBev85SR3DN6jVBz3Z1PjvTzZsh9JqMEw2NYEQCw6qNT1Yebg7DwQXrw6kcXMEdG1ySayWrr22uSRWi1hDrs18IO0uhgNptYCTRu0YXnM6l7m39qzVpnhmzDramPeYxqxDrNXeI2yttg7QlPfE4DpX6lpthoC12rq2P/IoutVhiEk3Wr5WqzTXZVirBc4Wl5gnVL31gHXdyLRWW8/DLQqq/2sDf6OrrlePYYtCvRg85II/IV6bnMXr61n8XnMWr0/Ey3sZtygEOgW9RaEecItCfeAgvxdo6Bvz/BaFlASiXJYB00APmIbmgGlAxN6GwmJvA6DBG+Jib4LU2Hu7gNjbyPbYq0jZgCH2VrA89irNjRhi770xPOYJVe99wLoqMMXe+zyMvar/kSlBXe8+hth7n8DYe7+exR8wZ/H7idj7AGPsDXQKOvbeB4y99wMH+QNAQ1fwY28iUS7LgGmsB8yD5oBpTMTeB4XF3sZAgz+Ii72JUmNvNQGx9yHbY68iZWOG2FvF8tirND/EEHsfiOExT6h6mwDrqsIUe5t4GHtV/yNTgrpeE4bY20Rg7H1Yz+JNzVn8YSL2NmWMvYFOQcfeJsDY+zBwkDcFGrqKH3uTiHJZBswjesA0MwfMI0TsbSYs9j4CNHgzXOxNkhp77xQQex+1PfYqUj7CEHuTLI+9SvOjDLG3aQyPeULV+xiwriSm2PsY13ZKfSDtbgafpwo4WFSTQXeakANpjwN9D+zrhDQBvnmcwTfNgROiCi4xzr8/yPvKcW+bx9hfYwvbg4uawB9jOJD2GHDSfSLG3kAFXUfSwGgB1Kuu90QM36BWH/Rk8+R/f7JhO5D2JMNkkwmEWHBQzfRg5SErDwQXrw6kcXMEdG1ySSxb197SXBLLJtaQWzIfSHuC4UBaNnDSaBnDa07nMvfWorXaZMcjY+ZoY+aaxswh1mpzha3V5gBNmYtbq02WulZbQ8Ba7VO2P/IouuUwxKTbLV+rVZqfYlirBc4Wl5gnVL1PA+u6nWmt9mkPtyio/m8J/I2uut7TDFsUno7BQy74E+K1yVm8lZ7FnzFn8VZEvHyGcYtCoFPQWxSeBm5RaAUc5M8ADX27v0UhhSiXZcA8qwdMa3PAPEvE3tbCYu+zQIO3xsXeFKmx924BsbeN7bFXkfJZhth7l+WxV2luwxB7n4nhMU+oetsC67qLKfa29TD2qv5HpgR1vbYMsbetwNj7nJ7Fnzdn8eeI2Ps8Y+wNdAo69rYFxt7ngIP8eaCh7/JjbypRLsuAaacHTHtzwLQjYm97YbG3HdDg7XGxN1Vq7K0tIPa+YHvsVaRsxxB7a1see5XmFxhi7/MxPOYJVe+LwLpqM8XeFz2Mvar/kSlBXe9Fhtj7osDY20HP4h3NWbwDEXs7MsbeQKegY++LwNjbATjIOwINXduPvWlEuSwD5iU9YDqZA+YlIvZ2EhZ7XwIavBMu9qZJjb33CIi9L9seexUpX2KIvfUtj71K88sMsbdjDI95QtXbGVhXfabY25lrO6U+kJbF4POGAg4WZTLobiTkQNorQN8D+zqhkQDfvMLgmy7ACVEFlxjn3x/kfeW4t11i7K+xq+3BRU3gnRkOpHUGTrrdYuwNVNB1JA2MrkC96nrdYvgGtfqgJ5tX//uTDduBtFcZJpvuQIgFB9XuHqw89MgDwcWrA2ncHAFdm1wS66lrf81cEutJrCG/xnwgrRvDgbSewEnjtRheczqXubcWrdWmOx4Zs5c2Zm/TmL2ItdrewtZqewFN2Ru3Vpsuda22noC12j62P/IouvViiEmNLV+rVZr7MKzVAmeLS8wTqt6+wLoaM63V9vVwi4Lq/9eAv9FV1+vLsEWhbwwecsGfEK9NzuL99Cze35zF+xHxsj/jFoVAp6C3KPQFblHoBxzk/YGGbuxvUcggymUZMAP0gBloDpgBROwdKCz2DgAafCAu9mZIjb33Coi9g2yPvYqUAxhib1PLY6/SPIgh9vaP4TFPqHoHA+tqyhR7B3sYe1X/I1OCut5ghtg7WGDsHaJn8dfNWXwIEXtfZ4y9gU5Bx97BwNg7BDjIXwcauqkfezOJclkGzBt6wAw1B8wbROwdKiz2vgE0+FBc7M2UGnsbCoi9w2yPvYqUbzDE3sctj71K8zCG2Pt6DI95QtX7JrCux5li75sexl7V/8iUoK73JkPsfVNg7H1Lz+LDzVn8LSL2DmeMvYFOQcfeN4Gx9y3gIB8ONPTjfuzNIsplGTAj9IAZaQ6YEUTsHSks9o4AGnwkLvZmSY299wmIvW/bHnsVKUcwxN5My2Ov0vw2Q+wdHsNjnlD1jgLWlckUe0dxbafUB9J6MPi8pYCDRd0ZdOcIOZA2Guh7YF8n5AjwzWgG34wBTogquMQ4//4g7yvHvR0TY3+NY20PLmoCH8VwIG0UcNIdF2NvoIKuI2lgjAXqVdcbF8M3qNUHPdmM/+9PNmwH0sYzTDYTgBALDqoTPFh5mJgHgotXB9K4OQK6NrkkNknXPtlcEptErCFPZj6QNo7hQNok4KQxOYbXnM5l7q1Fa7XZjkfGnKKNOdU05hRirXaqsLXaKUBTTsWt1WZLXat9QMBa7TTbH3kU3aYwxKRWlq/VKs3TGNZqgbPFJeYJVe90YF2tmNZqp3u4RUH1/2Tgb3TV9aYzbFGYHoOHXPAnxGuTs/gMPYvPNGfxGUS8nMm4RSHQKegtCtOBWxRmAAf5TKChW/lbFFoS5bIMmFl6wMw2B8wsIvbOFhZ7ZwENPhsXe1tKjb0PCoi9c2yPvYqUsxhib1vLY6/SPIch9s6M4TFPqHrnAutqyxR753oYe1X/I1OCut5chtg7V2Dsnadn8fnmLD6PiL3zGWNvoFPQsXcuMPbOAw7y+UBDt/Vjbw5RLsuAeUcPmAXmgHmHiL0LhMXed4AGX4CLvTlSY28TAbF3oe2xV5HyHYbY+4LlsVdpXsgQe+fH8JgnVL3vAut6gSn2vuth7FX9j0wJ6nrvMsTedwXG3vf0LP6+OYu/R8Te9xljb6BT0LH3XWDsfQ84yN8HGvoFP/bmEuWyDJhFesB8YA6YRUTs/UBY7F0ENPgHuNibKzX2NhUQez+0PfYqUi5iiL2dLI+9SvOHDLH3/Rge84Sq9yNgXZ2YYu9HXNsp9YG0iQw+f0XAwaIJDLq7CDmQ9jHQ98C+TugiwDcfM/jmE+CEqIJLjPPvD/K+ctzbT2Lsr/FT24OLmsA/YjiQ9hFw0v0sxt5ABV1H0sD4FKhXXe+zGL5BrT7oyWbxf3+yYTuQtphhslkChFhwUF3iwcrD53kguHh1II2bI6Brk0tiS3Xty8wlsaXEGvIy5gNpnzEcSFsKnDSWxfCa07nMvbVnrTbVM2Mu18b8wjTmcmKt9gtha7XLgab8IgbXuVLXapsJWKv90vZHHkW35Qwxqbvla7VK85cMa7XA2eIS84SqdwWwru5Ma7UrPNyioPp/GfA3uup6Kxi2KKyIwUMu+BPitclZfKWexb8yZ/GVRLz8inGLQqBT0FsUVgC3KKwEDvKvgIbunue3KKQmEOWyDJhVesCsNgfMKiL2rhYWe1cBDb4aF3sTpMbexwTE3jW2x15FylUMsbe35bFXaV7DEHu/iuExT6h6vwbW1Zsp9n7tYexV/Y9MCep6XzPE3q8Fxt5v9Cy+1pzFvyFi71rG2BvoFHTs/RoYe78BDvK1QEP39mNvIlEuy4BZpwfMenPArCNi73phsXcd0ODrcbE3UWrsbS4g9n5re+xVpFzHEHsHWB57leZvGWLv2hge84SqdwOwrgFMsXeDh7FX9T8yJajrbWCIvRsExt6Nehb/zpzFNxKx9zvG2BvoFHTs3QCMvRuBg/w7oKEH+LE3iSiXZcBs0gNmszlgNhGxd7Ow2LsJaPDNuNibJDX2PiEg9n5ve+xVpNzEEHtftzz2Ks3fM8Te72J4zBOq3i3Aul5nir1buLZT6gNpnzP4fJiAg0VLGHS/KeRA2g9A3wP7OuFNAb75gcE3W4ETogouMc6/P8j7ynFvt8bYX+M224OLmsC3MBxI2wKcdH+MsTdQQdeRNDC2AfWq6/0Ywzeo1Qc92Wz/7082bAfStjNMNjuAEAsOqjs8WHnYmQeCi1cH0rg5Aro2uSS2S9f+k7kktotYQ/6J+UDajwwH0nYBJ42fYnjN6Vzm3lq0VpvseGTM3dqYe0xj7ibWavcIW6vdDTTlHtxabbLUtdpMAWu1P9v+yKPotpshJo20fK1Waf6ZYa0WOFtcYp5Q9f4CrGsk01rtLx5uUVD9/xPwN7rqer8wbFH4JQYPueBPiNcmZ/G9ehbfZ87ie4l4uY9xi0KgU9BbFH4BblHYCxzk+4CGHulvUUghymUZMPv1gDlgDpj9ROw9ICz27gca/AAu9qZIjb3ZAmLvQdtjryLlfobYO9by2Ks0H2SIvftieMwT8oo/sK6xTLH3kIexV/U/MiWo6x1iiL2HBMbew3oWP2LO4oeJ2HuEMfYGOgUdew8BY+9h4CA/AjT0WD/2phLlsgyYo3rAHDMHzFEi9h4TFnuPAg1+DBd7U6XG3hwBsfdX22OvIuVRhtg7yfLYqzT/yhB7j8TwmCdUvceBdU1iir3HPYy9qv+RKUFd7zhD7D0uMPae0LP4b+YsfoKIvb8xxt5Ap6Bj73Fg7D0BHOS/AQ09yY+9aUS5LAPmpB4wv5sD5iQRe38XFntPAg3+Oy72pkmNvU8JiL2nbI+9ipQnGWLvdMtjr9J8iiH2/hbDY55Q9Z4G1jWdKfae5tpOqQ+k7WTw+SwBB4t2MOieLeRA2h9A3wP7OmG2AN/8weCbP4ETogouMc6/P8j7ynFv/4yxv8YztgcXNYGfZjiQdho46Z6NsTdQQdeRNDDOIH897V7vbAzfoFYf9GTz139/smE7kPYXw2RzDgix4KB6zoOVh/N5ILh4dSCNmyOga5NLYhd07X+bS2IXiDXkv5kPpJ1lOJB2AThp/B3Da07nMvfWorXadMcjYzqx+l7EGiZU/8Jcq1X/pdJGUTav1SoNqLquiMV1rtS12lYC1mrzxYJrRFPinykgFn/d+Zav1SrNqnPQa7XA2eIS84SqNz/OiAnzmdZq88d6t0VB9f/fwN/oquvlj8UnpPyxeMgFf0K8NjmLF9CzeJg5i6t/YcbLsFi+LQqBTkFvUcgfi0sFBYCDPCwWd+/m+1sUMohyWQZMuB4wEeaACSdib4Sw2BsONHgELvZmSI29zwqIvZG2x15FynCG2Pue5bFXaY5kiL1hsTzmCVVvQWBd7zHF3oIexl7V/8iUoK5XkCH2FhQYe6P0LB5tzuJRROyNZoy9gU5Bx96CwNgbBRzk0UBDv+fH3kyiXJYBE6MHTKw5YGKI2BsrLPbGAA0ei4u9mVJjbxsBsTfO9tirSBnDEHs/sjz2Ks1xDLE3OpbHPKHqjQfW9RFT7I33MPaq/kemBHW9eIbYGy8w9l6pZ/FC5ix+JRF7CzHG3kCnoGNvPDD2Xgkc5IWAhv7Ij71ZRLksA6awHjBXmQOmMBF7rxIWewsDDX4VLvZmSY29zwmIvUVsj72KlIUZYu9iy2Ov0lyEIfYWiuUxT6h6iwLrWswUe4vG8h5IO8+w53mpgINF5xh0LxNyIK0Y0PfAvk5YJsA3xRjmhauBE6IKLhIPpF0da3+N19geXNQEriYM9IG0osBJt3isvYEKuo6kgXENUK+6XvFYh21Qqw96sinx359s2A6klWCYbK4FQiw4qF7rwcrDdXkguHh1II2bI6Brk0tiJXXtpcwlsZLEGnIprieooBuZD2P0/y2LlQROGqViec3pXObeWrRWm+14ZMzrtTFLm8a8nlirLS1srfZ6oClL49Zqs6Wu1bYTsFZbxvZHHkW36xli0grL12qV5jIMa7XA2eIS84SqtyywrhVMa7VlPdyioPq/FPA3uup6ZRm2KJSNxUMu+BPitclZ/AY9i99ozuI3EPHyRsYtCoFOQW9RKAvconADcJDfCDT0Cn+LQkuiXJYBU04PmPLmgClHxN7ywmJvOaDBy+Nib0upsfcFAbH3JttjryJlOYbYu8by2Ks038QQe2+M5TFPqHpvBta1hin23uxh7FX9j0wJ6no3M8TemwXG3gp6Fq9ozuIViNhbkTH2BjoFHXtvBsbeCsBBXhFo6DV+7M0hymUZMJX0gLnFHDCViNh7i7DYWwlo8FtwsTdHauztICD2VrY99ipSVmKIvestj71Kc2WG2Fsxlsc8oeqtAqxrPVPsreJh7FX9j0wJ6npVGGJvFYGx91Y9i1c1Z/FbidhblTH2BjoFHXurAGPvrcBBXhVo6PV+7M0lymUZMAl6wCSaAyaBiL2JwmJvAtDgibjYmys19r4kIPYm2R57FSkTGGLvJstjr9KcxBB7q8bymCdUvcnAujYxxd5kru2U+kDadQw+3yLgYNG1DLp/EHIgLQXoe2BfJ/wgwDcpDL5JBU6IKrhIPJCWGmt/jWm2Bxc1gSczHEhLBk666bH2BiroOpIGRhpQr7peeqzDNqjVBz3ZZPz3Jxu2A2kZDJPNbUCIBQfV2zxYebg9DwQXrw6kcXMEdG1ySewOXXs1c0nsDmINuRrzgbR0hgNpdwAnjWqxvOZ0LnNv7VmrTfPMmNW1Me80jVmdWKu9U9habXWgKe+MxXWu1LXalwWs1d5l+yOPolt1hpi03fK12n8GI8NaLXC2uMQ8oeqtAaxrO9NabQ0Ptyio/q8G/I2uul4Nhi0KNWLxkAv+hHhtchavqWfxu81ZvCYRL+9m3KIQ6BT0FoUawC0KNYGD/G6gobfn+S0KaQlEuSwDppYeMLXNAVOLiL21hcXeWkCD18bF3gSpsfcVAbG3ju2xV5GyFkPs3W157FWa6zDE3rtjecwTqt57gHXtZoq993gYe1X/I1OCut49DLH3HoGxt66exeuZs3hdIvbWY4y9gU5Bx957gLG3LnCQ1wMaercfexOJclkGTH09YO41B0x9IvbeKyz21gca/F5c7E2UGnu7Coi9DWyPvYqU9Rli7z7LY6/S3IAh9taL5TFPqHobAuvaxxR7G3oYe1X/I1OCul5DhtjbUGDsbaRn8fvMWbwREXvvY4y9gU5Bx96GwNjbCDjI7wMaep8fe5OIclkGzP16wDxgDpj7idj7gLDYez/Q4A/gYm+S1Nj7qoDY29j22KtIeT9D7D1seexVmhszxN77YnnME6reB4F1HWaKvQ9ybafUB9JuZ/D5MQEHi25j0P2rkANpDwF9D+zrhF8F+OYhBt80AU6IKrhIPJDWJNb+Gh+2PbioCfxBhgNpDwIn3aax9gYq6DqSBsbDQL3qek1jHbZBrT7oyeaR//5kw3Yg7RGGyaYZEGLBQbWZBysPj+aB4OLVgTRujoCuTS6JPaZrf9xcEnuMWEN+nPlAWlOGA2mPASeNx2N5zelc5t5atFab7HhkzObamC1MYzYn1mpbCFurbQ40ZQvcWm2y1LXaHgLWap+w/ZFH0a05Q0w6aflardL8BMNaLXC2uMQ8oep9EljXSaa12ic93KKg+v9x4G901fWeZNii8GQsHnLBnxCvTc7imXoWzzJn8UwiXmYxblEIdAp6i8KTwC0KmcBBngU09El/i0IKUS7LgMnWA6alOWCyidjbUljszQYavCUu9qZIjb2vCYi9ObbHXkXKbIbY+6flsVdpzmGIvVmxPOYJVW8usK4/mWJvroexV/U/MiWo6+UyxN5cgbH3KT2LP23O4k8Rsfdpxtgb6BR07M0Fxt6ngIP8aaCh//RjbypRLsuAaaUHzDPmgGlFxN5nhMXeVkCDP4OLvalSY29vAbH3WdtjryJlK4bYe97y2Ks0P8sQe5+O5TFPqHpbA+s6zxR7W3sYe1X/I1OCul5rhtjbWmDsbaNn8bbmLN6GiL1tGWNvoFPQsbc1MPa2AQ7ytkBDn/djbxpRLsuAeU4PmOfNAfMcEXufFxZ7nwMa/Hlc7E2TGnv7Coi97WyPvYqUzzHE3nzX2B17leZ2DLG3bSyPeULV2x5YF7Jvg4Henms7pT6Q9iiDz8OYfV41tM8/e72bMegOvwYPX8fBT+AvAH0P7OuEcAG+eYHBNy8CJ0QVXCQeSHsx1v4aO9geXNQE3p7hQFp74KTbMdbeQAVdR9LA6ADUq67XMdZhG9Tqg55sXvrvTzZsB9JeYphsOgEhFhxUO3mw8vByHgguXh1I4+YI6NrkklhnXfsr5pJYZ2IN+RXmA2kdGQ6kdQZOGq/E8prTucy9tWitNt3xyJhdtDG7msbsQqzVdhW2VtsFaMquuLXadKlrtf0FrNV2s/2RR9GtC0NMirJ8rVZp7sawVgucLS4xT6h6XwXWFcW0Vvuqh1sUVP+/AvyNrrreqwxbFF6NxUMu+BPitclZvLuexXuYs3h3Il72YNyiEOgU9BaFV4FbFLoDB3kPoKGjmJ/JHHCfM8TeDKJclgHTUw+Y18wB05OIva8Ji709gQZ/DRd7M6TG3oECYm8v22OvImVPhtgbb3nsVZp7McTeHrE85glVb29gXfFMsbe3h7FX9T8yJajr9WaIvb0Fxt4+ehbva87ifYjY25cx9gY6BR17ewNjbx/gIO8LNHS8H3sziXJZBkw/PWD6mwOmHxF7+wuLvf2ABu+Pi72ZUmPvYAGxd4DtsVeRsh9D7C1ieexVmgcwxN6+sTzmCVXvQGBdRZhi70APY6/qf2RKUNcbyBB7BwqMvYP0LD7YnMUHEbF3MGPsDXQKOvYOBMbeQcBBPhho6CJ+7M0iymUZMEP0gHndHDBDiNj7urDYOwRo8NdxsTdLaux9XUDsfcP22KtIOYQh9ha3PPYqzW8wxN7BsTzmCVXvUGBdxZli71Cu7ZT6QNrLDD6/TsDBok4MuksKOZA2DOh7YF8nlBTgm2EMvnkTOCGq4CLxQNqbsfbX+JbtwUVN4EMZDqQNBU66w2PtDVTQdSQNjLeAetX1hsc6bINafdCTzYj//mTDdiBtBMNkMxIIseCgOtKDlYe380Bw8epAGjdHQNcml8RG6dpHm0tio4g15NHMB9KGMxxIGwWcNEbH8prTucy9tWitNtvxyJhjtDHHmsYcQ6zVjhW2VjsGaMqxuLXabKlrtUMFrNWOs/2RR9FtDENMKmP5Wq3SPI5hrRY4W1xinlD1jgfWVYZprXa8h1sUVP+PBv5GV11vPMMWhfGxeMgFf0K8NjmLT9Cz+ERzFp9AxMuJjFsUAp2C3qIwHrhFYQJwkE8EGrqMv0WhJVEuy4CZpAfMZHPATCJi72RhsXcS0OCTcbG3pdTY+6aA2DvF9tirSDmJIfaWtzz2Ks1TGGLvxFge84SqdyqwrvJMsXeqh7FX9T8yJajrTWWIvVMFxt5pehafbs7i04jYO50x9gY6BR17pwJj7zTgIJ8ONHR5P/bmEOWyDJgZesDMNAfMDCL2zhQWe2cADT4TF3tzpMbe4QJi7yzbY68i5QyG2FvJ8tirNM9iiL3TY3nME6re2cC6KjHF3tkexl7V/8iUoK43myH2zhYYe+foWXyuOYvPIWLvXMbYG+gUdOydDYy9c4CDfC7Q0JX82JtLlMsyYObpATPfHDDziNg7X1jsnQc0+Hxc7M2VGntHCoi979geexUp5zHE3qqWx16l+R2G2Ds3lsc8oepdAKyrKlPsXcC1nVIfSHubwedJAg4WjWTQnSzkQNpCoO+BfZ2QLMA3Cxl88y5wQlTBReKBtHdj7a/xPduDi5rAFzAcSFsAnHTfj7U3UEHXkTQw3gPqVdd7P9ZhG9Tqg55sFv33Jxu2A2mLGCabD4AQCw6qH+igqn6+Sv/zy+j/a1sR9PPKoJ+/Cvp5VdDPq4N+XhP089dBP38T9PPaoJ/XBf28Pujnb4N+3hD088agn78L+vmzoJ8XB/28JOjnz4N+Xhr087Kgn5cH/fyF/vlD93595H4/dr+fuN9P3e9n7nex+12iH8LUvQ13Lv+5C9OPCaquW1n/N1JTeK777z9+Bbpusqz7kJrDdF1p94Gp3sSqTPVmyLoPSZmy7u+/3xsHur8tmepNYqo3jalepvuQmM10Xd9nF6/LNR8nybpuagLTdZnGG1e/peQK6zemeTONaX5jG28+f//5+PO8rpeJO9L4wPb8xjRfpCXKug8shx0DnyRq9wV6fQ2wFeh/H757kf5/1y7g/N+ikPr4NynwSa96RZD+K/XPn7uLaEvd7zL3u9z9fuF+v3S/K9zvSvf7lftd5X5Xu9817vdr9/uN+13rfteZe60+D1rdDLQtJdqWEW3LibYviLYvibYVRNtKou0rom0V0baaaFtDtH1NtH1DtK0l2tbpNvWf45Ad4tC7fwMf9Eo5brNgume7a9fr+/StaeD1xGbBb4VtFlwP/FXat7G4zpW6WXCUgM2CG5C/c/9/87K/ULdGK5NuYNjrD70ReLOSNNqoafSdSaONxF7/7xj3+gc6BboxwuiUUOm2EUi374BmETrlJjgemXyTNvlm0+SbiCl3s7ApdxPQlJtxU26C1Cl3jIAp93vbt7kpum1i2BqTbvn+fKX5+1j8/nzgbHGJeULVuwVYVzrT/vwtGuheHEtV/f8d8BSfut4Whqi6RWBU/UHP4lvNWfwHIqpuZYyqgU5BH0vdAoyqPwAH+VagodPz/LHU9ESiXJYBs00PmB/NAbONiL0/Cou924AG/xEXexOlxt5xAmLvdttjryLlNobYW83y2Ks0b2eIvVtjecwTqt4dwLqqMcXeHR7GXtX/yJSgrreDIfbuEBh7d+pZfJc5i+8kYu8uxtgb6BR07N0BjL07gYN8F9DQ1fzYm0SUyzJgftIDZrc5YH4iYu9uYbH3J6DBd+Nib5LU2DtBQOzdY3vsVaT8iSH21rQ89irNexhi765YHvOEqvdnYF01mWLvzwwJKLi/f0b/jtq9Fz8D++iXWHvHX+CTD9wvyF1He4Ee59CqtuitB/tlbyx+0vqceX8D+tFQ3dNfYv/v+qjaHeIT4rXJ1LtP177fTL37iMfE/f8PkKwayifoRoKM/7/kuw9o+v3M5nQuc28tehxLdjwy5gFtzIOmMQ8Qj2MHhT2OHQCa8iDucSxZ6uPYJAGPY4dsfxxTdDvA8DhW1/LHMaX5EMPjGHC2uMQ8oeo9DKyrLtPj2GEPfwuh+n8/cNFWXe8ww28hDsfiIRf8CfHa5Cx+RM/iR81Z/AgRL48y/hYi0Cno30IcBv4W4ghwkB8FGrqu/1uIFKJclgFzTA+YX80Bc4yIvb8Ki73HgAb/FRd7U6TG3ikCYu9x22OvIuUxhtjb0PLYqzQfZ4i9R2N5zBOq3hPAuhoyxd4THsZe1f/IlKCud4Ih9p4QGHt/07P4SXMW/42IvScZY2+gU9Cx9wQw9v4GHOQngYZu6MfeVKJclgHzux4wp8wB8zsRe08Ji72/Aw1+Chd7U6XG3mkCYu9p22OvIuXvDLG3seWxV2k+zRB7T8bymCdUvX8A62rMFHv/8DD2qv5HpgR1vT8YYu8fAmPvn3oWP2PO4n8SsfcMY+wNdAo69v4BjL1/Agf5GaChG/uxN40ol2XAnNUD5i9zwJwlYu9fwmLvWaDB/8LF3jSpsXeGgNh7zvbYq0h5liH2NrU89irN5xhi75lYHvOEqvc8sK6mTLH3PNd2SrfmvZfZnxvqfb0AHOAKxHHOvz+o6ztM9/ZCrP01/m07iBWQzjMcijgPhIhyJ+paTS3/i4YKFn+DD0QEj26Udq829XPU7hCfEK9NPlZcoWvPF+dc+gih/oX5HK7+S6WZb6Rp1lAfLa4ADsx8cXn+eTfd8ciY+bUxC5jGVP/CfN4tECfreTc/0JQF4nCdK/V5d5aA592wOMtjlqJbYHAhr9vc8uddpVl1Dvp5FzhbXGKeUPWGA+tqzvS8Gx7n3a95VP/nA9zfwKq4ul54HD4hhcfhIRf8CfHa5CweoWfxSHMWjyDiZWQc3695Ap2C/jVPeBwuFUQAB3kk0NDN/V/zZBDlsgyYgnrARJkDpiARe6OExd6CQINH4WJvhtTYO0dA7I22PfYqUhZkiL1ZlsdepTmaIfZGxvGYJ1S9McC6sphib4yHsVf1PzIlqOvFMMTeGIGxN1bP4nHmLB5LxN44xtgb6BR07I0Bxt5Y4CCPAxo6y4+9mUS5LAMmXg+YK80BE0/E3iuFxd54oMGvxMXeTKmxd56A2FvI9tirSBnPEHufsjz2Ks2FGGJvXByPeULVWxhY11NMsbewh7FX9T8yJajrFWaIvYUFxt6r9CxexJzFryJibxHG2BvoFHTsLQyMvVcBB3kRoKGf8mNvFlEuy4ApqgdMMXPAFCVibzFhsbco0ODFcLE3S2rsfUdA7L3a9tirSFmUIfa2tjz2Ks1XM8TeInE85glV7zXAulozxd5ruLZTBm3qz8dwXVQfPcc8ZqqG9vnnD8bvjcW/YL040Ju230N1/4oz8LYEcKJR/auD2CUf5H3luLcl4uyv8VrbA4GaGBWI0YdLrgFOZtfF2RtUOCaYa4F61fWui+MZ1FImnJJ2TjgJHPdQ3b+SDBNOKSDIgkNgKcYQyOWn6y0NMF4d+OLiifkJ8drkklNpXXsZc8mpNLFGW4b5wNd1DAe+SgMnjzJxvOZ0LnNvLVoLzXY8MmZZbcwbTGOWJdZCbxC2FloWaMobcGuh2VLXQhcKWAu90fZHH0W3sgxR6QXL10KV5hsZ1kKBs8Ul5glVbzlgXS8wrYWW83ALgOr/MsDfmKrrlWPYAlAuDg+54E+I1yZn8fJ6Fr/JnMXLE/HyJsYtAIFOQW8BKAfcAlAeOMhvAhr6BX8LQEuiXJYBc7MeMBXMAXMzEXsrCIu9NwMNXgEXe1tKjb3vCYi9FW2PvYqUNzPE3k6Wx16luSJD7L0pjsc8oeqtBKyrE1PsreRh7FX9j0wJ6nqVGGJvJYGx9xY9i1c2Z/FbiNhbmTH2BjoFHXsrAWPvLcBBXhlo6E5+7M0hymUZMFX0gLnVHDBViNh7q7DYWwVo8FtxsTdHauxdJCD2VrU99ipSVmGIvV0tj71Kc1WG2Fs5jsc8oepNANbVlSn2JngYe1X/I1OCul4CQ+xNEBh7E/UsnmTO4olE7E1ijL2BTkHH3gRg7E0EDvIkoKG7+rE3lyiXZcAk6wGTYg6YZCL2pgiLvclAg6fgYm+u1Nj7oYDYm2p77FWkTGaIvT0tj71KcypD7E2K4zFPqHrTgHX1ZIq9acx7fa9n8HlvAQeMSjHo7nMNHr6Og5/A04G+B/Z1Qh8Bvkln8E0GcEJUwSXO+fcHeV857m1GnP013mZ7cFETeBrDwbQ04KR7e5y9gQq6jqSBcRtQr7re7XF8g1p90JPNHf/9yYbtUNodDJNNNSDEgoNqNQ9WHqrngeDi1YE0bo6Ark0uid2pa7/LXBK7k1hDvov5QNrtDAfS7gROGnfF8ZrTucy9tWetNsMzY9bQxqxpGrMGsVZbU9habQ2gKWvG4TpX6lrtxwLWau+2/ZFH0a0GQ0waYPlardJ8N8NaLXC2uMQ8oeqtBaxrANNabS0Ptyj8A2Pgb3TV9WoxbFGoFYeHXPAnxGuTs3htPYvXMWfx2kS8rMO4RSHQKegtCrWAWxRqAwd5HaChB+T5LQoZCUS5LAPmHj1g6poD5h4i9tYVFnvvARq8Li72JkiNvZ8KiL31bI+9ipT3MMTe1y2PvUpzPYbYWyeOxzyh6q0PrOt1pthb38PYq/ofmRLU9eozxN76AmPvvXoWb2DO4vcSsbcBY+wNdAo69tYHxt57gYO8AdDQr/uxN5Eol2XANNQDppE5YBoSsbeRsNjbEGjwRrjYmyg19i4WEHvvsz32KlI2ZIi9b1kee5Xm+xhib4M4HvOEqvd+YF1vMcXe+z2Mvar/kSlBXe9+hth7v8DY+4CexRubs/gDROxtzBh7A52Cjr33A2PvA8BB3hho6Lf82JtElMsyYB7UA+Yhc8A8SMTeh4TF3geBBn8IF3uTpMbezwXE3ia2x15FygcZYu8oy2Ov0tyEIfY2juMxT6h6HwbWNYop9j7MtZ1SH0irzuDzsQIOFlVj0D1OyIG0pkDfA/s6YZwA3zRl8M0jwAlRBZc4598f5H3luLePxNlfYzPbg4uawB9mOJD2MHDSfTTO3kAFXUfSwGgG1Kuu92gc36BWH/Rk89h/f7JhO5D2GMNk8zgQYsFB9XEPVh6a54Hg4tWBNG6OgK5NLom10LU/YS6JtSDWkJ9gPpD2KMOBtBbASeOJOF5zOpe5txat1SY7HhnzSW3MTNOYTxJrtZnC1mqfBJoyE7dWmyx1rXaZgLXaLNsfeRTdnmSISZMsX6tVmrMY1mqBs8Ul5glVbzawrklMa7XZHm5RUP3/BPA3uup62QxbFLLj8JAL/oR4bXIWb6ln8RxzFm9JxMscxi0KgU5Bb1HIBm5RaAkc5DlAQ0/ytyikEOWyDJhcPWCeMgdMLhF7nxIWe3OBBn8KF3tTpMbeLwTE3qdtj72KlLkMsXe65bFXaX6aIfbmxPGYJ1S9rYB1TWeKva08jL2q/5EpQV2vFUPsbSUw9j6jZ/FnzVn8GSL2PssYewOdgo69rYCx9xngIH8WaOjpfuxNJcplGTCt9YBpYw6Y1kTsbSMs9rYGGrwNLvamSo29KwTE3ra2x15FytYMsXeO5bFXaW7LEHufjeMxT6h6nwPWNYcp9j7nYexV/Y9MCep6zzHE3ucExt7n9SzezpzFnydibzvG2BvoFHTsfQ4Ye58HDvJ2QEPP8WNvGlEuy4BprwfMC+aAaU/E3heExd72QIO/gIu9aVJj71cCYu+LtsdeRcr2DLF3geWxV2l+kSH2tovjMU+oejsA61rAFHs7cG2n1AfSmjP4/D0BB4seZ9D9vpADaR2Bvgf2dcL7AnzTkcE3LwEnRBVc4px/f5D3lePevhRnf42dbA8uagLvwHAgrQNw0n05zt5ABV1H0sDoBNSrrvdyHN+gVh/0ZNP5vz/ZsB1I68ww2bwChFhwUH3Fg5WHLnkguHh1II2bI6Brk0tiXXXt3cwlsa7EGnI35gNpLzMcSOsKnDS6xfGa07nMvbVorTbd8ciYr2pjdjeN+SqxVttd2Frtq0BTdset1aZLXatdLWCttoftjzyKbq8yxKSPLF+rVZp7MKzVAmeLS8wTqt6ewLo+Ylqr7enhFgXV/92Av9FV1+vJsEWhZxwecsGfEK9NzuKv6Vm8lzmLv0bEy16MWxQCnYLeotATuEXhNeAg7wU09Ef+FoUMolyWAdNbD5g+5oDpTcTePsJib2+gwfvgYm+G1Nj7tYDY29f22KtI2Zsh9i62PPYqzX0ZYm+vOB7zhKq3H7CuxUyxt5+HsVf1PzIlqOv1Y4i9/QTG3v56Fh9gzuL9idg7gDH2BjoFHXv7AWNvf+AgHwA09GI/9mYS5bIMmIF6wAwyB8xAIvYOEhZ7BwINPggXezOlxt61AmLvYNtjryLlQIbYu9zy2Ks0D2aIvQPieMwTqt4hwLqWM8XeIR7GXtX/yJSgrjeEIfYOERh7X9ez+BvmLP46EXvfYIy9gU5Bx94hwNj7OnCQvwE09HI/9mYR5bIMmKF6wAwzB8xQIvYOExZ7hwINPgwXe7Okxt71AmLvm7bHXkXKoQyx9yvLY6/S/CZD7H0jjsc8oep9C1jXV0yx9y2u7ZT6QFoXBp+vEXCw6BUG3V8LOZA2HOh7YF8nfC3AN8MZfDMCOCGq4BLn/PuDvK8c93ZEnP01jrQ9uKgJ/C2GA2lvASfdt+PsDVTQdSQNjJFAvep6b8fxDWr1QU82o/77kw3bgbRRDJPNaCDEgoPqaA9WHsbkgeDi1YE0bo6Ark0uiY3VtY8zl8TGEmvI45gPpL3NcCBtLHDSGBfHa07nMvfWorXabMcjY47XxpxgGnM8sVY7Qdha7XigKSfg1mqzpa7VbhCwVjvR9kceRbfxDDFpveVrtUrzRIa1WuBscYl5Qv6LdcC61jOt1U7ycIuC6v9xwN/oqutNYtiiMCkOD7ngT4jXJmfxyXoWn2LO4pOJeDmFcYtCoFPQWxQmAbcoTAYO8ilAQ6/3tyi0JMplGTBT9YCZZg6YqUTsnSYs9k4FGnwaLva2lBp7vxMQe6fbHnsVKacyxN5NlsdepXk6Q+ydEsdjnlD1zgDWtYkp9s7wMPaq/kemBHW9GQyxd4bA2DtTz+KzzFl8JhF7ZzHG3kCnoGPvDGDsnQkc5LOAht7kx94colyWATNbD5g55oCZTcTeOcJi72ygwefgYm+O1Ni7WUDsnWt77FWknM0Qe7daHnuV5rkMsXdWHI95QtU7D1jXVqbYO8/D2Kv6H5kS1PXmMcTeeQJj73w9i79jzuLzidj7DmPsDXQKOvbOA8be+cBB/g7Q0Fv92JtLlMsyYBboAbPQHDALiNi7UFjsXQA0+EJc7M2VGnu3CIi979oeexUpFzDE3p2Wx16l+V2G2PtOHI95Qv5LXsC6djLF3ve4tlPqA2ljGHy+W8DBotEMuvcIOZD2PtD3wL5O2CPAN+8z+GYRcEJUwSXO+fcHeV857u2iOPtr/MD24KIm8PcYDqS9B5x0P4yzN1BB15E0MD4A6lXX+zCOb1CrD3qy+ei/P9mwHUj7iGGy+RgIseCg+rEHKw+f5IHg4tWBNG6OgK5NLol9qmv/zFwS+5RYQ/6M+UDahwwH0j4FThqfxfGa07nMvbVnrTbTM2Mu1sZcYhpzMbFWu0TYWu1ioCmXxOE6V+pa7VYBa7Wf2/7Io+i2mCEm7bN8rVZp/pxhrRY4W1xinlD1LgXWtY9prXaph1sUVP9/BvyNrrreUoYtCkvj8JAL/oR4bXIWX6Zn8eXmLL6MiJfLGbcoBDoFvUVhKXCLwjLgIF8ONPS+PL9FITOBKJdlwHyhB8yX5oD5goi9XwqLvV8ADf4lLvYmSI29PwqIvStsj72KlF8wxN7DlsdepXkFQ+xdHsdjnlD1rgTWdZgp9q70MPaq/kemBHW9lQyxd6XA2PuVnsVXmbP4V0TsXcUYewOdgo69K4Gx9yvgIF8FNPRhP/YmEuWyDJjVesCsMQfMaiL2rhEWe1cDDb4GF3sTpcbeHQJi79e2x15FytUMsfe45bFXaf6aIfauiuMxT6h6vwHWdZwp9n7jYexV/Y9MCep63zDE3m8Ext61ehZfZ87ia4nYu44x9gY6BR17vwHG3rXAQb4OaOjjfuxNIsplGTDr9YD51hww64nY+62w2LseaPBvcbE3SWrs3SUg9m6wPfYqUq5niL2nLI+9SvMGhti7Lo7HPKHq3Qis6xRT7N3ItZ1SH0j7hMHnfwo4WPQxg+4zQg6kfQf0PbCvE84I8M13DL7ZBJwQVXCJc/79Qd5Xjnu7Kc7+GjfbHlzUBL6R4UDaRuCk+32cvYEKuo6kgbEZqFdd7/s4vkGtPujJZst/f7JhO5C2hWGy+QEIseCg+oMHKw9b80Bw8epAGjdHQNcml8S26dp/NJfEthFryD8yH0j7nuFA2jbgpPFjHK85ncvcW4vWapMdj4y5XRtzh2nM7cRa7Q5ha7XbgabcgVurTZa6VrtbwFrtTtsfeRTdtjPEpPOWr9UqzTsZ1mqBs8Ul5glV7y5gXeeZ1mp3ebhFQfX/j8Df6Krr7WLYorArDg+54E+I1yZn8Z/0LL7bnMV/IuLlbsYtCoFOQW9R2AXcovATcJDvBhr6vL9FIYUol2XA7NED5mdzwOwhYu/PwmLvHqDBf8bF3hSpsfdnAbH3F9tjryLlHobYm6+43bFXaf6FIfbujuMxT8gr/sC6kH0bDPS9HsZe1f/IlKCut5ch9u4VGHv36Vl8vzmL7yNi737G2BvoFHTs3QuMvfuAg3w/0NDIQS409qYS5bIMmAN6wBw0B8wBIvYeFBZ7DwANfhAXe1Olxt69AmLvIdtjryLlAYbYG2F57FWaDzHE3v1xPOYJ+b0YwLoimGLvYQ9jr+p/ZEpQ1zvMEHsPC4y9R/QsftScxY8QsfcoY+wNdAo69h4Gxt4jwEF+FGjoCD/2phHlsgyYY3rA/GoOmGNE7P1VWOw9BjT4r7jYmyY19u4XEHuP2x57FSmPMcTeGMtjr9J8nCH2Ho3jMU+oek8A64phir0nuLZT6gNpWxl8Hs/s86qhff7Z6/0Dg+4ri+Ph6zj4Cfw3oO+BfZ1wpQDf/Mbgm5PACVEFlzjn3x/kfeW4tyfj7K/xd9uDi5rATzAcSDsBnHRPxdkbqKDrSBoYvyN/Pe1e71Qc36BWH/Rkc/q/P9mwHUg7zTDZ/AGEWHBQ/cODlYc/80Bw8epAGjdHQNcml8TO6NrPmktiZ4g15LPMB9JOMRxIOwOcNM7G8ZrTucy9tWitNt3xyJh/aWOeM435F7FWe07YWu1fQFOew63Vpktdqz0oYK32vO2PPIpufzHEpCKWr9UqzecZ1mqBs8Ul5glV7wVgXUWY1moveLhFQfX/WeBvdNX1LjBsUbgQh4dc8CfEa5Oz+N+BaBzvXDpj/03ES/VfKq3/++gtCoFOQW9RuADcovA3cJCre4m6d0X8LQoZRLksA+aK+Iv/zGcOGPUvzNibL15W7L0iHldXvnhc50qNvYcFxN788eAa0ZRQpAwMLuR1i1see5Vm1Tno2OvE85gnVL0FgHUVZ4q9BeK9i73/zDTAlKCuVyAeH3sLxOMhF/wJ8drkLB6mZ/FwcxZX/8KMveGMsTfQKejYWyAelwrCgIM8HGjo4n7szSTKZRkwEXrARJoDJoKIvZHCYm8E0OCRuNibKTX2HhUQewvaHnsVKSMYYm8py2Ov0lyQIfaGx/OYJ1S9UcC6SjHF3igPY6/qf2RKUNeLYoi9UQJjb7SexWPMWTyaiL0xjLE30Cno2BsFjL3RwEEeAzR0KT/2ZhHlsgyYWD1g4swBE0vE3jhhsTcWaPA4XOzNkhp7fxUQe+Ntj72KlLEMsfcGy2Ov0hzPEHtj4nnME/IBImBdNzDF3ivjeQ+k/cmwmae8gINFfzDovknIgbRCQN8D+zrhJgG+KcQwLxQGTogquEg8kFY43v4ar7I9uKgJXE0Y6ANpVwIn3SLx9gYq6DqSBsZVQL3qekXiHbZBrT7oyabof3+yYTuQVpRhsikGhFhwUC3mwcrD1XkguHh1II2bI6Brk0ti1+jai5tLYtcQa8jFuZ6ggm5kPozR/7csdg1w0igez2tO5zL31qK12mzHI2OW0Ma81jRmCWKt9lpha7UlgKa8FrdWmy11rfaEgLXa62x/5FF0K8EQkypZvlarNF/HsFYLnC0uMU+oeksC66rEtFZb0sMtCqr/iwN/o6uuV5Jhi0LJeDzkgj8hXpucxUvpWfx6cxYvRcTL6xm3KAQ6Bb1FoSRwi0Ip4CC/HmjoSv4WhZZEuSwDprQeMGXMAVOaiL1lhMXe0kCDl8HF3pZSY+9JAbG3rO2x959ZhyH2VrU89irNZRli7/XxPOYJ+TccwLqqMsXeGzyMvar/kSlBXe8Ghth7g8DYe6OexcuZs/iNROwtxxh7A52Cjr03AGPvjcBBXg5o6Kp+7M0hymUZMOX1gLnJHDDlidh7k7DYWx5o8JtwsTdHauw9JSD23mx77FWkLM8Qe1Msj71K880MsbdcPI95QtVbAVhXClPsreBh7FX9j0wJ6noVGGJvBYGxt6KexSuZs3hFIvZWYoy9gU5Bx94KwNhbETjIKwENneLH3lyiXJYBc4seMJXNAXMLEXsrC4u9twANXhkXe3Olxt4/BMTeKrbHXkXKWxhi722Wx16luQpD7K0Uz2OeUPXeCqzrNqbYeyvXdkp9IO1qBp9XE3CwqBiD7upCDqRVBfoe2NcJ1QX4piqDbxKAE6IKLhIPpCXE219jou3BRU3gtzIcSLsVOOkmxdsbqKDrSBoYiUC96npJ8Q7boFYf9GST/N+fbNgOpCVzrL0DIRYcVFM8WHlIzQPBxasDadwcAV2bXBJL07Wnm0tiacQacjrzgbQkhgNpacBJIz2e15zOZe6tPWu1WZ4ZM0Mb8zbTmBnEWu1twtZqM5DJLR7XuVLXas8IWKu93fZHHkW3DIaYVNPytVql+XaGtVrgbHGJeULVewewrppMa7V3eLhFQfV/OvA3uup6dzBsUbgjHg+54E+I1yZn8Wp6Fq9uzuLViHhZnXGLQqBT0FsU7gBuUagGHOTVgYaumee3KGQlEOWyDJg79YC5yxwwdxKx9y5hsfdOoMHvwsXeBKmx9y8BsbeG7bFXkfJOhth7j+WxV2muwRB7q8fzmCfkxxBgXfcwxd6aHsZe1f/IlKCuV5Mh9tYUGHvv1rN4LXMWv5uIvbUYY2+gU9CxtyYw9t4NHOS1gIa+x4+9iUS5LAOmth4wdcwBU5uIvXWExd7aQIPXwcXeRKmx97yA2HuP7bFXkbI2Q+xtYHnsVZrvYYi9teJ5zBOq3rrAuhowxd66HsZe1f/IlKCuV5ch9tYVGHvr6Vm8vjmL1yNib33G2BvoFHTsrQuMvfWAg7w+0NAN/NibRJTLMmDu1QOmgTlg7iVibwNhsfdeoMEb4GJvktTY+7eA2NvQ9tirSHkvQ+x9wPLYqzQ3ZIi99eN5zBOq3kbAuh5gir2NuLZT6gNpqQw+f0jAwaIUBt1NhBxIuw/oe2BfJzQR4Jv7GHxzP3BCVMFF4oG0++Ptr/EB24OLmsAbMRxIawScdBvH2xuooOtIGhgPAPWq6zWOd9gGtfqgJ5sH//uTDduBtAc5whkQYsFB9SEPVh6a5IHg4tWBNG6OgK5NLok9rGtvai6JPUysITdlPpDWmOFA2sPASaNpPK85ncvcW4vWapMdj4z5iDZmM9OYjxBrtc2ErdU+AjRlM9xabbLUtdorCthf46O2P/Iouj3CEJOaWb5WqzQ/yrBWC5wtLjFPqHofA9bVjGmt9jEPtyio/m8K/I2uut5jDFsUHovHQy74E+K1yVn8cT2LNzdn8ceJeNmccYtCoFPQWxQeA25ReBw4yJsDDd3M36KQQpTLMmBa6AHzhDlgWhCx9wlhsbcF0OBP4GJvitTYm19A7H3S9tirSNmCIfa2sDz2Ks1PMsTe5vE85glVbyawrhZMsTfTw9ir+h+ZEtT1Mhlib6bA2JulZ/FscxbPImJvNmPsDXQKOvZmAmNvFnCQZyMN7cfeVKJclgHTUg+YHHPAtCRib46w2NsSaPAcXOxNlRp7wwTE3lzbY68iZUuG2JtteexVmnMZYm92PI95QtX7FLCubKbY+5SHsVf1PzIlqOs9xRB7nxIYe5/Ws3grcxZ/moi9rRhjb6BT0LH3KWDsfRo4yFsBDZ3tx940olyWAfOMHjDPmgPmGSL2Piss9j4DNPizuNibJjX2RgiIva1tj72KlM8wxN6nLY+9SnNrhtjbKp7HPKHqbQOs62mm2NuGazulPpDWhMHnzwo4WPQQg+7WQg6ktQX6HtjXCa0F+KYtg2+eA06IKrhIPJD2XLz9NT5ve3BRE3gbhgNpbYCTbrt4ewMVdB1JA+N5oF51vXbxDtugVh/0ZNP+vz/ZsB1Ia88w2bwAhFhwUH3Bg5WHF/NAcPHqQBo3R0DXJpfEOujaO5pLYh2INeSOzAfS2jEcSOsAnDQ6xvOa07nMvbVorTbd8ciYL2ljdjKN+RKxVttJ2FrtS0BTdsKt1aZLXastKGCt9mXbH3kU3V5iiEnPW75WqzS/zLBWC5wtLjFPqHo7A+t6nmmttrOHWxRU/3cE/kZXXa8zwxaFzvF4yAV/Qrw2OYu/omfxLuYs/goRL7swblEIdAp6i0Jn4BaFV4CDvAvQ0M/7WxQyiHJZBkxXPWC6mQOmKxF7uwmLvV2BBu+Gi70ZUmNvtIDY+6rtsVeRsitD7O1geexVml9liL1d4nnME6re7sC6OjDF3u4exl7V/8iUoK7XnSH2dhcYe3voWbynOYv3IGJvT8bYG+gUdOztDoy9PYCDvCfQ0B382JtJlMsyYF7TA6aXOWBeI2JvL2Gx9zWgwXvhYm+m1NgbKyD29rY99ipSvsYQeztbHnuV5t4MsbdnPI95QtXbB1hXZ6bY28fD2Kv6H5kS1PX6MMTePgJjb189i/czZ/G+ROztxxh7A52Cjr19gLG3L3CQ9wMaurMfe7OIclkGTH89YAaYA6Y/EXsHCIu9/YEGH4CLvVlSY2+8gNg70PbYq0jZnyH2vmp57FWaBzLE3n7xPOYJVe8g5Co0U+wdxLWdUh9Ie5HB5z0FHCx6gUH3a0IOpA0G+h7Y1wmvCfDNYAbfDAFOiCq4SDyQNiTe/hpftz24qAl8EMOBtEHASfeNeHsDFXQdSQPjdaBedb034h22Qa0+6Mlm6H9/smE7kDaUYbIZBoRYcFAd5sHKw5t5ILh4dSCNmyOga5NLYm/p2oebS2JvEWvIw5kPpL3BcCDtLeCkMTye15zOZe6tRWu12Y5HxhyhjTnSNOYIYq12pLC12hFAU47ErdVmS12rLSRgrfZt2x95FN1GMMSkvpav1SrNbzOs1QJni0vME6reUcC6+jKt1Y7ycIuC6v/hwN/oquuNYtiiMCoeD7ngT4jXJmfx0XoWH2PO4qOJeDmGcYtCoFPQWxRGAbcojAYO8jFAQ/f1tyi0JMplGTBj9YAZZw6YsUTsHScs9o4FGnwcLva2lBp7rxIQe8fbHnsVKccyxN5BlsdepXk8Q+wdE89jnlD1TgDWNYgp9k7wMPaq/kemBHW9CQyxd4LA2DtRz+KTzFl8IhF7JzHG3kCnoGPvBGDsnQgc5JOAhh7kx94colyWATNZD5gp5oCZTMTeKcJi72SgwafgYm+O1NhbVEDsnWp77FWknMwQe4daHnuV5qkMsXdSPI95QtU7DVjXUKbYO83D2Kv6H5kS1PWmMcTeaQJj73Q9i88wZ/HpROydwRh7A52Cjr3TgLF3OnCQzwAaeqgfe3OJclkGzEw9YGaZA2YmEXtnCYu9M4EGn4WLvblSY+/VAmLvbNtjryLlTIbYO8Ly2Ks0z2aIvTPiecwTqt45wLpGMMXeOVzbKfWBtDcZfD5KwMGiYQy6Rws5kDYX6HtgXyeMFuCbuQy+mQecEFVwkXggbV68/TXOtz24qAl8DsOBtDnASfedeHsDFXQdSQNjPlCvut478Q7boFYf9GSz4L8/2bAdSFvAMNksBEIsOKgu1EFV/XyV/ufnsf/XtjTo52VBPy8P+vmLoJ+/DPp5RdDPK4N+/iro51VBP68O+vn/195VgElxNO29Ow455Hb3cAiaEE92z48IJFjcSAgOp1iIuxJ3dxdiX9ydECEJJCGuxN3dlb/7mLmrabo75N+3NtPH9PPUw7D9Xm11d1X1O70900+S66fI9dPkejG5foZc302u7yHX95Lr+8j1/eT6AXI9j1w/6F3fJvrrdiF3CLlTyF1C7hZyj5B7vZsw2betY+YyFDOOaWnX+qzfUV7Go7eikklvqVv9UF7PpNe1fmCytzjFZG+VW/1QUu1W/1bUMPVvHZO9JUz2VjDZy9QPxbVMeiM/W6aXaz4ucUtveZpJL1O8cY1bWYNj48Y0b1YwzW9s8Rbl38YSzfOevUx5x7X8wHb/xjRfVBS71Q8VHA87+qVEt/sCvb4G2ArUVPj6orZZd6tY86KQLFEn+aU2lUPaH/eu7xOLaPcLeUDIPCEPCpkv5CEhDwt5RMijQhYIeUzI40KeELJQyCJ1r9V9ZHXT/+x+zWcPaD6bp/nsQc1n8zWfPaT57GHNZ49oPntU89kCzWePaT57XPPZE5rPFmo+W+R9lucNBmxAYvrdv35Br5TjNgvWZm137ZNePz2lOvCTms2CTzm2WfBJ4E9pTxXiBtfVzYI9HNgs+DTyN/cVedlfplujpZM+zbDXH9oReGfVZqPFXjZ6Rs1GizV7/Z9h3OvvDwp0Y4QyKJlmt8XA7PYM0FkcnXLTsSw5+bOekz+nOvmzmin3Ocem3GeBTvkcbspNuzrl9nJgyn0+7NvcZHZ7lmFrzCUh358v2/x8IX5/PnC2CDhPpu19AWjXJUz781/wEno2HkuV4/8M8Ck+qe8FBqr6goNU9UVvFn9JncVf1FDVlxipqj8o6MdSXwBS1ReBQf4S0KEvWekfS60t1pjLEjAvewHzihowL2to7yuO0d6XgQ7+Co72FrtKe1dxgPa+GnbaKzPlywy0d27Iaa9s86sMtPelQh7nybS9rwHtmstEe1/LIu2V449kCVLfawy09zUHae/r3iy+RJ3FX9fQ3iWMtNcfFDTtfQ1Ie18HBvkSoEPPjWhvicZcloB5wwuYN9WAeUNDe990jPa+AXTwN3G0t8RV2tvXAdr7Vthpr8yUbzDQ3mtDTntlm99ioL1LCnmcJ9P2vg2061om2vs2AwOi4/02+jdq0RdvA8foncLwxp9fcsHjgtx19C7QxznaKrfoPQn2l3cL8ZPWfcz7G9C3hrJP3yls1o+yPaYpGerWst73PNvfV1nve5rbxPctSTKVSSEdCXL8Jub7HtDp32d2zpihb0N0O1Yay5JjfuA55oeqY36guR370LHbsQ+ATvkh7nas1NXbsf4O3I59FPbbMZndPmC4Hbsp5Ldjss0fMdyOAWeLgPNk2t6PgXbdxHQ79nEWf4WQ4/8+cNFW6vuY4VeIjwvxSY6WDHVrZ/FPvFn8U3UW/0RDLz9l/BXCHxT0rxAfA3+F+AQY5J8CHfqm6FeIMo25LAHzmRcwn6sB85mG9n7uGO39DOjgn+Nob5mrtHegA7T3i7DTXpkpP2OgvbeHnPbKNn/BQHs/LeRxnkzb+yXQrtuZaO+XWaS9cvyRLEHq+5KB9n7pIO39ypvFv1Zn8a80tPdrRtrrDwqa9n4JpL1fAYP8a6BD3x7R3nKNuSwB840XMN+qAfONhvZ+6xjt/Qbo4N/iaG+5q7R3NQdo73dhp70yU37DQHvvCTntlW3+joH2fl3I4zyZtvd7oF33MNHe77NIe+X4I1mC1Pc9A+393kHa+4M3i/+ozuI/aGjvj4y01x8UNO39Hkh7fwAG+Y9Ah74nor0VGnNZAuYnL2B+VgPmJw3t/dkx2vsT0MF/xtHeCldp7+oO0N5fwk57Zab8iYH2zgs57ZVt/oWB9v5YyOM8mbb3V6Bd85ho769c2ymFze8a9udm2q+/AQNcJmL/FaK0oPTHmPr2t8Lw2/h72BOxTEi/MjwU8SswifxRGN4JAnpf7CWM34Htlfr+KIzBgzpbm/o5bI9pSoa6tbcVf3q2/6XeVvypuQ//i3lT/x8Mm/r/BDrqX9Gm/spYlhzzb88xl6qO+bfmfnepY/e7fwOdcinufrfS1fvdNR2435X8FWojOkvI7PY3w33AoyG/323MNHH8/S5wtgg4T6btzcE5YvpRpvtdaWO/WHZ+5pHj/xdwVbwxhuJ4hpQTxyc5WjLUrZ3Fc72b9rx4LDhjywqVXubF+X7m8QcF/TNPThzHCnKBQZ4Xx/Xdo9HPPFUac1kCppUXMPlqwLSKL0978+Nu0d5WQAfPj+MG11Xau7YDtLd12GmvzJSt4ni9C0NOe2WbWzPQ3rw4j/Nk2t42QLsWMtHeNlmkvXL8kSxB6mvDQHvbOEh723qzeDt1Fm+rob3tGGmvPyho2tsGSHvbAoO8HdChF0a0t1pjLkvAFHgB014NmAIN7W3vGO0tADp4exztrXaV9q7rAO3tEHbaKzNlAQPtXRxy2ivb3IGB9raL8zhPpu3tCLRrMRPt7ZhF2ivHH8kSpL6ODLS3Yxyf5GjJULd2Fu/kzeKF6izeSUN7Cxlprz8oaNrbEUh7OwGDvBDo0Isj2lujMZclYOJewCTUgIlraG/CMdobBzp4Akd7a1ylves7QHuTYae9MlPGGWjvCyGnvbLNSQbaWxjncZ5M21sEtOsFJtpbFOff1J/LoBc1Ri8zx0wqs9J4YPy7hfgXrHcG+mbY+1D2X2eGfNsFONHI8fWIWKAg+5Wjb7vEw29j17ATAjkxykSMfrikCDiZdYuHl6hwTDBdge2V+rrFeYLalQmnezgnnDRHH8r+684w4fQAJjJKAnswkkAuf+oZUgKTrQe+uPKJWjLUrV1y6uXZ3ltdcuqlWaPtzeWcpCNBztm07NQLOHn0jvM6Z8zQtyFaC62NZckxV/Ecs4/qmKto1kL7OLYWugrQKfvg1kJrXV0LTTuwFto37Lc+MrutwkCVXg/5Wqhsc1+GtVDgbBFwnkzb2w9o1+tMa6H9srgFQI5/b+AvplJfP4YtAP3i+CRHS4a6tbN4f28WH6DO4v019HIA4xYAf1DQWwD6AbcA9AcG+QCgQ78ebQGo05jLEjADvYBZVQ2YgRrau6pjtHcg0MFXxdHeOldpb4kDtHe1sNNemSkHMtDet0NOe2WbV2OgvQPiPM6TaXsHAe16m4n2Dsoi7ZXjj2QJUt8gBto7KI5PcrRkqFs7i6/uzeJrqLP46hrauwYj7fUHBU17BwFp7+rAIF8D6NBvR7S3XmMuS8Cs6QXMWmrArKmhvWs5RnvXBDr4WjjaW+8q7S1zgPauHXbaKzPlmgy094OQ017Z5rUZaO8acR7nybS96wDt+oCJ9q6TRdorxx/JEqS+dRho7zpxfJKjJUPd2ll8XW8WX0+dxdfV0N71GGmvPyho2rsOkPauCwzy9YAO/UFEexs05rIEzPpewKTUgFlfQ3tTjtHe9YEOnsLR3gZXaW+FA7Q3HXbaKzPl+gy099OQ017Z5jQD7V0vzuM8mba3GGjXp0y0t5hrO6W317cng59/4cADRj0Y2v1lD3zyjcXwE3gJ0O+BY53+0gG/KWHwm1LghCiJSzy2fEH2K0fflsbDb2NZ2ImLnMDlhIF+MK0YOOmWx8NLqKDrSF7CKAO2V+orj/MFtSzoyaai5U82bA+lVTBMNpXAJEaJamUWVh6qVgLikq0H0rjzCEi3dklssGf7BuqS2GDNGvIGXHdQpCNzMY7etCw2GDhpbBDndc6YoW/Ds1ZblzXH3NBzzI1Ux9xQs1a7kWNrtRsCnXKjOG5wXV2rrXJgrXbjsN/yyOy2IQNN+jbka7WyzRszrNUCZ4uA82Ta3iFAu75lWqsdksUtCnL8NwD+oiv1DWHYojAkjk9ytGSoWzuLD/Vm8U3UWXyohl5uwrhFwR8U9BaFIcAtCkOBQb4J0KG/Xem3KNSlNeayBMymXsAMUwNmUw3tHeYY7d0U6ODDcLQ37Srt3cAB2js87LRXZspNGWjvTyGnvbLNwxlo7yZxHufJtL0jgHb9xER7R2SR9srxR7IEqW8EA+0dEccnOVoy1K2dxUd6s/godRYfqaG9oxhprz8oaNo7Akh7RwKDfBTQoX+KaG+xxlyWgNnMC5jN1YDZTEN7N3eM9m4GdPDNcbS32FXau5EDtHeLsNNemSk3Y6C9v4ec9so2b8FAe0fFeZwn0/ZuCbTrdybau2UWaa8cfyRLkPq2ZKC9W8bxSY6WDHVrZ/GtvFl8a3UW30pDe7dmpL3+oKBp75ZA2rsVMMi3Bjr07xHtLdGYyxIw23gBs60aMNtoaO+2jtHebYAOvi2O9pa4SnuHOEB7tws77ZWZchsG2rs05LRXtnk7Btq7dZzHeTJt7/ZAu5Yy0d7tubZTeg+kVTH4eW5PXj9PZVYa93pXMrQ7ryc++cZi+Al8B6DfA8c6neeA3+zA4DejgROiJC7x2PIF2a8cfTs6Hn4bdww7cZETuJww0A+kbQ+cdHeKh5dQQdeRvISxI7C9Ut9Ocb6glgU92Yxp+ZMN2wNpYxgmm52BSYwS1Z2zsPIwdiUgLtl6II07j4B0a5fExnm2j1eXxMZp1pDHc91BkY7MxTh607LYOOCkMT7O65wxQ9+GaK22NJYlx5zgOeZE1TEnaNZqJzq2VjsB6JQTcWu1pa6u1W7iwFrtpLDf8sjsNoGBJrVhXovI1D7Z5kkMa7XA2SLgPJm2dzLQLuTY0oQ+OYtbFOT4jwf+oiv1TWbYojA5jk9ytGSoWzuLT/Fm8anqLD5FQy+nMm5R8AcFvUVhMnCLwhRgkE8FOnQb5nuyGHjMGWhvmcZcloCp9gKmRg2Yag3trXGM9lYDHbwGR3vLXKW9wxygvbVhp70yU1Yz0N4OIae9ss21DLR3apzHeTJtbx3Qrg5MtLcui7RXjj+SJUh9dQy0ty6OT3K0ZKhbO4vXe7N4gzqL12tobwMj7fUHBU1764C0tx4Y5A1Ah+4Q0d5yjbksATPNC5jpasBM09De6Y7R3mlAB5+Oo73lrtLeEQ7Q3hlhp70yU05joL2JkNNe2eYZDLS3Ic7jPJm2dybQrgQT7Z2ZRdorxx/JEqS+mQy0d2Ycn+RoyVC3dhaf5c3iu6iz+CwN7d2Fkfb6g4KmvTOBtHcWMMh3ATp0IqK9FRpzWQJmthcwu6oBM1tDe3d1jPbOBjr4rjjaW+Eq7R3lAO3dLey0V2bK2Qy0t2vIaa9s824MtHeXOI/zZNre3YF2dWWivbtzbaf0Hkgby+DnPRx4sGhnhnb3dOSBtD2Afg8c63RPB/xmDwa/2RM4IUriEo8tX5D9ytG3e8bDb+NeYScucgKXEwb6gbTdgZPu3vHwEiroOpKXMPYCtlfq2zvOF9SyoCebfVr+ZMP2QNo+DJPNvsAkRonqvllYedhvJSAu2XogjTuPgHRrl8T292w/QF0S21+zhnwA1x0U6chcjKM3LYvtD5w0DojzOmfM0LchWqutjGXJMQ/0HPMg1TEP1KzVHuTYWu2BQKc8CLdWW+nqWu3mDqzVHhz2Wx6Z3Q5koEl9Qr5WK9t8MMNaLXC2CDhPpu09BGhXH6a12kOyuEVBjv8BwF90pb5DGLYoHBLHJzlaMtStncUP9Wbxw9RZ/FANvTyMcYuCPyjoLQqHALcoHAoM8sOADt0n2qJQpTGXJWDmeAFzuBowczS093DHaO8coIMfjqO9Va7S3i0doL1HhJ32ykw5h4H2Dgw57ZVtPoKB9h4W53GeTNt7JNCugUy098gs0l45/kiWIPUdyUB7j4zjkxwtGerWzuJHebP40eosfpSG9h7NSHv9QUHT3iOBtPcoYJAfDXTogRHtrdaYyxIwx3gBc6waMMdoaO+xjtHeY4AOfiyO9la7Snu3doD2Hhd22isz5TEMtHeNkNNe2ebjGGjv0XEe58m0vccD7VqDifYen0XaK8cfyRKkvuMZaO/xcXySoyVD3dpZ/ARvFj9RncVP0NDeExlprz8oaNp7PJD2ngAM8hOBDr1GRHtrNOayBMxJXsCcrAbMSRrae7JjtPckoIOfjKO9Na7S3m0doL2nhJ32ykx5EgPtXTfktFe2+RQG2ntinMd5Mm3vqUC71mWivadybaf0Hkjbj8HPUw48WLQvQ7vTjjyQdhrQ74FjnU474DenMfjN6cAJURKXeGz5guxXjr49PR5+G88IO3GRE7icMNAPpJ0KnHTPjIeXUEHXkbyEcQawvVLfmXG+oJYFPdmc1fInG7YH0s5imGzOBiYxSlTPzsLKwzkrAXHJ1gNp3HkEpFu7JHauZ/t56pLYuZo15PO47qBIR+ZiHL1pWexc4KRxXpzXOWOGvg3RWm1tLEuOeb7nmBeojnm+Zq32AsfWas8HOuUFuLXaWlfXard3YK32wrDf8sjsdj4DTSoL+VqtbPOFDGu1wNki4DyZtvcioF1lTGu1F2Vxi4Ic//OAv+hKfRcxbFG4KI5PcrRkqFs7i1/szeKXqLP4xRp6eQnjFgV/UNBbFC4CblG4GBjklwAduizaolCnMZclYC71AuYyNWAu1dDeyxyjvZcCHfwyHO2tc5X2jnaA9l4edtorM+WlDLR3cMhpr2zz5Qy095I4j/Nk2t4rgHYNZqK9V2SR9srxR7IEqe8KBtp7RRyf5GjJULd2Fp/rzeJXqrP4XA3tvZKR9vqDgqa9VwBp71xgkF8JdOjBEe2t15jLEjBXeQFztRowV2lo79WO0d6rgA5+NY721rtKe3dygPZeE3baKzPlVQy0d0jIaa9s8zUMtPfKOI/zZNrea4F2DWGivddmkfbK8UeyBKnvWgbae20cn+RoyVC3dhb/nzeLX6fO4v/T0N7rGGmvPyho2nstkPb+Dxjk1wEdekhEexs05rIEzPVewNygBsz1Gtp7g2O093qgg9+Ao70NrtLenR2gvTeGnfbKTHk9A+0dHnLaK9t8IwPtvS7O4zyZtvcmoF3DmWjvTVzbKb0H0s5h8PNRDjxYdDZDuzdz5IG0m4F+Dxzr9GYO+M3NDH5zC3BClMQlHlu+IPuVo29viYffxlvDTlzkBC4nDPQDaTcBJ93b4uElVNB1JC9h3Apsr9R3W5wvqGVBTza3t/zJhu2BtNsZJps7gEmMEtU7srDycOdKQFyy9UAadx4B6dYuid3l2X63uiR2l2YN+W6uOyjSkbkYR29aFrsLOGncHed1zpihb8OzVlufNce8x3PMe1XHvEezVnuvY2u19wCd8t44bnBdXasd58Ba7X1hv+WR2e0eBpq0VcjXamWb72NYqwXOFgHnybS99wPt2opprfb+LG5RkON/N/AXXanvfoYtCvfH8UmOlgx1a2fxB7xZfJ46iz+goZfzGLco+IOC3qJwP3CLwgPAIJ8HdOitVvotCvVpjbksAfOgFzDz1YB5UEN75ztGex8EOvh8HO1Nu0p7JzhAex8KO+2VmfJBBtq7fchpr2zzQwy0d16cx3kybe/DQLu2Z6K9D2eR9srxR7IEqe9hBtr7cByf5GjJULd2Fn/Em8UfVWfxRzS091FG2usPCpr2PgykvY8Ag/xRoENvH9HeYo25LAGzwAuYx9SAWaChvY85RnsXAB38MRztLXaV9k5ygPY+HnbaKzPlAgbaOybktFe2+XEG2vtonMd5Mm3vE0C7xjDR3ieySHvl+CNZgtT3BAPtfSKOT3K0ZKhbO4sv9GbxReosvlBDexcx0l5/UNC09wkg7V0IDPJFQIceE9HeEo25LAHzpBcwT6kB86SG9j7lGO19EujgT+Fob4mrtHeKA7T36bDTXpkpn2SgvRNCTntlm59moL2L4jzOk2l7FwPtmsBEexdzbaf0Hki7k8HPJzvwYNEdDO2e4sgDac8A/R441ukpDvjNMwx+8yxwQpTEJR5bviD7laNvn42H38bnwk5c5AQuJwz0A2mLgZPu8/HwEiroOpKXMJ4Dtlfqez7OF9SyoCebF1r+ZMP2QNoLDJPNi8AkRonqi1lYeXhpJSAu2XogjTuPgHRrl8Re9mx/RV0Se1mzhvwK1x0U6chcjKM3LYu9DJw0XonzOmfM0LchWqstjWXJMV/1HPM11TFf1azVvubYWu2rQKd8DbdWW+rqWm21A2u1r4f9lkdmt1cZaFJtyNdqZZtfZ1irBc4WAefJtL1LgHbVMq3VLsniFgU5/q8Af9GV+pYwbFFYEscnOVoy1K2dxd/wZvE31Vn8DQ29fJNxi4I/KOgtCkuAWxTeAAb5m0CHro22KJRpzGUJmLe8gHlbDZi3NLT3bcdo71tAB38bR3vLXKW9tQ7Q3nfCTntlpnyLgfZODzntlW1+h4H2vhnncZ6MV/yBdk1nor3vZpH2yvFHsgSp710G2vtuHJ/kaMlQt3YWf8+bxd9XZ/H3NLT3fUba6w8Kmva+C6S97wGD/H2gQ0+PaG+5xlyWgPnAC5gP1YD5QEN7P3SM9n4AdPAPcbS33FXaW+8A7f0o7LRXZsoPGGjv7JDTXtnmjxho7/txHufJtL0fA+2azUR7P84i7ZXjj2QJUt/HDLT34zg+ydGSoW7tLP6JN4t/qs7in2ho76eMtNcfFDTt/RhIez8BBvmnQIeeHdHeCo25LAHzmRcwn6sB85mG9n7uGO39DOjgn+Nob4WrtHeaA7T3i7DTXpkpP2OgvXuGnPbKNn/BQHs/jfM4T6bt/RJo155MtPdLru2U3gNpLzH4+T4OPFj0IkO793XkgbSvgH4PHOv0vg74zVcMfvM1cEKUxCUeW74g+5Wjb7+Oh9/Gb8JOXOQELicM9ANpXwIn3W/j4SVU0HUkL2F8g/x5Wuj7Ns4X1LKgJ5vvWv5kw/ZA2ncMk833wCRGier3WVh5+GElIC7ZeiCNO4+AdGuXxH70bP9JXRL7UbOG/BPXHRTpyFyMozcti/0InDR+ivM6Z8zQtyFaq62MZckxf/Yc8xfVMX/WrNX+4tha7c9Ap/wFt1Zb6epa7QwH1mp/Dfstj8xuPzPQpANDvlYr2/wrw1otcLYIOE+m7f0NaNeBTGu1v2Vxi4Ic/5+Av+hKfb8xbFH4LY5PcrRkqFs7i//uzeJ/qLP47xp6+QfjFgV/UNBbFH4DblH4HRjkfwAd+sBoi0KVxlyWgPnTC5i/1ID5U0N7/3KM9v4JdPC/cLS3ylXaO8sB2vt32GmvzJR/MtDew0JOe2Wb/2agvX/EeZwn0/YuBdp1GBPtXZpF2ivHH8kSpL6lDLR3aRyf5GjJULd2Fo8llv2Tk4gFZ2xZodJeCern/R2a9vqDgqa9S4G0V/ZJpu31gzwngeu7wyLaW60xlyVgcr2AyVMDRlaotDcv4RbtzQU6eF4CN7iu0t7ZDtDeVgmwjegsITOlH1xIvUeFnPbKNsvBQdPenASP82Ta3nygXUcx0d78RPZob6PPA1mC1JefwNPe/AQ+ydGSoW7tLN7am8XbqLN4aw3tbcNIe/1BQdPe/ASOFbQGBnkboEMfFdHeGo25LAHT1guYdmrAtNXQ3naO0d62QAdvh6O9Na7S3t0coL0FYae9MlO2ZaC9x4ec9so2FzDQ3jYJHufJtL3tgXYdz0R72yd4H0j7geFXjZMceLDoe4Z2n+zIA2kdgH4PHOv0yQ74TQeGeaEjcEKUxCUeW74g+5Wjbzsmwm9jp7ATFzmBywkD/UBae+CkW5gIL6GCriN5CaMTsL1SX2EixhbUsqAnm3jLn2zSulhOZVYafSfOMNkkgEmMEtVEFlYekisBccnWA2nceQSkW7skVuTZ3lldEivSrCF35rqDIh2Zi3H0pmWxIuCk0TnB65wxQ9+GaK22NpYlx+ziOWZX1TG7aNZquzq2VtsF6JRdcWu1ta6u1e7hwFptt7Df8sjs1oWBJp0e8rVa2eZuDGu1wNki4DyZtrc70K7TmdZqu2dxi4Ic/87AX3Slvu4MWxS6J/BJjpYMdWtn8R7eLN5TncV7aOhlT8YtCv6goLcodAduUegBDPKeQIc+PdqiUKcxlyVgenkB01sNmF4a2tvbMdrbC+jgvXG0t85V2ruXA7R3lbDTXpkpezHQ3nNCTntlm1dhoL09EzzOk2l7+wDtOoeJ9vbJIu2V449kCVJfHwba28dB2tvXm8X7qbN4Xw3t7cdIe/1BQdPePkDa2xcY5P2ADn1ORHvrNeayBEx/L2AGqAHTX0N7BzhGe/sDHXwAjvbWu0p793GA9g4MO+2VmbI/A+29MOS0V7Z5IAPt7ZfgcZ5M27sq0K4LmWjvqlmkvXL8kSxB6luVgfau6iDtXc2bxQeps/hqGto7iJH2+oOCpr2rAmnvasAgHwR06Asj2tugMZclYFb3AmYNNWBW19DeNRyjvasDHXwNHO1tcJX27ucA7V0z7LRXZsrVGWjvZSGnvbLNazLQ3kEJHufJtL1rAe26jIn2rsW1ndJ7IC3J4OdzHXiwKMHQ7isdeSBtbaDfA8c6faUDfrM2g9+sA5wQJXFx8YG0dRLht3HdsBMXOYGvxfBA2lrASXe9RHgJFXQdyUsY6wLbK/Wtl4ixBbUs6Mlm/ZY/2aR1sZzKrDT6zvoMk00KmMQoUU1lYeUhvRIQl2w9kMadR0C6tUtixZ7tJeqSWLFmDbmE+YG09RgeSCsGTholCV7njBn6NjxrtQ1Zc8xSzzHLVMcs1azVljm2VlsKdMqyBG5wXV2rPcCBtdrysN/yyOxWykCTrg35Wq1scznDWi1wtgg4T6btrQDadS3TWm1FFrcoyPEvAf6iK/VVMGxRqEjgkxwtGerWzuKV3ixepc7ilRp6WcW4RcEfFPQWhQrgFoVKYJBXAR362pV+i0JDWmMuS8AM9gJmAzVgBmto7waO0d7BQAffAEd7067S3oMcoL0bhp32ykw5mIH23hhy2ivbvCED7a1K8DhPpu3dCGjXjUy0d6Ms0l45/kiWIPVtxEB7N3KQ9m7szeJD1Fl8Yw3tHcJIe/1BQdPejYC0d2NgkA8BOvSNEe0t1pjLEjBDvYDZRA2YoRrau4ljtHco0ME3wdHeYldp7yEO0N5Nw057GzMlA+29LeS0V7Z5UwbaOyTB4zyZtncY0K7bmGjvsCzSXjn+SJYg9Q1joL3DHKS9w71ZfIQ6iw/X0N4RjLTXHxQ07R0GpL3DgUE+AujQt0W0t0RjLkvAjPQCZpQaMCM1tHeUY7R3JNDBR+Fob4mrtPcwB2jvZmGnvTJTjmSgvXeHnPbKNm/GQHtHJHicJ9P2bg60624m2rs513ZK74G0NIOf3+fAg0Uphnbf78gDaVsA/R441un7HfCbLRj8ZkvghCiJi4sPpG2ZCL+NW4WduMgJXE4Y6AfSNgdOulsnwkuooOtIXsLYCtheqW/rRIwtqGVBTzbbtPzJJq2L5VRmpdF3tmGYbLYFJjFKVLfNwsrDdisBccnWA2nceQSkW7sktr1n+w7qktj2mjXkHbjuoEhH5mIcvWlZbHvgpLFDgtc5Y4a+DdFabWksS4452nPMHVXHHK1Zq93RsbXa0UCn3BG3Vlvq6lrt4Q6s1e4U9lsemd1GM9Ck+SFfq5Vt3olhrRY4WwScJ9P2jgHaNZ9prXZMFrcoyPHfAfiLrtQ3hmGLwpgEPsnRkqFu7Sy+szeLj1Vn8Z019HIs4xYFf1DQWxTGALco7AwM8rFAh54fbVEo05jLEjDjvIAZrwbMOA3tHe8Y7R0HdPDxONpb5irtPdIB2jsh7LRXZspxDLR3Qchpr2zzBAbaOzbB4zyZtnci0K4FTLR3YhZprxx/JEuQ+iYy0N6JDtLeSd4sPlmdxSdpaO9kRtrrDwqa9k4E0t5JwCCfDHToBRHtLdeYyxIwU7yAmaoGzBQN7Z3qGO2dAnTwqTjaW+4q7T3aAdpbHXbaKzPlFAbauyjktFe2uZqB9k5O8DhPpu2tAdq1iIn21mSR9srxR7IEqa+GgfbWOEh7a71ZvE6dxWs1tLeOkfb6g4KmvTVA2lsLDPI6oEMvimhvhcZcloCp9wKmQQ2Yeg3tbXCM9tYDHbwBR3srXKW9xzpAe6eFnfbKTFnPQHufCTntlW2exkB76xI8zpNpe6cD7XqGifZO59pO6T2Qth2Dnz/vwINF2zK0+wVHHkibAfR74FinX3DAb2Yw+M1M4IQoiYuLD6TNTITfxllhJy5yAp/O8EDadOCku0sivIQKuo7kJYxZwPZKfbskYmxBLQt6spnd8iebtC6WU5mVRt+ZzTDZ7ApMYpSo7pqFlYfdVgLikq0H0rjzCEi3dklsd8/2PdQlsd01a8h7MD+QtgvDA2m7AyeNPRK8zhkz9G2I1morY1lyzD09x9xLdcw9NWu1ezm2Vrsn0Cn3wq3VVrq6Vnu8A2u1e4f9lkdmtz0ZaNIrIV+rlW3em2GtFjhbBJwn0/buA7TrFaa12n2yuEVBjv8ewF90pb59GLYo7JPAJzlaMtStncX39Wbx/dRZfF8NvdyPcYuCPyjoLQr7ALco7AsM8v2ADv1KtEWhSmMuS8Ds7wXMAWrA7K+hvQc4Rnv3Bzr4ATjaW+Uq7T3RAdp7YNhpr8yU+zPQ3jdCTntlmw9koL37JXicJ9P2HgS06w0m2ntQFmmvHH8kS5D6DmKgvQc5SHsP9mbxQ9RZ/GAN7T2Ekfb6g4KmvQcBae/BwCA/BOjQb0S0t1pjLkvAHOoFzGFqwByqob2HOUZ7DwU6+GE42lvtKu092QHaOyfstFdmykMZaO+7Iae9ss1zGGjvIQke58m0vYcD7XqXifYenkXaK8cfyRKkvsMZaO/hDtLeI7xZ/Eh1Fj9CQ3uPZKS9/qCgae/hQNp7BDDIjwQ69LsR7a3RmMsSMEd5AXO0GjBHaWjv0Y7R3qOADn40jvbWuEp7T3WA9h4TdtorM+VRDLT3o5DTXtnmYxho75EJHufJtL3HAu36iIn2Hsu1ndJ7IG03Bj//1IEHi3ZlaPdnjjyQdhzQ74Fjnf7MAb85jsFvjgdOiJK4uPhA2vGJ8Nt4QtiJi5zAj2V4IO1Y4KR7YiK8hAq6juQljBOA7ZX6TkzE2IJaFvRkc1LLn2zSulhOZVYafeckhsnmZGASo0T15CysPJyyEhCXbD2Qxp1HQLq1S2Knerafpi6JnapZQz6N+YG0ExkeSDsVOGmcluB1zpihb0O0Vlsby5Jjnu455hmqY56uWas9w7G12tOBTnkGbq221tW12tMdWKs9M+y3PDK7nc5Ak74K+VqtbPOZDGu1wNki4DyZtvcsoF1fMa3VnpXFLQpy/E8D/qIr9Z3FsEXhrAQ+ydGSoW7tLH62N4ufo87iZ2vo5TmMWxT8QUFvUTgLuEXhbGCQnwN06K+iLQp1GnNZAuZcL2DOUwPmXA3tPc8x2nsu0MHPw9HeOldp75kO0N7zw057ZaY8l4H2fh9y2ivbfD4D7T0nweM8mbb3AqBd3zPR3guySHvl+CNZgtR3AQPtvcBB2nuhN4tfpM7iF2po70WMtNcfFDTtvQBIey8EBvlFQIf+PqK99RpzWQLmYi9gLlED5mIN7b3EMdp7MdDBL8HR3npXae/ZDtDeS8NOe2WmvJiB9v4Sctor23wpA+29KMHjPJm29zKgXb8w0d7Lskh75fgjWYLUdxkD7b3MQdp7uTeLX6HO4pdraO8VjLTXHxQ07b0MSHsvBwb5FUCH/iWivQ0ac1kCZq4XMFeqATNXQ3uvdIz2zgU6+JU42tvgKu091wHae1XYaa/MlHMZaO+fIae9ss1XMdDeKxI8zpNpe68G2vUnE+29mms7pfdA2ikMfr7UgQeLTmZod6wXDx1HT+DXAP1+KXJff6/w+801DH5zLXBClMTFxQfSrk2E38b/hZ24yAn8aoYH0q4GTrrXJcJLqKDrSF7C+B+wvVLfdYkYW1DLgp5srm/5k01aF8upzEqj71zPMNncAExilKje4BFVeV3k/XtfYfNn95PrB8j1PHL9ILmeT64fItcPk+tHyPWj5HoBuX6MXD9Orp8g1wvJ9SJyfRu5vp1c30Gu7yTXd5Hru8n1PeT6Xu/6RtFfNwm5WcgtQm4VcpuQ24Xc4eXwpJDtvLF6WKy6PCLkUSELhDwm5HEhTwhZKGSRkCeFPCXkaSGLhTwj5Fkhz8m/aS/+RsjjQp4QslDIIiFPCnlKyNNCFgt5RsizQp4T8ryQF4S8KGR+RzEOQh4W8oiQR4UsEPKYkMeFPCFkoZBFQp4U8pSQp4UsFvJMx2W+IH1Ajr0ccznWcozl2MoxlWMpx1COnRwzOVZyjOTYyDE5LzczUQs216dT89vhYvROMCFMLt/80JOtOx0ghHdx/f6CJiJ3AknI3cAJ3VXnvNsB57zHFee8G+ic90bOmb7XAee8zxXnvBfonPdHzpm+3wHnfMAV57wf6JzzIudMz3PAOR90xTnnAZ1zfuSc6fkOOOdDrjjnfKBzPhw5Z/phB5zzEVec82Ggcz4aOWf6UQecc4Erzvko0Dkfi5wz/ZgDzvm4K875GNA5n4icM/2EA8650BXnfALonIsi50wvcsA5n3TFORcBnfOpyDnTTzngnE+74pxPAZ1zceSc6cUOOOczrjjnYqBzPhs5Z/pZB5zzOVec81mgcz4fOWf6eQec8wVXnPN5oHO+GDln+kUHnPMlpI3/5tHxVGYlDXh0vNlwNucqDTw6/rL3rMAr6qPjsqKn8pkEtVaMQj9IAnh03HsHQW36ZWD2eAXoldl0ylcSLjhlqpT2xaueU76mOqWs6KN8JkG5zE75CuzFGA11rwKd8rXIKbPmlK97TrlEdcrXNU65xDGnfB3olEvATum/8YfbKZF2U3vfSDAa/EYCr/dNoDNwtfvNRHMHg/Sy2op+ZnIJMPiR4/0WLohKaUJ9y3t2MJsJ4S1cH9dTe99OMBr8dgJ2+FmT8W8D75zfCXlykX34DvChWr8P33F0VgQGQQO1913OIHgXHwQN7wKD4D0HguA9fBA0vJcI92z9phf86NkaOcMiE+j7QJ9Gj0eDMFL6y/sJ/Ntb3wf24QdAn5Z+J9+MEPf0yaeH5UOa8lk4+ciRfLJDbqCX+5TldlC5605ubpJ7SORP9fIXUfnDk1zff4kwZPQbIl71WC16uR+5NvIhcFxyvXFRC0q/aZxSmZX0h4nw2/gR2kbcpLXMwDfBjNB30FYhf5eZTJIfMLQ7n+kdeLB3UnqveEVOtB8DJ1qg36SRY5HNuxJgfwbW6j5JMBr8CcNa3achv5OQ7f40S2t1CJb+KfMYpTIs2fyVBj0z4+7Il9nnT8yo9pomvNT/t2gmklSGhY77Z15cfU5sZgkKVAfTBd3PEs0vPPM/+9z7zCVnQb8JG9LfDAzmc6CuL4C6qP98QfzHL2FmhV+uBKwwFsNPTDJ3fMmw/ID08a8Ybr1lQeVFjqXJr8HLiejxlYTma/AYf+3ID9GfO2Trq56t6PFHjv034DtQfw77hvzQ/U+HmCFi/1Vw/H+D87Gms45imoLSTfv3W8/27xKxIDH91mPY9LPvCNngWl9H623HPLGjHAittyBLS46ZnnX1LTAYvwNOxkC/SQPGIpAYON7Y+y3DRBkl9KZxS8c0BaQ7kNC/92z/QU3o32sS+g8rcPeYaYB/DxycH1p+gMM3FaS8tx5/HwV4Y2EK8OKYpoB0BwL8R8/2n9QA/1ET4D9lIcB/BA7OTy0/wBsdhePN0T9GAd5YmAK8JKYpIN2BAP/Zs/0XNcB/1gT4L1kI8J+Bg/NLyw/wRkeBP2ibaHYMoN4owJvHrTSmKSDdgQD/1bP9NzXAf9UE+G9ZCPBfgYPzW8sP8EZHQQe43Of6axTgjYUpwMtimgLSHQjw3z3b/1AD/HdNgP+RhQD/HTg4f7T8AG90FHSAy03sv0cB3liYArw8pikg3YEA/9Oz/S81wP/UBPhfWQjwP4GD81fLD/BGR0EHuHxC5c8owBsLU4BXxDQFpDsQ4H97ti9VA/xvTYAvzUKA/w0cnKUtP8AbHQUd4PLxs7+jAG8sTAFeGdOUod6/qf9f0Qa4/yq7HPkvDWZZoQa4BPWLBQs6wOX3ZqireYNossUHeKOjoANcPltK33EI0hsFePO4VcU0BaQ7EOC53jjmqQGeqwnwvCwEeC4wwPNafoA3Ogo6wOWD47lRgDcWpgCvjmkKSHcgwFt545ivBngrTYDnZyHAWwEDPL/lB3ijo6ADXL4VolUU4I2FKcBrYpoC0h0I8NbeOLZRA7y1JsDbZCHAWwMDvE3LD/BGR0EHuHzlS+sowBsLU4DXxjQFpDsQ4G29cWynBnhbTYC3y0KAtwUGeLuWH+CNjoIOcPk+p7ZRgDcWpgCvi2kKSHcgwAu8cWyvBniBJsDbZyHAC4AB3r7lB3ijo6ADXL6srSAK8MbCFOD1MU0B6Q4EeAdvHDuqAd5BE+AdsxDgHYAB3rHlB3ijo6ADXL6JsUMU4I2FKcAbYpoC0h0I8E7eOBaqAd5JE+CFWQjwTsAAL2z5Ad7oKOgAl69Z7cQQ4NKPOgtZw9N3R/tY7E4hdwm5W8g9Qu4Vcp+Q+4U8IGSekAeFzBfykJCHhTwi5FH5Nx3F3wi5V8h9Qu4X8oCQeUIeFHJbYSx2u5A7hNwp5C4hdwu5R8i9Qm4U7bxJyM1CbhFyq5DbhNwu5I5EbLmSi+2PyvntcL4ex/l6Y4LovHzzYfp9fWi/RfYBl40JBhs5nDPQmZk6ZxKYiF11zqQDzlnkinMmgc7ZOXLOdGcHnLOLK87ZGeicXSPnTHd1wDm7ueKcXYHO2T1yznR3B5yzhyvO2R3onD0j50z3dMA5e7ninD2Bztk7cs50bweccxVXnLM30Dn7RM6Z7uOAc/ZF2pjNk05wpzzXpqm9/ZKMBkvlqF+jfOP7ASOtPzADcPVh/yTuPah+H/YHRoHuF0iUvX7fSntfSfAGVSrDEtMUkO7A+fMDvIAdqP76OJAEG3oAfEcM89n1A4DBPBD8y5CLhwYOcGA6XxU9nUeZLHuZbDUvkw1SM5ms6KN8Nmglz26rAbPbIKY7NBTV09mZqa7VcW0upX65ure/J5v3AqsncX5F7V0jyWjwGvB7gYa6NYD3AmuG/F5A9uGa8HuBhro1mZIBOkmvhbIzzWvn2hg7Gzercdq5DsJOb0udTIZdYs0bGy8UgS7HS/bFOkm+NvgxgV4ZXB2YC9YF30p0iS1fUPpN45TKrKTXTYbfxvVcXRlEGk7tXT/JaPD6SbzeVMhncNnuFMMWYZ2tmbZ/Tc9WzjFKZViyeQbyqgwZjMvHUHbSfk17fltMfILF6VAdQe/R0t49Gv2s2PuMFvQZvsj2rAdMbsVAXSVAXXR8Ssj4cARJmoE2Ivu11JE1GuRtcxkwXnRtTWVWGieBMvAYl2WJEKQyK+m0Zys655cnw91umSvKGdpdEfJ2y7GuYGh3JfhuxZ8vKjXzeZjXo6tw/VBC+6HqP1iPrmJajx6cZDR4MMN69GDgBLZByO9mZR9uwLAevQFzYkQE7gYM5LEKON4bRmuO6Q2T4bdxI7SN2GCsbExCG8GdvTK1EdDZN2ZiFBsTRoEOdsmuKoF9IMdpY4aktDHQxiFM4zREs7oj9y618saNce9V2te3Mu69GhLW5KVu60EHxSvAd+EMZVryHEpuA1Z0jTwEbfF+Ty7J2pEXm3i3GJuqe9A2SS7/Lp9NNfeYeYydmOl7gTYBZu9NgYPLnJXZMt55ueG3cRgyK7s6UBc6MFDDo4FKpS92YKBGRAOVSl/qwECNjAYqlb7cgYEaFQ1UKj3XgYHaLBqoVPoqBwZq82igUulrHBioLaKBSqX/58BAbRkNVCp9vQMDtVU0UKn0jQ4M1NbRQKXSNzswUNtEA5VK3+rAQG0bDVQqfbsDA7VdNFCp9J0ODNT20UCl0nc7MFA7IAcqxxso+e8wsptgOLkeQa5HkutR5Hozcr05ud6CXG9Jrrci11uT623I9bbkejtyvT253oFcJ8h1EbnuQq67kese5LoXuV6FXPf1rkeLf3cUspOQMUJ2FjJWyDgh470dF/mx5t9EaQCgHaDxt03vx1ugXtaHsx5oh90B49sY964niP6YKGSSkMlCpgiZKqRaSI2QWiF1QuqFNAiZJmS6kBlCZqo/gE/QbKuZqPlskuazyZrPpmg+m6r5rFrzWY3ms1rNZ3Waz+o1nzVoPpum+Wy65rMZms9mep/J/3dDDkgstkJvJUplVrISTGDdgTcJzfJs30V1Ylmhvklol6T5TUKpzEpaduImSfzG8lnAnRy7AKfOyDm1JeCcsz3bd1Wdc7bGOXd10DlnA51zV7BzZusRGKTd1N7dkowG75bE690d6Axc7d6dKZtw2YreY7hrEhf8yPHeAxdEgXe07eHRs2wmhD1wfVxP7d0zyWjwnvjZoX5P3KCm9wp5cpF9uFcS/RhOQ/1ejs6KwCBooPbuzRkEe+ODoGFvYBDs40AQ7IMPgoZ9kuGerXf3gh89WyNnWGQC3Rfo0+jxaBBGSn/ZNwl+/CcdbHemfbgfs09nat8sj4FC+1D0InI9Y39gH8p2dostX5BjhPZ1UdL7J8Nv4wFoG3ETzDIDdwezt6Yj1XuFe+KSCW0/hnbHe+GdUhbYa9q8B9KQk+KBwEkR6Ddp5Fhk8w4C2J+BdbWDkowGH8SwrnZwyFm/bPfBWVpXQzDqg5nHKJVhyebLTdEzM+7ueZl9/sSMaq9pwkv9f4tmIkllWOi4H+LF1aHEZpagQHUwXXw9RPN7+aHeZy45C/rlsJD+ZmAwhwJ1HQbURf3nMOI/fgkzK5yzErDCWAw/McncMYdh+QHp44cz3HrLgsqLHMuIR4R46S/lEZojGO5ok8zxgvDFIxiIbTLkeeJQr90xrF4WW2d5tqJz2hHA+D4SfNftz9tHkh/i1Zsbjnw3C5zzjsT5WNPbqGKagtJN+/coz/aj1W1oR3kJg352NCFYXL8poPV2Dnly9h0IrbdLlpZZM30b2VHAYDwaSECAfpMGjEUgMaAnH7kh/SiGiTJK6E3jlo5pCkh3IKEf49l+rJrQj9Ek9GNX4I450wA/Bjg4x7b8AGe585FPmxwTBXhjYQrw4pimgHQHAvw4z/bj1QA/ThPgx2chwI8DDs7xLT/AGx0FHeDyUbLjogBvLEwBXhLTFJDuQICf4Nl+ohrgJ2gC/MQsBPgJwME5seUHeKOjoANcPid6QhTgjYUpwEtjmgLSHQjwkzzbT1YD/CRNgJ+chQA/CTg4J7f8AG90FHSAy4fAT4oCvLEwBXhZTFNAugMBfopn+6lqgJ+iCfBTsxDgpwAH59SWH+CNjoIOcPmGh1OiAG8sTAFeHtMUkO5AgJ/m2X66GuCnaQL89CwE+GnAwTm95Qd4o6OgA1y+vuW0KMAbC1OAV8Q0BaQ7EOBneLafqQb4GZoAPzMLAX4GcHDObPkB3ugo6ACX72Y6IwrwxsIU4Fk74essz/az1QA/SxPgZ2chwM8CDs7ZLT/AGx0FHeDyxWtnRQHeWJgCvCqmKSDdgQA/x7P9XDXAz9EE+LlZCPBzgINzbssP8EZHQQe4fKviOVGANxamAK+OaQpIdyDAz/NsP18N8PM0AX5+FgL8PODgnN/yA7zRUdABLl+Zel4U4I2FKcBrYpoC0h0I8As82y9UA/wCTYBfmIUAvwA4OBe2/ABvdBR0gMv3IV8QBXhjYQrw2pimgHQHAvwiz/aL1QC/SBPgF2chwC8CDs7FLT/AGx0FHeDyZecXRQHeWJgCvC6mKSDdgQC/xLP9UjXAL9EE+KVZCPBLgINzacsP8EZHQQe4PMngEoYA57DVfyoT/XDWZTjfaQw4F88TQvYBl42Xo21EG4h+eT/yXeC+riuS4Q5yGeBXMAT5XGC76UQ5N2l+CjeVWWnyJ3RfXJnkZXIxQ38g4yD1/ytZf6T7Km9yvVplXVdpWNfVGtYVwoMFmhjcVcDEdDVwcLP5Yra54XZKvwSOu7nGc8prVaeUFX2Vz65NLt+ReYydmOlpF9cAnfJapsFFM4RrgW3+H2520D58g7gPvyoZ7pezXBdyliXH+DoGZnE9E8u63psYs/la2+uBOYnae0OS0eAbgLcfvvE3ANdWbgQGGVcf3ggMDL8Pb2ROCIiEdSNDUr0OON43hTypSt+5iSGp3gxen+oSW74g+5Wjb29Oht/GW5A2ZnOmuwU8a/vl1iSjwbcm8XpvC/nsJNt9W7K5g0F6WWy9icnWbN7bX86Qdbj8AmUn7dfbvfG7g8Qai6OgjKf3DLd79wz0szuSbD9rctCUwMBmatcdQF13Mo3ZnYyr6bIvb2eguMh+vQuccNBtvdyjuMhYuStLkwRH3rqdaTJWC0R3Opjc7/Zsv0ddBJYV3ZXPJKgtc0di1y1S6buBjnpPyO8953oLemG+f7+XadK4VzOpoxfYkf1wH5Ag6Nqayqw0nnoC/Im4cWF9LsO6yP1JhyaM9DIfuseNCUP7U/YDnu3z1AnjgWTzWoX/2TwuJkc6EhTkTT9nPwAM8nkhnzD8PkQH5YPMQRkz+FSI9pZk7e3S872AfEgNyPmavSUPOba3ZD4wGB8CDu6KbF1PZVYagxPIltKScdzv0q2Ksl/lYc/2R1RHlxV9lM8eITMDR9a8lyFr9gz54T2+A6Hb3Svc52I0/Xz7MDAZPQIMbKDfpLnGAn0r9ghwLB51YK/T/JDvdVoQcqYrx3gBQ+56jGk547H/YK/TY0x7nR5PMhr8OMNep8eByfmJkP+aLPvwCYa9Tk+EfK/TAq/d6KS6ADjeC0OeVKXvLGRIqouivU7pRcnw2/ikq3udngTP2n55Kslo8FMMe52eDvnsJNv9NNOaBdrWhUy2RnudlrfzSfAM4ZfF3vg9k2Tc67QQnH38e4bFmr1OzyT59zoB2xMY2Eztegao61mmMXuW6xcyry8XM1BcZL8+58Bep4VgSv+co3udFiabEyTS9pimQHQre52e92x/Qf0B4XnNXqcXknx7nRYaAjPTvU7PAx31hZAH5jxvQQ+lT+p6geFe9kWmiePFLOx3Qq5lvOTAfifgtoXGxfV5DP70MhNDR+8CeKXl/8DFci60jLlXGPzmVaY89GoWdpS81vJ9KcW+oyS9LJ/D5qP0spz+ssN7GV/3bF+iEsLXk8vvZVzCuJfRHxh00A8I844S4kDodg8M946Spu1trwMJ1hJgkgT6TZprLNCTzBuBsRDY6uLS8vqyVHl9ZVVlfVVFQ1lFqrZa/LJZkSqtrUnV1JSWp0rSJQ01FcWpmuIq8bVV9WW1jXkm0H+Z6hrIPMn4JcR7aYs15rJMCG96E8Jb6oTwZnL5vbRvZYH5IPfSvglMNm8BBzcbe2nlBAtkwGk5cb3m0lKYspf2bc/2d1RHf1uzl/Ydxr20/sCgs8+qId9L6zsQut2rObKX9m1gMnoHGNhAv0mv5she2neAY/GuA3tp30yGey/te8lw5y45xu8x5K73mZao3v8P9tK+z7SX9oMko8EfJPF7aT8AJucPQ75bSfbhhwx7aT9kTgiIhPUhQ1J9DzjeH4U8qUrf+YghqX4c7aVNf5wMv42fuLqX9hPwrO2XT5OMBn+axOv9LOSzk2z3Z0xrFmhbP2KyNdpLu7ydn4BnCL987o3fF0nGvbQfgbOPf8/weXL5vbRfJPn30gLbExjYTO36AqjrS6Yx+5LrF1qvLz9noLjIfv0q5Fv2LvcoLjJWvsrSJMGRtz536QcEZS/t157t36g/IHyt2Uv7TZJvL+1HhsDMdC/t10BH/SbkgbnEW9BD6ZO6vmG4l/2WaeL4Ngt7aZFrGd85sJf2DfBe2iUM/vQ9E0NH7wL4oeX/wMWyl1bG3A8MfvMjUx76MQs7Sn5q+b6Ulb200rdg81F6WU7/3uG9tD97tv+iEsKfk8vvpf2FcS+tPzDooF8n5HtpfQdCt3tdR/bS/gwkWL8AkyTQb9LrOrKX9lfgXtp1gHtp14320pZozGWZEH7zJoTf1Qnht+Tye2l/d2wv7W/AZPM7cHCzsZdWTrBABpyWE9dPLi2FKXtp//Bs/1N19D80e2n/ZNxL6w8MOvusF/K9tL4Dodu9viN7af8AJqM/gYEN9Jv0+o7spf0TOBZ/4caCbS/tb8lw76X9Oxnu3CXH+G+G3LWUaYlq6X+wl3Yp017aWBGjwVI59jephjqpE2VjThHO2bj6UNqI3kubU8SbEBAJK6cIn1T/BibV3KJwJ1XpO7lF+LHJA7Zbjq+Le2nzisJvYyukjdmc6ZCGU3vzixgNzi/C620d8tlJtrt1UXMHg/Sy2JrLZGu0l3Z5O1uBZwi/tPHGr20R417aXHD28e8ZpPH9YsF1sLZF/Htpge0JDGymdrUF6mrHNGbtivj20sq+bMNAcZH9WgCmOei2Xu5RXGSsFGRpkuDIW22YJmO1QHQre2nbe7Z3KIoFk6SsUPfSShDXXtpcQ2Bmupe2PdBRO4Q8MH/xFvRQ+qSuDgz3sh2ZJo6ORfx7aZFrGZ2AJIHDn+Re2l/Be2l/YVhwLmRYF4jF8LsA4sDxDukPXCx7aWXMxRnyUIIpDyVIHuJYSwXmz7TMQYUMfZsM+Vq3zEVJhtWjpKPbvGbhdgJlbd9vkUdeO6vktaho+W1enYv4t3nNAm7zKgIS185F2AEoisEHuKn4+tCBeV5u+G3sgiYyaPY7IbksuFANlrq6MCzHTACydOSgOJrR0xpzWTJ6Vy+zdFMzeldNRu/mWEbvCszo3XAZPe1qRr/QgYzePewZfWJyWXChGix1dWfI6BOBGb17lNGLNeayZPQeXmbpqWb0HpqM3tOxjN4DmNF74jJ6sasZ/WIHMnqvsGf0ScllwYVqsNTViyGjTwJm9F5RRi/RmMuS0Xt7mWUVNaP31mT0VRzL6L2BGX0VXEYvcTWjX+pARu8T9ow+ObksuFANlrr6MGT0ycCM3ifK6KUac1kyel8vs/RTM3pfTUbv51hG7wvM6P1wGb3U1Yx+uQMZvX/YM/qU5LLgQjVY6urPkNGnADN6/yijl2nMZcnoA7zMMlDN6AM0GX2gYxl9ADCjD8Rl9DJXM/pcBzL6qmHP6FOTy4IL1WCpa1WGjD4VmNFXjTJ6ucZcloy+mpdZBqkZfTVNRh/kWEZfDZjRB+EyermrGf0qBzL66mHP6NXJZcGFarDUtTpDRq8GZvTVo4xeoTGXJaOv4WWWNdWMvoYmo6/pWEZfA5jR18Rl9ApXM/o1DmT0tcKe0WuSy4IL1WCpay2GjF4DzOhrRRm9UmMuS0Zf28ss66gZfW1NRl/HsYy+NjCjr4PL6JWuZvT/OZDR1w17Rq9NLgsuVIOlrnUZMnotMKOvG2X0Ko25LBl9PS+zrK9m9PU0GX19xzL6esCMvj4uo1e5mtGvdyCjp8Ke0euSy4IL1WCpK8WQ0euAGT0VZfRqjbksGT3tZZZiNaOnNRm92LGMngZm9GJcRq92NaPf6EBGLwl7Rq9PLgsuVIOlrhKGjF4PzOglUUav0ZjLktFLvcxSpmb0Uk1GL3Mso5cCM3oZLqPXuJrRb3Ygo5eHPaM3JJcFF6rBUlc5Q0ZvAGb08iij12rMZcnoFV5mqVQzeoUmo1c6ltErgBm9EpfRa13N6Lc6kNGrwp7RpyWXBReqwVJXFUNGnwbM6FVRRq/TmMuS0Qd7mWUDNaMP1mT0DRzL6IOBGX0DXEavczWj3+5ARt8w7Bl9enJZcKEaLHVtyJDRpwMzOnxQvIJKPt45UFUPtMNl2RnA9/POBJ90gfaVhLBvE6C/SF2jGQ4RHA20caOicI9JEcOY7MgwJjsCbdw45GPShWFMdmIYk52ANg4J+Zh0YxiTMQxjMgZo49CQj0kPhjHZmWFMdkbaGPIx6cUwJmMZxmQs0MZNQz4mqzCMyTiGMRkHtHFYyMekL8OYjGcYk/FAG4cDx6TxNfGxZQsDE7yDpeX1RHI9iVxPJtdTyPVUcl1NrmvIdS25riPX9eS6gVxPI9fTyfUMcj2TXG9U1Hy9MbkeQq6HkutNyPWm5HoYuR7uXY8Q/44UMkrIZkI2F7KFkC2FbFW07OA8cTvbdI9MC3rRZQTT/X0MayfHe5uWlXTz0aryX//Qwq1Fv2wjZFsh26krrLKyrfLZNprPttV8tl1R84FffsnHdlZgUDNNEFsDdPkHh20D0iXbuC1E17L+2g78s0W2gndkFLza4N1e9MsOQkYL2VEN3u01QbmD5rPRms92zELwjgQG7/bA4N0BGLyjgcG7o6PBOyoKXm3w7iT6ZYyQnYWMVYN3J01QjtF8trPms7FZCN5RwODdCRi8Y4DBuzMweMc6GrybRcGrDd5xol/GC5kgZKIavOM0QTle89kEzWcTsxC8mwGDdxwweMcDg3cCMHgnOhq8m0fBqw3eSaJfJguZImSqGryTNEE5WfPZFM1nU7MQvJsDg3cSMHgnA4N3CjB4pzoavFtEwasN3mrRLzVCaoXUqcFbrQnKGs1ntZrP6rIQvFsAg7caGLw1wOCtBQZvnaPBu2UUvNrgrRf90iBkmpDpavDWa4KyQfPZNM1n07MQvFsCg7ceGLwNwOCdBgze6Y4G71ZR8GqDd4bol5lCZgnZRQ3eGZqgnKn5bJbms12yELxbAYN3BjB4ZwKDdxYweHcBB29r4khsjivslv7UnfU7Sqt49JbX8+itSDHpLWPSW8qjt5ipH0ormfwhzdS/JUz2MvVDSTWPXi5/qKhh6t8o7yzT61jeKWvg0Vse5Z1l9jL1QwXHE65+aeQp/RTd6BuZ7RhuZNA2buuAjds4YOPWDti4owM2jnbAxh0csHF7B2wc64CNOztg4xgHbNzJARsnOmDjBAdsHO+AjeMcsHGqAzZOccDGyQ7YOMkBG+scsLHWARtrHLCx2gEbpztg4zQHbGxwwMZ6B2zcxQEbZzlg40wHbJzBvEkhlqsYnOmP5jvkhnthk6PNo4Ft3taRNu8IbPM2jrR5J2Cbt3akzWOAbd7RkTbvDGzzaEfaPBbY5h0cafM4YJu3d6TN44FtHutImycA27yzI22eCGzzGEfaPAnY5p0cafNkYJsnOtLmKcA2T3CkzVOBbR7vSJurgW0e50iba4BtnupIm2uBbZ7iSJvrgG2e7Eib64FtnuRImxuAba5zpM3TgG2udaTN04FtrnGkzTOAba52pM0zgW2e7kibZwHbPM2RNu8CbHODI22eDWxzvSNt3hXY5l0cafNuwDbPcqTNuwPbPNORNu8BbDPXD9HoH8z3ysX1H6edyHHmtDMHYKd3qFUdp52tHbEzN+ZGHOU5YmcrR+zMd8TONo7Y2dYRO9s5YmeBI3Zul4vK8/VpTju3d8TOrXNwPETm4rbERk6798Rx2xS1d3YRo8FNymO4Tqevburn/bu3+K59hOwrZD8h+ws5QMiBQg4ScrCQQ4QcKuQwIXOEHC7kCCFHCjlKyNFCjhFyrJDjhBwv5AQhJwo5ScjJQk4RcqqQ04ScLuQMIWfmLvt+OvDyv3menXIilGStjecsMkHK5NNeSAchHYV0ElIoJC4kISQZW3YST2chXYR0FdIttuwNQD2E9BTSS0hvIasI6SOkr9cf/YUMEDJQyKpCVhMySMjqQtYQsqaQtYSsLWQdIesKWU/I+nLMhcjoK5bjJES+OkK+lqJcSIUQ+UoC+bqOwUI2ELKhkI2EbCxkiDfGmwjZVMgwIcOFjBAyUsgoIZsJ2VzIFkK2FLKVkK2FbCNkWyHbCdleyA5CRgvZUchOQsYI2VnIWCHjhIwXMkHIRCGThEwWMkXIVCHVQmqE1AqRzFa+BkS+qmKakOlCZgiZKWSWkF2EzBayq5DdhOwuZA8hewrZS/qVkH2E7CtkPyH7CzlAyIFCDhJysJBDhBwq5DAhc4QcLuQIIUcKOUrI0UKOEXKskOOEHC/kBCEnCjlJyMlCThFyqpDThJwu5AwhZwo5S8jZQs4Rcq6Q84ScL+QCIRcKuUjIxUIuEXKpkMuEXC7kCiFzhVwp5CohVwu5Rsi1Qv4n5Doh1wu5QciNQm4ScrOQW4TcKuQ2IbcLuUPInULuEnK3kHuE3CvkPiH3C3lAyDwhDwqZL+QhIQ8LeUTIo0IWCHlMyONCnhCyUMgiIU8KeUrI00IWC3lGyLNCnhPyvJAXhLwo5CUhLwt5RcirQl4T8rqQJULeEPKmkLeEvC3kHSHvCnlPyPtCPhDyoZCPhHws5BMhnwr5TMjnQr4Q8qWQr4R8LeQbId8K+U7I90J+EPKjkJ+E/CzkFyG/CvlNyO9C/hDyp5C/hPwtZKkQGfw5QnKF5AlpJSRfSGshbYS0FdJOSIGQ9kI6COkopJOQQiFxIQkhSSFFQjoL6SKkq5BuQroL6SGkp5BeQnoLWUVIHyF9hfQT0l/IACEDhawqZDUhg4SsLmQNIWsKWUvI2kLWEbKukPWErC9EJld5B1wspERIqZAyIeVCKoRUCqkSMljIBkI2FLKRkI2FDJETq5BNhGwqZJiQ4UJGCBkpZJSQzYRsLmQLIVsK2UqInJC3EbKtkO2EbC9kByGjhewoZCchY4TsLGSskHFCxguZIGSikElCJguZImSqkGohNUJqhdQJqRfSIGSakOlCZgiZKWSWkF2EzBayq5DdhOwuZA8hewrZS8jeQvYRsq+Q/YTsL+QAIQcKOUjIwUIOEXKokMOEzBFyuJAjhBwp5CghRws5RsixQo4TcryQE4ScKOQkIScLOUXIqUJOE3K6kDOEnCnkLCFnCzlHyLlCzhNyvpALhFwo5CIhFwu5RMilQi4TcrmQK4TMFXKlkKuEXC3kGiHXCvmfkOuEXC/kBiE3CrlJyM1CbhFyq5DbhNwu5A4hdwq5S8jdQu4Rcq+Q+4TcL+QBIfOEPChkvpCHhDws5BEhjwpZIOQxIY8LeULIQiGLhDwp5CkhTwtZLOQZIc8KeU7I80JeEPKikJeEvCzkFSGvCnlNyOtClgh5Q8ibQt4S8raQd4S8K+Q9Ie8L+UDIh0I+EvKxkE+EfCrkMyGfC/lCyJdCvhLytZBvhHwr5Dsh3wv5QciPQn4S8rOQX4T8KuQ3Ib8L+UPIn0L+EvK3kKVC5MSfIyRXSJ6QVkLyhbQW0kZIWyHthBQIaS+kg5COQjoJKRQSF5IQkhRSJKSzkC5CugrpJqS7kB5CegrpJaS3kFWE9BHSV0g/If2FDBAyUMiqQlYTMkjI6kLWELKmkLWErC1kHSHrCllPyPpCUkLkik2xkBIhpULKhJQLqRBSKaRKyGAhGwjZUMhGQjYWMkQSVCGbCNlUyDAhw4WMEDJSyCghmwnZXMgWQrYUspWQrYVsI2RbIfJmR95IyIdq5EMm8qEL+RCC3JQvN6nLTdtyE7Pc1Cs3ucpNn3ITpNwUKDfJTRUiN1HJTUVyk43cdCI3YchNCfJHevmjtfwRV/6oKX/kkz96yR+B5I8i8kcCuWguF5Eld92LcDoZ+345pWDZv6uNnXjLsdcf3iNGyhntl/3b5cNNeuzx5DUjaN057c1/d55XlxuLdxq/YNZjtO5CS90llrrLLXVXWuqusdRdZ6m70VJ3i6XudkvdXZa6ey11D1jq5lvqHrHUPWapW2ipe8pS94yl7nlL3UuWulctdUssdW9Z6t611H1gqfvYUveZpe5LS903lrrvLXU/Wer+sMTt2h3MdRWWumGWuh0sdZMtdTMtdfta6o6x1J1hqbvEUnedpe52S91DlrqnLXWvWeo+tNR9ban7w1LXpqO5rshS19dSt6alrtxSt6mlbhtL3XhLXZ2lbg9L3SGWuuMtdWdb6i611N1gqbvHUrfAUvecpW6Jpe4TS90Plrqllrr2ncx1XSx1Ayx161nqBlvqRlrqtrPUTbLUzbDU7WOpO9xSd6Kl7jxL3ZWWulssdQ9Y6h631L1oqXvHUveFpe4XS11Oobmuk6Wup6VukKWu2FK3oaVuc0vdTpa6akvdbEvdfpa6oyx1p1nqLrLUXWupu81S946l7gtL3S+WutZxc13SUtfHUreWpW6wpW6kpW4HS91kS900S93elro5lrqTLHXnWequsNTdbKm731L3hKXuRUvdW5a6zy11P1vqchPmuk6Wuu6WutUsdWlL3UaWus0tdaMtdVMtdbtY6va31B1lqTvFUnehpe4aS93tlrr5lrpFlrpXLHXvW+q+ttT9bqlrlTTXJSx1q1jq1rTUlVnqhljqtrLUjbXU1VnqdrfUHWipO9ZSd6al7lJL3fWWujstdY9Y6p6x1C2x1H1sqfvWUveXpa5dkbmui6Wuv6VubUtdpaVuuKVuO0vdREtdg6XuREvduZa6uZa62yx1D1rqnrTUvWKp+9hS972l7m9LXUFnc12Rpa6fpW4dS12lpW64pW4bS90ES900S91elrrDLHXHW+rOsdRdYam7yVJ3n6VugaXueUvdW5a6zyx1P1nqllrqOnQx13W31K1qqUtZ6gZb6kZZ6kZb6qZY6mZZ6vax1B1hqTvFUneBpe5qS90tlrp5lrpFlrqXLXXvWeq+sNT9aqlr1dVcF7fU9bbUDbLUlVjqhljqtrTU7Wypq7bU7WqpO9BSd4yl7gxL3UWWuv9Z6u601D1sqVtsqXvVUvehpe5bS92flrq23cx1SUtdhaVumKVuW0vdZEvdTEvdvpa6Iyx1Z1jqLrHUXWepu8tSN99S97Sl7jVL3YeWum8tdb9b6tp0N9cVWer6WurWttSVWeo2tdRtY6kbb6lrsNTtbqk7xFJ3vKXubEvd5Za66y1191jqFljqnrPUvWmp+9hS94Olbqmlrn0Pc103S11/S916lrrBlrqRlrodLHUTLXUzLHX7WOoOt9SdbKk711J3paXuFkvdA5a6hZa6Fyx171jqvrDU/WKpy+tprutoqetpqRtkqSu21G1sqdvMUreTpa7aUjfbUneApe5IS91plrqLLHXXWurusNQ9aKn7zqsb9tebo24545g1aF1hL/PfHdbL/HfneXVPnfXs49ceVx14YPICy99dbvm7uRZbrvTqtPuzLH/3hsWW3yx/N7K3+e9GW+pm9jbrPMzyd+dY/u5CS92tFp0LLX+32FL3gUXn75a/W2qpq19l2b9z7yzd7fyrTphI62ZZ6vaw1O1nqTvEUnekpe54S92phjpv+2PjfmJZ2nn/97dLyo+BD9Om2xG9aP2V6bLqdrFgAdtf0s7Tmc+hP50u9/W35rE/1cbTM3xOs37aFv978xSc+jcUM4JgRhBMDsGMJJiRBswoghllwGxGMJsZMJsTzOYGzBYEs4UBsyXBbGnAbEUwWxkwWxPM1gbMNgSzjQGzLcFsa8BsRzDbGTDbE8z2BswOBLODATOaYEYbMDsSzI4GzE4Es5MBM4ZgxhgwOxPMzgbMWIIZa8CMJ5jxBswEgplgwEwkmIkGzCSCmWTATCaYyQbMFIKZYsBMJZipBkw1wVQbMDUEU2PA1BJMrQFTRzB1Bkw9wdQbMA0E02DATCOYaQbMdIKZbsDMIJgZBsxMgplpwMwimFkGzC4Es4sBM5tgZhswuxLMrgbMbgSzmwGzO8HsbsDsQTB7GDB7EsyeBsxeBLOXAbM3wextwOxDMPsYMPsSzL4GzH4Es58Bsz/B7G/AHEAwBxgwBxLMgQbMQQRzkAFzMMEcbMAcQjCHGDCHEsyhBsxhBHOYATOHYOYYMIcTzOEGzBEEc4QBcyTBHGnAHEUwRxkwRxPM0QbMMQRzjAFzLMEca8AcRzDHGTDHE8zxBswJBHOCAXMiwZxowJxEMCcZMCcTzMkGzCkEc4oBcyrBnGrAnEYwpxkwpxPM6QbMGQRzhgFzJsGcacCcRTBnGTBnE8zZBsw5BHOOAXMuwZxrwJxHMOcZMOcTzPkGzAUEc4EBcyHBXGjAXEQwFxkwFxPMxQbMJQRziQFzKcFcasBcRjCXGTCXE8zlBswVBHOFATOXYOYaMFcSzJUGzFUEc5UBczXBXG3AXEMw1xgw1xLMtQbM/wjmfwbMdQRznQFzPcFcb8DcQDA3GDA3EsyNBsxNBHOTAXMzwdxswNxCMLcYMLcSzK0GzG0Ec5sBczvB3G7A3EEwdxgwdxLMnQbMXQRzlwFzN8HcbcDcQzD3GDD3Esy9Bsx9BHOfAXM/wdxvwDxAMA8YMPMIZp4B8yDBPGjAzCeY+QbMQwTzkAHzMME8bMA8QjCPGDCPEsyjBswCgllgwDxGMI8ZMI8TzOMGzBME84QBs5BgFhowiwhmkQHzJME8acA8RTBPGTBPE8zTBsxigllswDxDMM8YMM8SzLMGzHME85wB8zzBPG/AvEAwLxgwLxLMiwbMSwTzkgHzMsG8bMC8QjCvGDCvEsyrBsxrBPOaAfM6wbxuwCwhmCUGzBsE84YB8ybBvGnAvEUwbxkwbxPM2wbMOwTzjgHzLsG8a8C8RzDvGTDvE8z7BswHBPOBAfMhwXxowHxEMB8ZMB8TzMcGzCcE84kB8ynBfGrAfEYwnxkwnxPM5wbMFwTzhQHzJcF8acB8RTBfGTBfE8zXBsw3BPONAfMtwXxrwHxHMN8ZMN8TzPcGzA8E84MB8yPB/GjA/EQwPxkwPxPMzwbMLwTziwHzK8H8asD8RjC/GTC/E8zvBswfBPOHAfMnwfxpwPxFMH8ZMH8TzN8GzFKCWWrANL5MTblWMTkEk2PA5BJMrgGTRzB5BkwrgmllwOQTTL4B05pgWhswbQimjQHTlmDaGjDtCKadAVNAMAUGTHuCaW/AdCCYDgZMR4LpaMB0IphOBkwhwRQaMHGCiRswCYJJGDBJgkkaMEUEU2TAdCaYzgZMF4LpYsB0JZiuBkw3gulmwHQnmO4GTA+C6WHA9CSYngZML4LpZcD0JpjeBswqBLOKAdOHYPoYMH0Jpq8B049g+hkw/QmmvwEzgGAGGDADCWagAbMqwaxqwKxGMKsZMIMIZpABszrBrG7ArEEwaxgwaxLMmgbMWgSzlgGzNsGsbcCsQzDrGDDrEsy6Bsx6BLOeAbM+waxvwKQIJmXApAkmbcAUE0yxAVNCMCUGTCnBlBowZQRTZsCUE0y5AVNBMBUGTCXBVBowVQRTZcAMJpjBBswGBLOBAbMhwWxowGxEMBsZMBsTzMYGzBCCGWLADCWYoQbMJgSziQGzKcFsasAMI5hhBsxwghluwIwgmBEGzEiCGWnAjCKYUQbMZgSzmQGzOcFsbsBsQTBbGDBbEsyWBsxWBLOVAbM1wWxtwGxDMNsYMNsSzLYGzHYEs50Bsz3BbG/A7EAwOxgwowlmtAGzI8HsaMDsRDA7GTBjCGaMAbMzwexswIwlmLEGzDiCGadgOpJrvwyfs+xff18ex77IylRpGe++v3Sp37Z80ja/nf53t+H57rIc5ftiMXK/R/71v79AsRVrz7JDgej3+fao/eOPdUcfM6fZHrWu1Zzl2+HX5ZM6f3zlu+MH5zTjVN/KjwXrmu6hRRnn6fPHrVUM30+VqWV7adl8Mp1K/Wc+mV7mA/T7YjH3fbKVUtdqzvLt+Lc+SX0rn+BG5DRfj/Su/THLYegjf283Vw6WpUhjP/0uWdrMiTWVprUm8pnfr34/t6V4pa4dqWs1J/g9Bd7/W5Hvobp8O/IV/HBPgfcKsVhr8jf+38c1399a+f6A3ZrP1H5pp8G30+Clr23k/VF7T6QPXa74EI0zKUO9/6cyKhU1upyG019crMtbOP3lTfa35dFf5etvx6O/3tdfwKO/1NffnkV/SVMO6sDjn03Pl3Tk0d/UP5149Df5fyHP+Fb4+uMs+otrff0JHvub9Cd59DfdRxTx6K/09Xdm0V/S5D9dePQ39U9XHv1Nz291Y9FfUefzMu/R+qbvkMX/7h7kc+B9XMOKcmb/+wsUW7k4cw/FHrV/KGeWdT01tsY1dSoH6an5np6a79Hpag3U1Qaoqy1QVzugrgKgLmTftw+pXR2AujoCdXUC6gqrrxYCdSF9Ih5SuxJAXUmgrrD6BDIei4C6wppXOwN1dQHq6grU5fNL3XqJLEO9f1OZlSaO1Vpja67GVh+vW8dsZcG31eB1HK4Daevue87Yde+YUqihvnJ67dd3VnB5pgbk6A3to/x9vuH7VTvo/6kNNpxqg1qv2iKLDCg/obWa01yHIuAVlc0nD/sLm/mx4A8VMeX78xX81Z4CSvb8f1tlYGdDRXW6oaS6obqsuq6utLY6qeiXJZf0Uz+vwumXn6Qq3H75Cbl5jl5+osdELz8JXquY6OUnwWsVE738JHitYqKXnwSvVUz08pPgtYqJXn4SvFYxtpefRJuvWL472nxF6uhGl/EEp/pWi998lSr+7zZfpYqjzVekzuaTps1X9eS6wbtm3Xzl3Vty5WBZWsLmK/+NwGHefDXJu6abr3p6iqLNV7YSbb76B/2Ob74qTzNvvipm3nxVxbv5qnlzFM/mq3LuzVdlzJuvKng3XzVv3uPZfNW8uYtp81UJ8+arYubNVylff3ce/WW6DVxA/U3935NHf5P/9+IZ3yb/7M1jf9PmOu9d+U3fIYv/3X3I5zj+W1q1ovdE/vcXKLZy3RP1UexR+4feE8m6vhpb45o6lWP21XxPX8336HS1BupqA9TVFqirHVBXAVAXsu/bh9SuDkBdHUOqC9nGTkBdyHEsDKldcaCuBFAXMuckgbqKgLo6A3WFNRd2AerqCtQV1nhE+hcyF3YD6kLmibD6fcQx/7t8H3HMf6erO1AXchx7AHUhfRXJJ5D9hcyryBgKa55AzrXIvkf6F9Iu5D3fynBv1ROoCxlDyNiO7of+na5eQF29GXS15Id6dGvHWX+op5/B0M2Uv+d8qKffP9SrtsjiwkM9fT0F//VDPe95/3H8ROPKbD3Uw/OWt3Qp72ZC/UM9tC1+fZ6CU/+GYkYQzAiCoTllJMGMNGBGEcwoAyZ6qCd4rWJa6kM9qAd2xhHMOAMmeqgneK1iood6gtcqJnqoJ3itYqKHeoLXKiY60Th4rWKiE42D1yomOtE4eK1iohONg9cqJjrROHitYqITjYPXKiY60Th4rWKiE42D1yomOtE4eK1iohONg9cqJjrROHitYqITjYPXKiY60Th4rWKiE42D1yomOtE4eK1iohONg9cqJjrROHitYqITjYPXKiY60Th4rWKiE42D1yomOtE4eK1iohONg9cqJjrROHitYqITjYPXKiY60Th4rWKiE42D1yomOtE4eK1iWtKJxrI+DC/DZHohZdpvm25Pre4FW8DvLs5Rvi8WI/dp5F//+wsUW7H2NG/E1m2Upv1DX7LRiJnTbI9a12rO8u3QvXjQH1+J8d8+onsZZutYsK7p3jfW/DJq5pdhVjCfBpz6z3zyX5xE7JJP2l6G+f/1Sepbqk/Sl3T6uVTq8E/DpScWM59SXBm9KLMZ79uhvihzmKcgzC/K3ND7I/qizDfIMwVqDEoZ6v0/lVFpflEmz4ssm1+UyfQiyxrmF1lWMb/Isp73RZbNL8rkeZFl84symV5kWcL8IstS3hdZNr+Ik+dFls0v8mN6kWUJ74ssm1/0yXSKcJr5RZZ1vC+yLGc+RbiU+UWW5Q28L7IsK+d9kWV5Oe+LLJtfRMvzIsuyGt4XWTa/iHYVFv3NLxruw2N/E4fuy6K/+UWx/Xj0N+WH/jz6m/x/AM/4Nr3odiCP/ib/XJWnf5r8ZzUe+5vml0Es+sua9K/O0z8l/n3zGrHm0nSP5F2vST7H3b/WrPCBNP73Fyi2Yu1pXu9YU7FH7R+63iHr1tLYGtfUqfeIa2m+Zy3N9+h0tQHqagvU1Q6oqwCoqz1QF7LvO4TUro5AXZ2AugqBuuJAXQmgLmR/IX0iGVK7kHmiCKirM1BXF6CulSF/dQXq6gbUhcw5SL9Hzo9IX0Xa1T2kbUTOHStDvu8B1IXkq0if6AnUhYwhJC8M6zzUK6S6VgZ+j5xrkfcKSF7YG6grrLwQOXdE6yb/TlcBUFe0bvLf5Qlk/gprLlwFqGtl4L5IXoicOwqAupDzI5Kb9AHqCmsu7AvU1Q+oqz9QV1hjG+mryLw6AKhrZVjHjPjqfzd3RHz13+kK63o0cn0C6atIboLsr7CuuYc1TyDnWmTfh3VtCHn/uDLcpw0E6kLGEDK2o3urf6drVaCu1UKqaxBQFzK2w/o7zMqwnhP9rvDvdEX3aS0j30f3af+dr0b3aS0jT0T3af9OV3Sf9u90DQTqiu7T/rtxRM7bqwN1IX9PC+t9GlKX30bdezVkGer9m8qsND3rpTvINldjq4/XvQvHdvBtOw1e9yzZPx58Sw31ldNrvz6h4PJMDcgJ4vINht+h6GttsIf+rWontcmGU23Ks2BVu2Rx4VDcd70RL1Bs9x1p6P/Tzn97KO5+3n/cPhR32QPEtIDtL+F94VhJCe+L7vSH4tK2+N+bp+DUv6GYEQQzgmBovhlJMCMNmFEEM8qAiQ7FDV6rmJZ6KO4YghljwEQH5wavVUx0cG7wWsVMI5hpBkx0cG7wWsWE7eDc6FDc4LWKiQ7FDV6rmKMJ5mgD5hiCOcaAOZZgjjVgokNxg9cqJjoUN3itYqJDcYPXKiY6FDd4rWKiQ3GD1yomOhQ3eK1iokNxg9cqJjoUN3itYqJDcYPXKiY6FDd4rWKiQ3GD1yomOhQ3eK1iokNxg9cqJjoUN3itYqJDcYPXKiY6FDd4rWKiQ3GD1yomOhQ3eK1iokNxg9cqJjoUN3itYqJDcYPXKiY6FDd4rWKiQ3GD1yomOhQ3eK1iokNxg9cqJjoUN3itYsYSzFgDZhzBjDNgxhPMeANmAsFMMGAmEsxEA2YSwUwyYCYTzGQDZgrBTDFgphLMVAOmmmCqDZgagqkxYGoJptaAqSOYOgOmnmDqDZgGgmkwYKYRzDQDZjrBTDdgZhDMDANmJsHMNGBmEcwsA2YXgtnFgJlNMLMNmF0JZlcDZjeC2c2A2Z1gdjdg9iCYPQyYPQlmTwNmL4LZy4DZm2D2NmD2IZh9CCaPYPYlmH0VTBgO3ObZC1zc4LdNt3dfd1An7rtLmvbN037NUz6j31+g2Iq1p/kBEN0DGrR//LH+twdut1Pq8kmdP77y33E5zTjVt9rEgnV+f8myt6eP98DtCl6fJAduZ90n/8WB2y75pO3A7f+vT1LfUn2SHrjt51vdIep+npX663Kar+u9a97DuJsPmmN6zqVFHMZd6ykI82HcE70/oodx70GeZVLjU8pQ7/+pjErzYdw8h2U3H8bNdFh2DfNh2VXMh2XX8x6W3XwYN89h2c2HcfMclt18mLKjh2VX8R6W3XyYNc9h2eXch2WXMR+WXcF7WHbzYe48h2U3HxbMc1h282HBPIdlNx8WzHNYdgnzYdnNhwXzHJbdfC/Cc1h2RQnzYdkVvIdllzAfll1R5/P6frHmot6r9Sef4/h1aXWO8n2xmP5ezf/+AsVWMN9vulfrr9ij9g+9V5N1AzS2xjV1KocdoPmeAZrv0elqC9TVDqirAKirPVBXB6AuZN93DKldnYC6CkOqC9nGOFAXchwTIbUrCdRVBNSFzDmdgbq6AHV1BeoKay7sBtTVHairB1BXWGMb6avIvNoTqAuZc8IaQxFf/e/mjoiv/jtdvYC6kOPYG6gL6atIboLsL2ReRcZQWPMEcq5F9j3Sv5B2Ie8fV4b7tFWAupAxhIzt6N7q3+nqA9TVl0EX72+yJSX+um+c2JWjfDdd3wDu9yvPUb7P7yf6Gf3+AsVWrD3Na+ZJxR61f/xx8/uuu8bWuKZOvQfprvme7prv0elqC9TVDqirAKirPVBXB6AuZN93DKldvYC6kOPYG6gL6audgbqQ/VUE1IWMobDmiS5AXci+R/oX0q5CoC5k/kqE1K5VgLqQMYSMbWQMdQXqCuu83QmoqxtQl38PUuj9n/JX9bcM3UElbSzfQ//ex+n2R8sy1Ps3lVlp4ve6Q1JyNbb6eN3zDrZDVQo0+H4WfHsNPm7Bd1hB/D8e2kIN9ZXTa7+j1ldweQquHa0kl/nK36knWvrfv7nyud8h6olCHZTP/bo2hvbQv40p/6dtsuHUNuUp16a/2/wf9K62gvXUBBcOkNnX877/+gCZl7wKtw+QKaumyYfB/hLOB/RS6VTTpuR8HvubDpChh6/QtjT5p4JT/4bGdnRgS/BaxUQHtgSvVUx0YEvwWsVEB7YEr1VMdGBL8FrFZPPAlr0JZm8DJjrUJXitYqJDXYLXKuZogjnagDmGYI4xYI4lmGMNmOhQl+C1iokOdQleq5joUJfgtYqJDnUJXquY6FCX4LWKiQ51CV6rmOhQl+C1iokOdQleq5joUJfgtYqJDnUJXquY6FCX4LWKiQ51CV6rmOhQl+C1iokOdQleq5joUJfgtYqJDnUJXquY6FCX4LWKiQ51CV6rmOhQl+C1iokOdQleq5joUJfgtYqJDnUJXquY6FCX4LWKiQ51CV6rGNOhLnkEYzrURdazvgg6VVrJul+KvNCcbmD12+J/d2ue717hF5r731+g2Aq1h2wIbq3Yo/YPfeCvETOn2Z4cpa7VnOXboXuhuT++co/tgJxmnOpb9IXpObHgRmXff3Uv4Pf9VupfN6f5uiQnaDvVl6d8f4zUt1O+A+r36dJq1n2Iwvn+7QEJeUodHTvfRjp2rIdvkP7h6H/ZP0UG+/1rWdrMiTWVPKU/aR/9Vy+IX8dTEOYXxK/m/RHdyz1sTrM+3JiWpnz9w1n0p5v0j2DRnyr19Y/k0C/mQl//KB770/4BADcoOYJrL7TuYAt1buc5HCS9wnM7fVaDjWuQuV33YBLtH3V+4zncKJ3KUfRTe9pq+scfy3aaOl+X/4xFPtFF8W1JGymeXvt/Tz8b5g1YXKMzX7FB93AU/Yzmvo0UnqM7VGdF/IjqjceW7xv1OaPWpJ2+jbp5Ll/Bj89ptn1zhTfpxpHyL5rTaZ+01uCpvnwFvzXhbrfl6HWa2mXSuQNp13bKmLTWtEF+NtbQ/pyYvU9XtP25BlvHkPbfabCV2kNt1R0Q1JrgJlpw+Rqc6k+xmP5+gc6Hqm15FpvyFfxUy9jr+p/aNUqxQe1/FaPa4OPrNP2v9kNebPlcRvtBl1tlGer9m8qspHkPpkmldAfTAOeqSt3hatT/Zir93p6MlS721LH08buRuJ/tXRcSvf7f+7lU/p1vG33oNMfwbyy2Yrm6g6advg0dyd+obZNFja1C8r15ig4d3n/YuhXB05cYqHnIx+9H4uAeJW+017RH9vEBOfrvpuPWXmOr+t0nkXE7WBk3+t1+vxbGlu9nlTs03dfG9P08fE7QFh9/OOmH+0k/yELvrf3v5nxeVfJOaceDynjQ8c+fE2x3J1Kn8xf1YetCDZ4+sK/6NvWl9kodHQP1BQK6h8DpePi5Wpcr/L/V5YpCS3tV/8mJNd8ftzbgfX35Cv40y1wVJ3+ji7lWBp1nE78/UxljOgZ0brvc8N20/Xma9vj4hKb9FB9XbPXx51vaX6hpP7XLv7/NV/AXaWJNtZO2K4d8pvqx7qVmCU27CmPL94v/t7q+b1priTX3vU6H+oIR//sKYnqfKFBspXX0+2nbdbEd19hqG+u45nvUsb5WM9a6uU19sYfOPhr3aoy31+ii80rY3wVwq6fgv34XAPr7S8uqK2qrK9LpqtJ0fWm6LNvfX1xZWV5VXJMqrairbagrLcn295eXlqcrK6sra8trG6pKa2uy/f21ZeU1tWIQUvXpxu74p+/XrQdTriKLv6ZM15wpnvJCin+EzFELyBzViNV8n8S9aMHlGP5t1KH5rNWc4Ge6tWi6Ru/j/e8umLO8jX5de1JHeZQsHbz/0/6iunw78hX8c2SOkIWuq/t/H9d8f1vl+wN2az5T1+jba/DtNXg5PouUvEXbjl6jbPxORT/9TLXN9x3p132VecDJd5ykyt1+x0kq7cw7TvIIxvSOE4oxveOEYkzvOKEY0ztOKMb0jhOKMb3jhGJM7zihGNM7TijG9I4TijG944RiTO84oRjTO04oxvSOE4oxveOEYkzvOKEY0ztOKMb0jhNZ7/QeGW+vAI2xGGkL6x6Zf/E72sq2R6aY4FTfsu2R8f1Xt0fG91upfyPyXcNiQdtDsUcmVebsHplipX9Y9siQ/uHo/5ayR2ZD7/9h3iNT5l3z75FJM++Rad7DMoJDP9nDwrJHJpWqz9YemR89fba5d0XmRlnUNXmaL3OU78kHfg/lI+qcwLPvJlXqt6ktsVP3m6D6+w+9Z1R/u9XhVb6j6m+XnfYut4+G/o7XWmO/7rfhGM6eNPdvw+qegDO9f2Vbd1TGyF8v1vmALMPnBPEdFJtVjLqPpiP5brXP6d+qvxmO8/6Vbfhd0anbm0PXxIcpOn38RKLzL4OdsZidr/mf234TpPYUxpbvl06G76btob+dD5+z7F/dwT44vylOqWNQ7/0rba/1rv0cqIt7idtLaVsh6T+/bdTv6W++8v8JlrY15wCfp9AckNDYo/6uOFtpl38gAo0b229XSc330kMVCpTvTSrf29YHEp3/9BtpJ0Nbdic68ww628f0OdLXr/MD+jvwXsp3+z61H8Hso+jS5WL52dGxoI26/R42n2I6/Cml+jgd27jGHvW32sOUdvljTn2qo0aPj09ovpf+rqH6VEL5Xp1P6X53pjZ0MrTlCKJT9Sn/b+jvttRvfP06P6C/YR5NcLLo1guysXekdU7QXrp/LV+xSTevUPz/d16Jx5afC1ordZTDqgdZ5Gi+h9qi+hrdA6nD+/rUOfd071/5/b1zgvbla/6+cd+Gd12o+R71b+g6to2/6NaA6L6rcxW99Lc7HR9Q91/4+I+IzgsUnf7fm/JW0z2upq0cecu3meaPfI09ahuvUNrl5+o8TV9RPaov0e+l3F/NW62V76V5y+aLtC/Ve7Gh3r+pDEtHzXfmKN/NNI5VOcr3xWL6dd+m9ZyYfmyGYuxJqzHp26P2j3qfy/Q8R6Wc7/xcY9oPSsdGtSNGbM/7hzb5ax26nJWn/B3VreI41zvFEFWqY1TwD3bxro+mitUcoutf+v26+6k2lv7VrUHQz3Xtl0V9FqNpvTKmz5Wtlf5iivmSFe2v/H/RX/n/z/6if6ceLJav6S/TuND/69ojy/A5wfbodOXF7HFM9a7oeBZq6nxexZy/GnQ8N598tyyt5nB8t57nUp/LJ9+bE9M/26R7viqu4OlYMOeashXxNV2u0fmFzqfVmP//5lqmPTnlK9r+XKX9tlgz/a6li7WCmJ6jq7nWrzPFZpb8pSKs/qLmWl0uW5F7JlN7CpT26HTZ/EZtj248VX4liy7f0TV5WVrNCX7HUO/zVEZFn+98u2RR890/8UHfp+Mxc7zbfmvy96Cq/api/fHI/wc78hX8Z96/dC3c9lv+f9H/1E/V/tfFJMWr94O6+UnlILLo5qc2Sp1uH53q6/R76Hj49wm69Qj6e7a/HhH2/fq/ef9vafv1/+v98v92v3qL269fVd5QVVJSky6pqquvSpf/l/v1CzwFMi47kBzViNV8n8T1suByDP826tB81mpO8LOw79fv7ikI8379hPdHYdyv7/tOGJ5DWtWrcPt5gYr6bD0vwLPuU1LNvNbQ9LzA8DnN+k33MRSn/g3FjCCYEQRDY2AkwYw0YEYRzCgDJjqjNXitYqIzWoPXKsbFM1qj81eD1yqmgWAaDJhpBDPNgInOXw1eq5jo/NXgtYppaeev6tbHhnsY3uc1SsuYn6WqtO3xZn4f4gr/nq++D5Hpt0br+xB1a23/9lmgNkpdPqnzx1euw00mONW38pU6unbln1vO+QxUZaqsntcni1P/nU8Wp1uiT7ZS6lrNWb4d/9YndWvCEjeDXM/0rnmfda2oZ/4dsemZNmq/uhbjr53FYvo1Kr9f/6tn2qZ7/w/zM23V3nV7T6QP9fEU6dYbpAz1/p/KqFTU6HIaTn9xsS5v4fSX1+jeHwnUX8X7/sjyet0zQkD9pb7+9iz6m9erOvDY3/QMVUce/y/WPWsD1N/kP4Us+otrdc8+APu/Vve8DlB/E89P8uiv8PUX8YxvU3x15rG/6X0WXVj0lzStZ3fl0d8UX914+r/p/bvdefQ3+WcPHv1N/d+TR3+T//fiGd8m/+zNY3+dz7tXiTUX9Z6oD/kcx39LV/g+3f/+AsVWrnuiPoo9av/QeyJZ11dja1xTp3LMvprv6av5Hp2u1kBdbYC62gJ1tQPqKgDqQvZ9+5Da1QGoq2NIdSHb2AmoCzmOhSG1Kw7UlQDqQuacJFBXEVBXZ6CusObCLkBdXYG6whqPSP9C5sJuQF3IPBFWv4845n+X7yOO+e90dQfqQo5jD6AupK8i+QSyv5B5FRlDYc0TyLkW2fdI/0LahbznWxnurXoCdSFjCBnb0f3Qv9PVC6irN4Mu3e/wsgz1/k1lVqzv0s7V2OrjdftjWlnwuucjdWvHHUhbd99zxq57x5RCDfWV02u/vruCyzM0oJ/B0M2Uv6cvc6Kfq3bQ/1MbbLh+/1Cv2iILfRFxqznNdaiFf8TDmwM9Bf/1w5v+mPr9xfRi1OJ25DsZ9Kdo0MWUttDvVfuglebvcgz/z1X+tWHVz+lnHTV1vk5/kqL2+u1op/xLF6yQP2r5+jvz6NeOVRdy3VlpJ+3voSAbfH1+zObHli+5Sl3TJjPFvhy8femYUvI03+UX32c6k8/8/kwotnK92I4e6sigv8knmV5UXaLzycBLd7x/deOQo9ikxinY1uocjX15yneqNlKMLuflKv9vpXyetwJYnW/6dU0bOi1/105jK/1MPXwkpsH7uuhh6jpdbUg9xasvPeEawyKNTb7t/weBmYPXhoocAA==","debug_symbols":"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D2ehfh7q5yHfHvLtysOZ8nAW6uehfh7y7SHfrjycKQ9noX4e6uch3x7y7crDmfJwFurnoX4e8u0h3648nCkPZ6F+HurnId8e8u3Kw5nycBbq56F+HvLtId+uPJwpD2ehfh7q5yHfHvLtysOZ8nAW6uehfh7y7SHfrjycKQ9noX4e6uch3x7y7crDmfJwFurnoX4e8u0h3648nCkPZ6F+HurnId8e8u3Kw5nycBbq56F+HvLtId+uPJwpD2ehfp7q5ynfnvLtysOZ8nCW6uepfp7y7SnfrjycKQ9nqX6e6ucp357y7crDmfJwlurnqX6e8u0p3648nCkPZ6l+nurnKd+e8u3Kw5nycJbq56l+nvLtKd+uPJwpD2epfp7q5ynfnvLtysOZ8nCW6uepfp7y7SnfrjycKQ9nqX6e6ucp357y7crDmfJwpqeYWaqf6zlmpgeZmfJwpjycpfp5qp/raWamx5mZ8nCmPJyl+nmqn+uZZqaHmpnycKY8nKX6eaqf68lmpkebmfJwpjycpfp5qp/r+WamB5yZ8nCmPJyl+nmqn+spZ6bHnJnycKY8nKX6eaqf61lnpoedmfJwpjycpfp5qp/riWemR57Zk4fLF3rycA8aQib05lg3cqEQSqElVEL7oFvnDxpCJiSOIY4hjiGOIY4hjiEOE4eJw8Rh4jBxmDhMHCYOE4eJY4pjimOKY4pjimOKY4pjimOKY4rDxeHicHG4OFwcLg4Xh4vDxeHiCHGEOEIcIY4QR4gjxBHiCHGEOFIcKY4UR4ojxZHiSHGkOFIcKY4ljiWOJY4ljiWOJY4ljiWOJY4ljhJHiaPEUeIocZQ4ShwljhJHiWOLY4tji2OLY4tji2OLY4tji2MfjicP96AhZEJTyIVCKIWWUAmJQzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6byk85LOSzov6XxL51s639L5ls63dL6l8y2db+l8S+db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","file_map":{"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\n/// Asserts the validity of the provided proof and public inputs against the provided verification key and hash.\n///\n/// The ACVM cannot determine whether the provided proof is valid during execution as this requires knowledge of\n/// the backend against which the program is being proven. However if an invalid proof if submitted, the program may\n/// fail to prove or the backend may generate a proof which will subsequently fail to verify.\n///\n/// # Important Note\n///\n/// If you are not developing your own backend such as [Barretenberg](https://github.com/AztecProtocol/barretenberg)\n/// you probably shouldn't need to interact with this function directly. It's easier and safer to use a verification\n/// library which is published by the developers of the backend which will document or enforce any safety requirements.\n///\n/// If you use this directly, you're liable to introduce underconstrainedness bugs and *your circuit will be insecure*.\n///\n/// # Arguments\n/// - verification_key: The verification key of the circuit to be verified.\n/// - proof: The proof to be verified.\n/// - public_inputs: The public inputs associated with `proof`\n/// - key_hash: The hash of `verification_key` of the form expected by the backend.\n/// - proof_type: An identifier for the proving scheme used to generate the proof to be verified. This allows\n///               for a single backend to support verifying multiple proving schemes.\n///\n/// # Constraining `key_hash`\n///\n/// The Noir compiler does not by itself constrain that `key_hash` is a valid hash of `verification_key`.\n/// This is because different backends may differ in how they hash their verification keys.\n/// It is then the responsibility of either the noir developer (by explicitly hashing the verification key\n/// in the correct manner) or by the proving system itself internally asserting the correctness of `key_hash`.\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time.\n// The message can be a string, a format string, or any value, as long as it is known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<T>(predicate: bool, message: T) {}\n\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_add(y)\")]\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_sub(y)\")]\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n#[deprecated(\"wrapping operations should be done with the Wrapping traits. E.g: x.wrapping_mul(y)\")]\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    use super::ops::arith::WrappingMul;\n\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n\n    #[test]\n    fn test_wrapping_mul() {\n        let zero: u128 = 0;\n        let one: u128 = 1;\n        let two_pow_64: u128 = 0x10000000000000000;\n        let u128_max: u128 = 0xffffffffffffffffffffffffffffffff;\n\n        // 1*0==0\n        assert_eq(zero, zero.wrapping_mul(one));\n\n        // 0*1==0\n        assert_eq(zero, one.wrapping_mul(zero));\n\n        // 1*1==1\n        assert_eq(one, one.wrapping_mul(one));\n\n        // 0 * ( 1 << 64 ) ==  0\n        assert_eq(zero, zero.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * 0 == 0\n        assert_eq(zero, two_pow_64.wrapping_mul(zero));\n\n        // 1 * ( 1 << 64 ) == 1 << 64\n        assert_eq(two_pow_64, two_pow_64.wrapping_mul(one));\n\n        // ( 1 << 64 ) * 1 == 1 << 64\n        assert_eq(two_pow_64, one.wrapping_mul(two_pow_64));\n\n        // ( 1 << 64 ) * ( 1 << 64 ) == 1 << 64\n        assert_eq(zero, two_pow_64.wrapping_mul(two_pow_64));\n        // -1 * -1 == 1\n        assert_eq(one, u128_max.wrapping_mul(u128_max));\n    }\n}\n","path":"std/lib.nr"},"50":{"source":"// Simple Token Contract implementation in Noir\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    version: pub u32,\n    // The initial state of the contract. This is the state before the transaction is executed.\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    // The state of the contract after the transaction is executed.\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    // The identity used to execute the transaction. This is the same as the one used in the\n    // BlobTransaction.\n    identity_len: pub u8,\n    identity: pub str<256>,\n    // TxHash of the BlobTransaction.\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    // The index of the blob being executed.\n    index: pub u32,\n    // Number of blobs used by the contract\n    // If blob_number is > 1, then you need multiple occurence of parameters group \"Blob\"\n    blob_number: pub u32,\n    // --- Blob\n    // At least one blob_index must match the index parameter\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 32],\n    // ---\n    // Number of blobs in the transaction. tx_blob_count >= blob_number\n    tx_blob_count: pub u32,\n    // -------------------\n    // Weither the execution was successful or not. If false, the BlobTransaction will be\n    // settled as failed.\n    success: pub bool,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(identity.as_bytes(), identity_len as u32);\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    println(f\"Identity: {identity}\");\n    println(f\"Password: {password}\");\n    println(f\"extended id: {id}\");\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), identity_len as u64 + 1 + 32);\n    println(f\"Input Hash: {input_hash}\");\n\n    assert(input_hash == blob);\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 32);\n    assert(blob_len == 32);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n","path":"/Users/lancelot/Programming/Hyl/hyli-noir/check-secret/src/main.nr"},"57":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks::<N>(message_size, h, msg_block)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let new_msg_block = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, modulo)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    let num_blocks = N / BLOCK_SIZE;\n\n    // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n    // for the given message size with a lookup.\n    //\n    // These can be reasoned about as followed:\n    // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n    // - `states[i]` should then be the state after processing the first `i` blocks.\n    // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n    // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n    //\n    // In other words:\n    //\n    // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n    // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n    //\n    // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n    let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n    let mut states: [STATE; N / BLOCK_SIZE + 1] = [h; N / BLOCK_SIZE + 1];\n\n    // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n    // no matter the value of `message_size`.\n    //\n    // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n    let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n        message_size / BLOCK_SIZE\n    } else {\n        0\n    };\n\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        println(f\"extended id: {msg}, {message_size}, {msg_start}\");\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, msg_start);\n\n        blocks[i] = new_msg_block;\n        states[i + 1] = sha256_compression(new_msg_block, states[i]);\n    }\n    // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n    if N % BLOCK_SIZE != 0 {\n        let new_msg_block =\n            // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks) };\n\n        // Verify the block we are compressing was appropriately constructed\n        verify_msg_block(msg, message_size, new_msg_block, BLOCK_SIZE * num_blocks);\n\n        blocks[num_blocks] = new_msg_block;\n    }\n\n    // verify the 0 padding is correct for the last block\n    let final_block = blocks[first_partially_filled_block_index];\n    verify_msg_block_zeros(final_block, message_size % BLOCK_SIZE, INT_BLOCK_SIZE);\n    (states[first_partially_filled_block_index], final_block)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) {\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = msg_item << 8;\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n        }\n    }\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, 0);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], 0);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = msg_item << 8;\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = (item << 8) + b1 as u32;\n    item = (item << 8) + b2 as u32;\n    item = (item << 8) + b3 as u32;\n    item\n}\n\nglobal BIT_SHIFT_TABLE: [u32; 4] = [1, TWO_POW_8, TWO_POW_16, TWO_POW_24];\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item * BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if shifts >= 4 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        if shifts == 4 {\n            0\n        } else {\n            item / BIT_SHIFT_TABLE[shifts]\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let mut msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks::<N>(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/sha256/v0.2.1/src/sha256.nr"}},"names":["main"],"brillig_names":["print_unconstrained","print_unconstrained","print_unconstrained","print_unconstrained","build_msg_block","attach_len_to_msg_block","print_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}