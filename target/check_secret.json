{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"2408654658531913618","abi":{"parameters":[{"name":"hyli_output","type":{"kind":"struct","path":"noir_utils::HyliOutput","fields":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"identity","type":{"kind":"string","length":256}},{"name":"tx_hash","type":{"kind":"string","length":64}},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"blob_contract_name","type":{"kind":"string","length":256}},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"success","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"password","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"18188290404514020094":{"error_kind":"string","string":"extend_from_slice out of bounds"}}},"bytecode":"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","debug_symbols":"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N843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfON843zjfOD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/O7z7c9a8lxd2He6u4/p25W3UqqUHN6188udWi9vUv093q1GMX56/HLs7fj4XHusfSY8Nj02M8Fo/FY/PYPDaPzWPz2Dw2j81j89g8Do/D4/A4PA6Pw+PwODwOj/P26Hcf7nqs332492Phse6x9Njw2PTY8tj2GI/Go/FoPBqPxqPxaDwaj8aj8QgewSN4BI/gETyCR/AIHsHj4jzvf/z74vytgupUXr8O/FaDmtSiNnVKXZy/VaOC6hSP5JE8kkfySB6Dx8X5uPd2cf5WnUrq8rhP4+L8rRa1S110X/+0V79bcG8VVKeuleetBjWpRV0rr1udeuyi+60aFVSvKxaPxWPxWDwWj8Vj89g8No/N46J73ie0eWwem8dF91uduvbwODwOj4vut0pX8Dg8Do/D45TH3YK7H7tbcG8VVKfSFeO9o7sF9/7bRW2qzupuwb2ubTwaj8ajJTVcwaPxaDwaj+ARPIJH8AgeweP+l8jvHQWP4BE8urO66H5d23l0Hp1HH9R0BY/Oo/NIHskjeSSP5JE8ksdF92tHySN5DB7DWd1039cOHoPH4DF8P266X1fwGDwmj8lj8pg8cN5w3nB+t+DeV+zaEc4bzhvOG84bzhvOG84bzhvOG84bzhvOG84bzhvO7xbc+zEeOG84v1tw7ytO7QjnDecN5w3nDecN5w3nDecN5w3ngfPAeeA8cB44v1tw78cmtahN8bg4v3cUOA+cB84D54HzwHngPHAeOA+cB84D54HzwHng/G7BvR/jgfPA+d2Ce11xcf7aEc4D54HzwHngPHAeOA+cB84D54HzwHngPHAeOL9bcO/HeOA8cH634F5XXJy/doTzwHngPHAeOA+cB84D54HzwHngPHAeOA+cB87vFtz7MR44D5zfLbjXFRfnrx3hPHAeOA+cB84D54HzwHngPHAeOA+cB84D54HzuwX3egzngfPA+d2Ce11xamYInAfOA+eB88B5x3nHecd5x3nHecd5x3nHecd5x/ndgns9hvOO847zuwX3vqJmho7zjvOO847zjvOO847zjvOO847zjvOO847zjvOO87sF936MB847zu8W3PuKmhk6zjvOO847zjvOO847zjvOO847zjvOO847zjvOO87vFtz7MR447zi/W3DvK2pm6DjvOO847zjvOO847zjvOO847zjvOO847zjvOO84v1tw78d44Lzj/G7Bva+omaHjvOO847zjvOO847zjvOO847zjvOO847zjvOO84/xuwb0f44HzjvO7Bfe+omaGuwU381aNCqpTSQ1qUovaVL0LvFtwb9WooDqV1KAmtahN8QgewSN4BI/gETxuzu/TuDl/qU2dUjfn995uzl8qqE5dK8etJrWoTdV3OtF9d9/eKqj6Tie6E9139+2tFrVdwQPdaVpPdN/dt9cV6E50pxS/u29vxWP4aUJ3ovvuvr1Vp+oVPdGd6E7vyhPdd/ftdQW6E91pWk9039239xU80J1S/O6+vRWPXRNoojvRfXff3spZ7eFaHuhO78oT3Xf37XUFuhPdaVpPdN/dt/cVPNCdUvzuvt3q7r7dV9zdt3tHQ4oPKX53395qUNO1y2Ob4iHF7+7b6wopPqT4MK3f3be34iHFhxQfUvzuvr0Vj6gJdEjxIcXv7ttbTWq5locUH96VDyl+d99eV0jxIcWHaf3uvr0VDyk+cD5wPnB+d99eV2RNoAPnA+cD5wPnA+cD5wPnA+cD5wPnA+cD5wPnA+cD50OKD5wPnA+c39231xWzJtCB84HzgfOB84HzgfOB84HzgfOB84HzgfOB84HzgfMhxQfOB84Hzu/u2/uKmkAHzgfOB84HzgfOB84HzgfOB84HzgfOB84HzgfOJ86naX3ifOJ84vzuvr2vqAl04nzifOJ84nzifOJ84nzifOJ84nzifOJ84nzifOJ8mtYnzifOJ87v7tv7ippAJ84nzifOJ84nzifOJ84nzifOJ84nzifOJ84nzifOp2l94nzifOL87r69r6gJdOJ84nzifOJ84nzifOJ84nzifOJ84nzifOJ84nzifJrWJ84nzifOp7vsd/fttSOcT5xPnE+cT5xPnE+cT5xPnE+cT5xPnE+cT5xPnE/T+sT5xPnE+XSX/e6+vXaE84nzifOJ84nzifOJ84nzifOF84XzhfOF84XzhfPlXfnC+cL5wvlyl/3uvt07WjhfOF84XzhfOF84XzhfOF84XzhfOF84XzhfOF84X96VL5wvnC+cL3fZ7+7ba0c4XzhfOF84XzhfOF84XzhfOF84XzhfOF84XzhfOF/elS+cL5wvnC932e/u22tHOF84XzhfOF84XzhfOF84XzhfOF84XzhfOF84Xzhf3pUvnC+cL5wvd9nv7ttrR6vead7dt/u92t19e6tN1bvAu/v2Vo0KqlNJDYrH5rF5bB6Hx+FxeJz6TPPuvr3VoCZVn2ne3be3Om91d9/eqj7TvBtvb5XUoOq7sNG90b3RvdG93XPb6N7o3uje7q1v99w2uje6N7q3e27bPbeN7o3uje7tntv2GdpG90b3RvdG90b3ds9to3uje6N7u7e+3XPb6N7o3uje7rlt78o3uje6N7q3e27bZ2gb3RvdG90b3Rvd2z23je6N7o3u7d76ds9to3uje6N7u+e2vSvf6N7o3uje7rltn6FtdG90b3RvdG90b/fcthTfUnxL8e3e+nbPbUvxLcW3FN/uuW3vyrcU31J8S/Htntv2Gdp2z21L8S3FtxTfPkPb7rltKb6l+Jbi27314976keJHih8pftxbP96VH5wfnB+cH/fWj8/QDs4Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/Oj3flB+cH5wfnx7314zO0g/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pz4135wfnB+cH5cW/9+Azt4Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD8eFd+cH5wfnB+3Fs/PkM7OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/OD84Pzg/3pUfnB+cH5wf99aPz9AOzg/OD84Pzk9xno/iPB/FeT6K83wU5/kozvNRnOejOM9HcZ6P4jwfDx6NR+PReDQejUd9hpaPxqPxaDyK83wU5/kIHsEjeBTn+SjO8xE8gkfwCB6dR+fReXQenUfnUZ+h5aPz6Dw6j3RWxXk+kkfySB7p+1Gc5yN5JI/kMXgMHoPH4DF4DB6DR32Glo/BY/CYPKazKs7zMXlMHpPH9P0ozvMxeUwei8fisXgsHovH4rF4LB71GVrqvqXuW+q+pe5b6r7lY/PYPDaP7ftRnOdj8zg8Do/D4/A4PA6Pw+PwODzqM7TUfUvdt9R9S9231H3LhnPdt9R9S923bDhvONd9S9231H3LhvPWeOBc9y113/LVfbuviEftCOe6b6n7lrpvqfuWDee6b6n7lrpv2XDecK77lrpvqfuWDeet88C57lvqvuWr+3Zfka12lO/PNLNVszVbNVuzVbM1WzVbs1WzNVs1W7NVszVbNVvz1X17qaB4DB6Dx+AxeAweg8fN+f3sZ6OC6tT7/WC+um8vNSlnhXPdt9R9y1f37T615fuBc9231H3LV/ftdQWPxQPnum/56r7dV+C8bR44133LV/ftdUW9JrbNA+e6b6n7lq/u233t4YFz3bfUfctX9+11BY+6+5a6b6n7lq/u27pV91hSg5rUckW9JsaDB85131L3LV/dt/vaxgPnum+p+5av7tvrCh7BA+e6b/nqvt1X4DyCB8513/LVfXtdUa+J0XngXPctdd/y1X27r+08cK77lrpv+eq+3VfI80ge8lz3LV/dt9cVPJKHPNd9y1f37b5i1GtiDB7yXPctdd/y1X17Xctj8JDnum/56r7dV8jzmDzkue5bvrpvryt44Fz3LXXf8tV9u69Y9ZoYOA+c676l7lsGznXfMnCu+5a6bxk4133LwLnuW+q+ZeBc9y0D57pvqfuWr+7bfcWJ2hHOA+e6b6n7loFz3bcMnOu+pe5bdpzrvmXHue5b6r5lx7nuW3ac676l7lu+um/3Fe39Pio7zjvOdd9S9y07znXfsuNc9y1137LjXPctO85131L3LTvOdd+y41z3LXXf8tV9u6/oWTvCece57lvqvmXHue5bdpzrvqXuW3ac675lx7nuW+q+Zce57lt2nOu+pe5bvrpvryvqfVTHece57lvqvmXHue5bdpzrvqXuW3ac675lx7nuW+q+Zce57lt2nOu+pe5bvrpvryvqfVTHece57lvqvmXHue5bdpzrvqXuW3ac675lx7nuW+q+Zce57lt2nOu+pe5bvrpvrytqZug47zhPnCfOE+eJ88R54jxxnjhPnCfOE+eJ88R5mtsT54nzxPmr+/a6omaGxHniPHGeOE+cJ84T54nzxHniPHGeOE+cJ84T52luT5wnzhPnrxbc64qaGbTgUgsuteAycZ4414JLLbjUgsvEeeJcCy614FILLhPniXMtuNSCSy24TJzfLbjXFbNmBi241IJLLbhMnCfOteBSCy614DJxnjjXgkstuNSCy8R54lwLLrXgUgsuE+d3C+51xa6ZQQsuteBSCy4T54lzLbjUgkstuEycJ8614FILLrXgMnGeONeCSy241ILLgfO7BXdfcbfg7h1pwaUWXGrBpRZcjuq45t2Cm6/HTqn7fvtLNSqoTiU1qEktikfjETyCR/AIHsHj4nzuW01qUZs6pS7O36pRQXUqKR6dR+fReXQeySN5JI/kkTySR/JIHskjeQweg8fgMXgMHoPH4DF4XJyvx61OqYvzt2rU02PFrTqV1NNj3T91F+dv9fRY98/VxflbnVIX52vcqlFBdSqpy+P+2b04f6tVbhfn6/7ZuDh/qYvzt2rU5XHv/OL8rZIa1KQWtalT6uL8rRrF4/A4PA6Pw+PwODxO7eNuwb1Vo4LqVFKDmtSiNsWj8Wg8Go+L8/24VVKDenrs13/39DivxzZ1Sl2cv1WjgupUUoOaFI/gETw6j86j8+g8Oo/Oo/PoPDqPzuPi/IxbNSqoTiU1qEktalOn1OAxeAweg8fgMXgMHoPH4DF4TB6Tx+QxeUwek8fkMXlMHpPH4rF4LB6Lx+KxeCwei8fisXhsHpvH5rF5bB6bx+axeVycn/vn+eL8pS7O36pRQXUqqUFNalE8TnncLbi3alRQnUpqUJNa1KZ4NB6NR+PReDQejUfj0Xg0Ho3Hzfm51dPj+THCLeOS7Zb9knHLvGS/5fgi5xe5vsh9yXHLQ17Al2xf5O12P5t+u+1b3m73M7uof374cMt5y5+//ea///TT93/68w/f/dc3//bP5x//4x8//uXv3//1x/cf//6//1Z/8+efvv/hh+//849/++mvf/nu3//x03d//OGvf7n+7pvH+3/+13Nw/vYJ2x+eH50+//S8v/Pt8/7L80/t/stY3z7fZlx/bNcf+3z+cf/huXK7rr//m96+7fMPP//88x9+/j8=","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"// Simple Token Contract implementation in Noir\nuse noir_utils::HyliOutput32 as HyliOutput;\n\nfn main(\n    // The version of the HyleOutput. This is unchecked for now.\n    hyli_output: HyliOutput,\n    // ------ Private inputs ------\n    password: [u8; 32],\n) {\n    // Build padded \"identity:password\" buffer\n    let mut id: BoundedVec<u8, 256> = BoundedVec::from_parts(\n        hyli_output.identity.as_bytes(),\n        hyli_output.identity_len as u32,\n    );\n    id.extend_from_slice(\":\".as_bytes());\n    id.extend_from_slice(password);\n\n    // Hash the combined input using SHA-256\n    let input_hash = sha256::sha256_var(id.storage(), hyli_output.identity_len as u32 + 1 + 32);\n\n    assert(input_hash == hyli_output.blob);\n\n    assert(hyli_output.success == true);\n    assert(hyli_output.version == 1);\n    assert(hyli_output.initial_state_len == 4);\n    assert(hyli_output.next_state_len == 4);\n    assert(hyli_output.initial_state == [0; 4]);\n    assert(hyli_output.next_state == [0; 4]);\n    assert(hyli_output.blob_capacity == 32);\n    assert(hyli_output.blob_len == 32);\n    assert(hyli_output.blob_number == 1);\n    assert(hyli_output.tx_blob_count >= 1);\n}\n","path":"/Users/matteo/projects/hyli-noir/check-secret/src/main.nr"},"60":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK_SIZE, INT_SIZE, INT_SIZE_PTR,\n    MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\nmod oracle_tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    assert(message_size <= N);\n\n    let (h, msg_block) = process_full_blocks(msg, message_size, INITIAL_STATE);\n\n    finalize_sha256_blocks(message_size, h, msg_block)\n}\n\n/// Returns the first partially filled message block along with the internal state prior to its compression.\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> (STATE, MSG_BLOCK) {\n    if std::runtime::is_unconstrained() {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        // Intermediate hash, starting with the canonical initial value\n        let mut h: STATE = initial_state;\n        // Pointer into msg_block on a 64 byte scale\n        for i in 0..num_full_blocks {\n            let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n            h = sha256_compression(msg_block, h);\n        }\n\n        // We now build the final un-filled block.\n        let msg_byte_ptr = message_size % BLOCK_SIZE;\n        let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n            let num_full_blocks = message_size / BLOCK_SIZE;\n            let msg_start = BLOCK_SIZE * num_full_blocks;\n            build_msg_block(msg, message_size, msg_start)\n        } else {\n            // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n            // so we short-circuit in this case.\n            [0; 16]\n        };\n\n        (h, msg_block)\n    } else {\n        let num_blocks = N / BLOCK_SIZE;\n\n        // We store the intermediate hash states and message blocks in these two arrays which allows us to select the correct state\n        // for the given message size with a lookup.\n        //\n        // These can be reasoned about as followed:\n        // Consider a message with an unknown number of bytes, `msg_size. It can be seen that this will have `msg_size / BLOCK_SIZE` full blocks.\n        // - `states[i]` should then be the state after processing the first `i` blocks.\n        // - `blocks[i]` should then be the next message block after processing the first `i` blocks.\n        // blocks[first_partially_filled_block_index] is the last block that is partially filled or all 0 if the message is a multiple of the block size.\n        //\n        // In other words:\n        //\n        // blocks = [block 1, block 2, ..., block N / BLOCK_SIZE, block N / BLOCK_SIZE + 1]\n        // states = [INITIAL_STATE, state after block 1, state after block 2, ..., state after block N / BLOCK_SIZE]\n        //\n        // We place the initial state in `states[0]` as in the case where the `message_size < BLOCK_SIZE` then there are no full blocks to process and no compressions should occur.\n        let mut blocks: [MSG_BLOCK; N / BLOCK_SIZE + 1] = std::mem::zeroed();\n        let mut states: [STATE; N / BLOCK_SIZE + 1] = [initial_state; N / BLOCK_SIZE + 1];\n\n        // Optimization for small messages. If the largest possible message is smaller than a block then we know that the first block is partially filled\n        // no matter the value of `message_size`.\n        //\n        // Note that the condition `N >= BLOCK_SIZE` is known during monomorphization so this has no runtime cost.\n        let first_partially_filled_block_index = if N >= BLOCK_SIZE {\n            message_size / BLOCK_SIZE\n        } else {\n            0\n        };\n\n        for i in 0..num_blocks {\n            let msg_start = BLOCK_SIZE * i;\n            let new_msg_block = build_msg_block(msg, message_size, msg_start);\n\n            blocks[i] = new_msg_block;\n            states[i + 1] = sha256_compression(new_msg_block, states[i]);\n        }\n        // If message_size/BLOCK_SIZE == N/BLOCK_SIZE, and there is a remainder, we need to process the last block.\n        if N % BLOCK_SIZE != 0 {\n            let new_msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * num_blocks);\n\n            blocks[num_blocks] = new_msg_block;\n        }\n\n        (states[first_partially_filled_block_index], blocks[first_partially_filled_block_index])\n    }\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start` and pack them into a `MSG_BLOCK`.\npub(crate) unconstrained fn build_msg_block_helper<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> MSG_BLOCK {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = (msg_item << 8) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    msg_block\n}\n\n// Build a message block from the input message starting at `msg_start`.\n//\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn build_msg_block<let N: u32>(msg: [u8; N], message_size: u32, msg_start: u32) -> MSG_BLOCK {\n    let msg_block =\n        // Safety: We constrain the block below by reconstructing each `u32` word from the input bytes.\n        unsafe { build_msg_block_helper(msg, message_size, msg_start) };\n\n    if !is_unconstrained() {\n        let mut msg_end = msg_start + BLOCK_SIZE;\n\n        let max_read_index = std::cmp::min(message_size, msg_end);\n\n        // Reconstructed packed item\n        let mut msg_item: Field = 0;\n\n        // Inclusive at the end so that we can compare the last item.\n        for k in msg_start..=msg_end {\n            if (k != msg_start) & (k % INT_SIZE == 0) {\n                // If we consumed some input we can compare against the block.\n                let msg_block_index = (k - msg_start) / INT_SIZE - 1;\n                assert_eq(msg_block[msg_block_index] as Field, msg_item);\n\n                msg_item = 0;\n            }\n\n            // If we have input to consume, add it at the rightmost position.\n            let msg_byte = if k < max_read_index { msg[k] } else { 0 };\n            msg_item = msg_item * (TWO_POW_8 as Field) + msg_byte as Field;\n        }\n    }\n    msg_block\n}\n\n// Encode `8 * message_size` into two `u32` limbs.\nunconstrained fn encode_len(message_size: u32) -> (u32, u32) {\n    let len = 8 * message_size as u64;\n    let lo = len & 0xFFFFFFFF;\n    let hi = (len >> 32) & 0xFFFFFFFF;\n    (lo as u32, hi as u32)\n}\n\n// Write the length into the last 8 bytes of the block.\nfn attach_len_to_msg_block(mut msg_block: MSG_BLOCK, message_size: u32) -> MSG_BLOCK {\n    // Safety: We assert the correctness of the decomposition below.\n    // 2 `u32` limbs cannot overflow the field modulus so performing the check as `Field`s is safe.\n    let (lo, hi) = unsafe { encode_len(message_size) };\n    assert_eq(8 * (message_size as Field), lo as Field + hi as Field * TWO_POW_32);\n\n    msg_block[INT_SIZE_PTR] = hi;\n    msg_block[INT_SIZE_PTR + 1] = lo;\n    msg_block\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n/// Lookup table for the position of the padding bit within one of the `u32` words in the final message block.\nglobal PADDING_BIT_TABLE: [u32; 4] =\n    [(1 << 7) * TWO_POW_24, (1 << 7) * TWO_POW_16, (1 << 7) * TWO_POW_8, (1 << 7)];\n\n/// Add 1 bit padding to end of message and compress the block if there's not enough room for the 8-byte length.\n/// Returns the updated hash state and message block that will be used to write the message size.\n///\n/// # Assumptions:\n///\n/// - `msg_block[i] == 0` for all `i > msg_byte_ptr / INT_SIZE`\n/// - `msg_block[msg_byte_ptr / INT_SIZE] & ((1 << 7) * (msg_byte_ptr % INT_SIZE)) == 0`\nfn add_padding_byte_and_compress_if_needed(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    h: STATE,\n) -> (STATE, MSG_BLOCK) {\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n\n    // Lookup the position of the padding bit and insert it into the message block.\n    msg_block[index] += PADDING_BIT_TABLE[msg_byte_ptr % INT_SIZE];\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr >= MSG_SIZE_PTR {\n        let h = sha256_compression(msg_block, h);\n\n        // In this case, the final block consists of all zeros with the last 8 bytes containing the length.\n        // We set msg_block to all zeros and attach_len_to_msg_block will add the length to the last 8 bytes.\n        let msg_block = [0; INT_BLOCK_SIZE];\n        (h, msg_block)\n    } else {\n        (h, msg_block)\n    }\n}\n\npub(crate) fn finalize_sha256_blocks(\n    message_size: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (h, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (h, msg_block) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(real_message_size, h, msg_block)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let msg_block = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\n// Helper function to finalize the message block with padding and length\nunconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let msg_byte_ptr = message_size % BLOCK_SIZE;\n\n    // We now build the final un-filled block.\n    let msg_block: MSG_BLOCK = if msg_byte_ptr != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        build_msg_block(msg, message_size, msg_start)\n    } else {\n        // If the message size is a multiple of the block size (i.e. `msg_byte_ptr == 0`) then this block will be empty,\n        // so we short-circuit in this case.\n        [0; 16]\n    };\n\n    // Once built, we need to add the necessary padding bytes and encoded length\n    let (h, mut msg_block) = add_padding_byte_and_compress_if_needed(msg_block, msg_byte_ptr, h);\n    msg_block = attach_len_to_msg_block(msg_block, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\nmod test_process_full_blocks {\n\n    /// Wrapper to force an unconstrained runtime on process_full_blocks.\n    unconstrained fn unconstrained_process_full_blocks<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n        h: super::STATE,\n    ) -> (super::STATE, super::MSG_BLOCK) {\n        super::process_full_blocks(msg, message_size, h)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_state =\n            unsafe { unconstrained_process_full_blocks(msg, message_size, super::INITIAL_STATE) };\n        let state = super::process_full_blocks(msg, message_size, super::INITIAL_STATE);\n        assert_eq(state, unconstrained_state);\n    }\n}\n\nmod test_sha256_var {\n\n    /// Wrapper to force an unconstrained runtime on sha256.\n    unconstrained fn unconstrained_sha256<let N: u32>(\n        msg: [u8; N],\n        message_size: u32,\n    ) -> super::HASH {\n        super::sha256_var(msg, message_size)\n    }\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u32) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { unconstrained_sha256(msg, message_size) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/sha256/v0.3.0/src/sha256.nr"}},"expression_width":{"Bounded":{"width":4}}}