{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"7375693470095956142","abi":{"parameters":[{"name":"hyli","type":{"kind":"struct","path":"noir_utils::HyliOutput","fields":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"identity","type":{"kind":"string","length":256}},{"name":"tx_hash","type":{"kind":"string","length":64}},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"blob_contract_name","type":{"kind":"string","length":256}},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob","type":{"kind":"array","length":306,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"success","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3029459486139804503":{"error_kind":"string","string":"blob mail"},"3221523076127768791":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7662373878251359219":{"error_kind":"string","string":"blob not matching"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"11544899148041293964":{"error_kind":"string","string":"partial_data length is too long"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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p6t7PnJPN/d87J7u7unhnp7u+cQ9vdzzqXt6u6ePe/q65zP39HPP5+7p754B7hnoni/cM8g9X7pnsHuGuGeoe75yzzD3fO2e4e75xj0j3POte0a65zv3jHLP9+4Z7Z4f3DPGPT+6Z6x7fnLPOPf87J7x7vnFPRPc86t7JrrnN/dMcs/v7pnsnj/cM8U9f7pnqnumuWe6e2a4Z6Z7ZrlntnvmuGeue+a5Z757FrhnoXsWuWexe5a4Z6l7lrlnuXtWuGele1a5Z7V71rhnrXvWuWe9eza4Z6N7Nrlns3u2uGere7a5Z7t7drhnp3t2uWe3e/5yzx737HXPPvfsd88B9xx0zyH3HHbPEfccdc8x9/ztnuPu+cc9J9zzr3tOuueUe06754x7zrrnnHvOu+eCey6655J7Lrvninuuuueae6675z/33HDPTffccs9t99xxz1333HPPffc8cM9D9zxyz2P3PHHPU/c8c89z97xwz0v3vHLPa/e8cc9b97xzz3v3fHAP6ej+/e8Y+V8Di+6eGO6J6Z5Y7ontnjjuieueeO6J754E7knonkTuSeyeJO5J6p5k7knunhTuSemeVO5J7Z407knrnnTuSe+eDO7J6J5M7snsHuqeLO7J6p5s7snunhzuyemeXO7J7Z487snrnnzuye+eAu4p6J5C7insniLuKeqeYu4p7p4S7inpnlLuKe2eMu4p655y7invngruqeieSu6p7J4q7qnqnmruqe6eGu6p6Z5a7qntnjruqeueeu6p754G7mnonkbuaeyeJu5p6p5m7mnunhbuaemeVu4JdU+Ye8LdE+Ge1u5p45627mnnHsc97d3TwT0d3dPJPZ3d08U9Xd3zkXu6uedj93R3Tw/39HTPJ+7p5Z5P3dPbPX3c09c9n7mnn3s+d09/9wxwz0D3fOGeQe750j2D3TPEPUPd85V7hrnna/cMd8837hnhnm/dM9I937lnlHu+d89o9/zgnjHu+dE9Y93zk3vGuedn94x3zy/umeCeX90z0T2/uWeSe353z2T3/OGeKe750z1T3TPNPdPdM8M9M90zyz2z3TPHPXPdM889892zwD0L3bPIPYvds8Q9S92zzD3L3bPCPSvds8o9q92zxj1r3bPOPevds8E9G92zyT2b3bPFPVvds809292zwz073bPLPbvd85d79rhnr3v2uWe/ew64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5tr8v5lrCxw01xb83Vxb6JC59qw/zLVJh821Z/9pri18xFx7zl/m2iJHzbXn/m2uLXrMXHveP+baYsfNteefMNcWj37enkZ7gWeuLZHNXHthdnNtyRzm2lI5zbXJucy1F+U215bOY64tk9dcWzafufbi/ObacgXMteULmmtTCplrLznLXFshyVxb8WxzbaXC5tpLzzHXVi5irr3sXHNtlaLm2svPM9dWLWauveJ8c2214ubaKy8w11YvYa696kJzbY2S5tqrS5lrayaba6+5yFxbq7S59toy5traZc21111srg2XM9deX95cWyfFXHvDJebauhXMtfUqmmvrVzLXNrjUXNuwsrn2xsvMtY2qmGtvutxc27iqubbJFebaptXMtc2uNNc2r26uvfkqc22LGubaW64217asaa699Rpzbata5trW15pr29Q21952nbm2bdhce/v15tp2dcy1d9xgrm1f11x7Zz1zbaS+ufauBubaDg3NtR1vNNd2amSuvfsmc23nxubaLk3MtV2bmmu7NTPXdm9uru1xs7m2Zwtzba9bzLWpLc21vW811/ZpZa7t29pc26+Nufae28y1/duaa++93Vw7oJ259r47zLUD25tr77/TXDsoYq594C5z7eAO5toHO5prh3Qy1z50t7E2ffMyXpMzXhM9P+4A+/nuJqHQznahUHbJTueG25lpvdDOu8zj+akzNt/TXtK3ZEM/Ozsbaccxrcf3zQQuzNhJ3DZoLfclp///e0oo9Adrf7L2F2t/s/YPaydY85guO2s5L0n8+55g2idZe4q1p1l7hrVnWXuOtedZe4G1F1mbytrLrP2PtVdYe5W111h7nbU3WHuTtbdYe5u1BawtYu0d1t5l7b2UWL95M+J6n/3sA9Y+ZO0j1j5m7RPWPmXtM9Y+Z+0L1r5k7SvWvmbtG9a+Ze071r5n7QfWfmTtJ9Z2sfYza7+w9itr+1n7LeXMf1+zGn17IisvslpWy2r/j1pWzctqWS298S3bqXMCaUsO/bvzFp3c5vwI9bEL8JGDtdyh0+ePVH5Vv197ztcu/XwXjcv8XFe9JYcsNnRy+1iQuy1O5PcBJ/K7gBP53cCb6RdMuwlg+tknmH52DBPPtX0WMO2jgclT9pIzXnWTO8SC3GMB0yEApt0ATHsCANMeAph+8QmmXxzDxHPtkAVMh2hgyiZ6lYx1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","debug_symbols":"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t3j95ksDpT7/kgZWSbuBVZT952++LKyi7D9/82VhXm66d1WsL6yi7D9+8+XA8aePvmS9+v75l16ff6Eo++SbLztmmXQWAq9vvrRfv13+5stCirL/9M2XhRRl/+mbLwtTjSL2HSnK/tM3XxZSlP2nb74sTLW8zfXNl7y39c2XVXueZdJ5keubL3k565sveQ3rmy+rEj6LstPu+ubLQoqyP/vNF0rA1zdf8hc6++bLwix9XmXoFGX/5998yeqc9998WUhR9p+++bKQouw/ffNlYV5ZenJ98yXdl5N1//xLVgSvivSs580bWt98WXgUZX/6my8GHkXZZ998ObD/9tmPvlTp96pUz5LeT33zZSFF2T//5suqX088++bLwrSbpdo5JVed9J+++bKQouzPfPNlx8wBLZK6hPXNlyzV/tQ3XxZSlP2nb74sTLX8Vf7zb7681LFf+ubLgVWW/aGPvlTp96pUX1hF2T/75svCKsr+8DdfOmj1+Zcsk15YRdmn33xZSFH2n775sjCLsrM69+ybLwtTLetw1zdfsrD4+998WZhq1LF/8c2XhRRl/+mbLwspyv4LvvlCeTvffDlQ/pOPvlgRRdl/+ubLwjSaHl316ulRreLTv+KbLwtzfysvMrdr98+/VDnz1W++VMH5J775srCKsj/8zRcFR7l6ffNlYRVl/+ybLwurKPvP33xZmGpZBnv2zZeFWSbdfh2F7PvnXyjKvvjNl8T1zZcsDz775stCirLPvvlCefvrN19WRXqqrYr0BlKU/dlvvlACfvbNl4VZJp1OvfjNl4UUZZ9982UhRdl/+ubLwlTL3+LiN18WploVsh+ff0m1VQqfBaV5m3/65svCLChdtecPUP6zr74sqLLsD330pUq/P/XNl4VVlH3jmy+JZ998WVhF2SfffDlwL8z+6VdfHkfJ9/83vvmC2qqDylJtoWL67JsvCynK/ug3X4wS8LNvviysouwb33xZWEXZf/rmy45VlH36zZeFFGV/8c2XDhpIWXfG9f3zLxRl/+ibLwspyv7+N18WUpR99s2XhamWpdoXv/myMI1lUbZSn72K0xfmn2UltlGfvarMFwZYRdmv33xZBW6Jf3/zZVWn/v3Nlx3/Lm9f+Hd5+8K/y9sX/l3envh3efuOZ+Xt//Efv37753/9b//w7//0r//yX//93/7xH7ey7eM//Pff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2kBtoDZQG6gN1AZqA7WB2kAtUAvUArVALVAL1AK1QC1Qq30clckMmMyAyQyo3KvKRG2iNplvtSes9HtVqT1hpd+r0u9V6feq1L0qda9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elbpXpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0rdq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el7lXp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+rUveq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVal7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96rUvSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV6l6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9KnWvSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpW6V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9K3avS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpe5V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq1L3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Wpe1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq1L0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7VepelX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSp1r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vulel36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6v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GdU4I79E972O7nsd3fc6I79kVOOM/JKRX6L7Xkf3vc7ILxn5JSO/RPe9zqjGGdU4I79E972O7nsd3fc6I79kVOOM/JKRX6L7Xkf3vc7ILxn5JSO/RPe9zqjGGdU4I79E972O7nsd3fc6I79kVOOM/JKRX6L7Xkf3vc7ILxn5JSO/RPe9zqjGGdU4I79E972O7nsd3fc6I79kVOOM/JKRX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSu/RPe9zqrGWdU4K79E972O7nsd3fc6K79kVeOs/JKVX6L7Xkf3vc7KL1n5JSe/RPe9zqnGOdU4J79E972O7nsd3fc6J7/kVOOc/JKTX6L7Xkf3vc7JLzn5JSe/RPe9zqnGOdU4J79E972O7nsd3fc6J7/kVOOc/JKTX6L7Xkf3vc7JLzn5JSe/RPe9zqnGOdU4J79E972O7nsd3fc6J7/kVOOc/JKTX6L7Xkf3vc7JLzn5JSe/RPe9zqnGOdU4J79E972O7nsd3fc6J7/kVOOc/JKTX3LyS3Tf65z8kpNfcvJLdN/rnGqcU41z8kt03+vovtfRfa9z8ktONc7JLzn5JbrvdXTf65z8kpNfcvJLdN/rqO911Pc66nsd9b2O+l5Hfa9z8ktONc7JLzn5JbrvdXTf65z8kpNfcvJLdN/rqO911Pe66ntd9b2u+l5Xfa/7ef2S/bw1zn5ev2Q/r1+yuu91dd/rfl6/ZD+vX7Kf1y9Z3fe66ntd9b2u+l5Xfa+rvtdV3+t+Xr9kP2+Ns5/XL9nP65es7ntd3fe6uu91dd/r/vpe/bu8d/nUOM/StHQtQ8u/SYv9vPM4+3nncfbzzuPs553H2c87j7Ofdx5nP+88zn7eeZz9vPM4+0lFS0VLRUtFS0VLRStFK0UrRStFK0UrRStFK0UrRStFa0VrRWtFa0VrRWtFa0VrRWtFa0UbRRtFG0UbRRtFG0UbRRtFG0UbRVtFW0VbRVtFW0VbRVtFW0VbRVtFO0U7RTtFO0U7RTtFO0U7RTtFe2f71t7ZvrV3tm/tne1be2f71t7ZvrV3tm/tne1be2f71t7ZvrWPopmimaKZopmimaKZopmimaKZopmiuaK5ormiuaK5ormiuaK5ormiuaKFooWihaKFooklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpaYWGJiiYklJpa4WOJiiYslLpa4WOJiiYslLpa4WOJiydP3+m8AcZ++19/StQwtU8vSsrUcLVfLe5euaO9s3/o727f+zvatv7N96+9s3/o727f+zvatv7N96+9s3/o727ceihaKFooWihaKFooWihaKFoqWipaKloqWipaKloqWipaKloqWilaKVopWilaKVopWilaKVopWilaK1orWitaK1orWitaK1orWitaK1oo2ijaKNoo2ijaKNoo2ijaKNoo2iraKtoq2iraKtoq2iraK9niv+V2ulvcunxrnWX6jzXfpWoaWfzXO+lvjrL81zvpb46z6Xld9rxuqcUI1TqjGCdU48folq/teV/e9ru57Xd33urrvddX3uup7XfW9rvpeV32vq77XDdU4oRonVOOEapxwRXNFc0VzRXNFc0VzRXNFc0VzRQtFC0ULRQtFC0ULRQtFC0ULRQtFS0VLRUtFS0VLRUtFS0VLRUtFS0UrRStFK0UrRStFK0UrRStFK0UrRWtFa0VrRWtFe89xVve9ru57Xd33urrvdXXf6+q+1433jsaN90x44/VLNt4z4Y1RtFG0UbTRs42iraKtnm31bKtnW2XyYclX2XsmvPGeCW+8Z8Ibr1+y8folG++Z8MZ7JrzxnglviCXqe904fW6nz00sCbEkxZJf3+t8l28m8z0T3nzPhDfll6T8knzPhDffM+HN90x4U36J+l43xZIUS1IsSbEkxZJf3+tX73smvPmeCW++Z8Kb8ktSfkm+Z8Kb75nw5nsmvPn2l6z6XjfFkhRLUixJsSTFkl/f61dvKJOhTIYy+Z4Jb4aeLZTJVCbfM+HNt79k1fe6KZakWJJiSYolKZb8+l6/ekuZLGWylMnSW1J6tlImS5ksvSWlt0QsSbEkxZIUS1Isydaz9fv7lq1MtjLZymTrLRk92yiTo0yO3hKxRH2vm6NMjjIplqRYkmLJr+/1q3eVyVUmV5lcvSViSa4yucrk6i05vSWnTJ4yecrkKZNiSYolv77Xr95TJt8z4a33THjrPRPeEkvqPRPees+Et94z4a23v2TV97ql7yWl7yWl7yUllpRY8ut7ne/yzWS9Z8Jb75nw1nsmvCWW1HsmvPWeCW+9Z8Jbb3/Jqu91S99LSt9LSt9LSiwpseTX9/rVG8pkKJOhTL5nwltiSYUyGcrkeya89faXrPpet/S9pPS9pPS9pMSSEkt+fa9fvalMpjKZymTqLRFLqpTJUiZLb0npLdH3ktL3ktL3ktL3khJLSiz59b1+9bYy2cpkK5Ott0QsKX0vKX0vqdZbMnpLRpkcZXKUyVEmxZISS359r1+9o0yOMrnK5OotEUtqlclVJldvyeotWWVylclVJk+ZFEtKLCnVOHXK5CmTp0ye3hKxpN4z4e33THj7PRPefvtLVn2v26pxWjVOq8ZpsaTFkl/f6z+9/Z4Jb79nwtvvmfD2eya8LZb0eya8/Z4Jb79nwttvf8mq73VbNU6rxmnVOC2WtFjy63v96tU5Tuscp98z4e33THhbLOlQJkOZfM+Et9/+klXf67ZqnFaN06pxWixpseTX9/rVm8pkKpOpTL5nwttiSacymcpk6i0pvSWqcVo1TqvGadU4LZa0WPLre/3qLWWylMlWJltviVjSrUy2Mqkap1XjqO91u5VJ1TitGqfFkhZLfn2vX72jTI4yOcrk6C0RS3qUyVUmV2/J6i1RjdOqcXqVyVUmxZIWS359r1+9qnH6lMlTJk9viVjS8ktafknLL+nTW6IaZ1TjjPySkV8yYsmIJb++1/ku30yOzoRHZ8KjM+ERS0ZnwqMz4dGZ8Lz9Jau+1x3VOCO/ZOSXjFgyYsmv7/WrVzXO6Ex4dCY8OhMesWTeHvqdt4d+5+2h33n7S1Z9rzuqcUZ+ycgvGbFkxJJf3+tXr2qcCWUylcm3v2RHLJlUJlOZfHvod97+klXf645qnJFfMvJLRiwZseTX9/rVqxpnSpksZbL0loglU8pkK5Ott6T1lqjGGdU408pkK5NiyYglv77Xr17VODPKpPySkV8yYsnILxn5JSO/ZEZviWqcUY0z8ktGfsmIJSOWjPySUY0z8ktGfsnILxmxZOSXjPySkV8y8kvU97qjGmfkl4z8khFLVixZ+SWrGmfll6z8kpVfsmLJyi9Z+SUrv2Tll6jvdVc1zsovWfklK5asWLLyS1Y1zsovWfklK79kxZKVX7LyS1Z+ycovUd/rrmqclV+y8ktWLFmxZOWXrGqclV+y8ktWfsmKJSu/ZOWXrPySlV+ivtdd1Tgrv2Tll6xYsmLJyi9Z1Tgrv2Tll6z8khVLVn7Jyi9Z+SUrv0R9r7uqcVZ+ycovWbFkxZKVX7KqcVZ+ycovWfklK5as/JKVX7LyS1Z+ifped1XjrPySlV+yYsmKJSu/ZFXjrPySlV+y8ktWLFn5JSu/ZOWXrPwS9b3uqsZZ+SUrv2TFkhVLVn7JqsZZ+SUnv+Tkl5xYcvJLTn7JyS85+SXqe91TjXPyS05+yYklJ5ac/JJTjXPyS05+yckvObHk5Jec/JKTX3LyS9T3uqca5+SXnPySE0tOLDn5Jaca5+SXnPySk19yYsnJLzn5JSe/5OSXqO91TzXOyS85+SUnlpxYcvJLTjXOyS85+SUnv+TEkpNfcvJLTn7JyS9R3+ueapyTX3LyS04sObHk5JecapyTX3LyS05+yYklJ7/k5JfovtfVfa+rvtc91Ti673V13+vqvtfVfa978ktONc7JLzn5JSe/5MSSk19y8ktOfsnJL1Hf6+q+19V9r6v7Xlf3va7ue92TX3KqcU5+yckvOfklJ5bc65fc5/VL7vP6Jfd5/ZJT3+vpvtfTfa+n+15P972e7nu9z+uX3Oetce7z+iX3ef2S+7x+yX1eltzn9Uvu8/ol93n9kvu8fsmp7/V03+vpvtfTfa+n+15P973e5/VLTn2vp77X+7x+yX1ev+Q+oWcLZTKUydcvuc/rl5zuez3d93q67/V03+t9Qs+WerbXL7lPKpOpTKYy+fol90k9WyqTqUym3pLSW1LKZCmTpUyWMll6ttKzvX7JfUqZLGWylcnWW9J6tlYmW5lsvSWtt6SVyVYmW5kcZXL0bKNne/2S+4wyOcrkKJOjt2T0bKNMrjK5ektWb8kqk6tMrjK5yuTq2VbPtvp9O2XylMlT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RCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCMTjUw0MtHIRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJRCcTnUx0MtHJxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCATg0wMMjHIxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCQTk0xMMjHJxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCITi0wsMrHIxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCYTm0xsMrHJxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCETh0wcMnHIxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCUTl0xcMnHJxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MvHIxCMTj0w8MpFzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjuX/DRWQiZxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGP593+4oQIykXMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbj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kjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErH8n+DCexEHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1LHTtRx/J/gwnsRB1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR3L/w0msBN1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSx97EQdy/8NJrATdSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY/m/wQR2oo7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuXqWK6O5epYro7l6liujuX/PikzgZ147EQdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcvVsVwdy9WxXB3L1bFcHcv9cyz5DePwJehveAy/nfg7HIcvwf2GdCiHdrgO47AOj+G3E3+H42CCZ4JngmeCZ4JngmeCR4I/x/I7HIdwSIdyaIfrMA7rYIJjgmOCY4JjgmOCY4JjgmOCY4JjgjBBmCBMECYIE4QJwgRhgjBBmCBNkCZIE6QJ0gRpgjRBmiBNkCYoE5QJygRlgjJBmaBMUCYoE5QJ2gRtgjZBm6BN0CZoE7QJ2gRtgmuCa4JrgmuCa4JrgmuCa4JrgmuCMcGYYEwwJhgTjAnGBGOCMcGYYE2wJrATw04MOzHsxLATw04MOzHsxLATw04MOzHsxLATw04MOzHsxLATw05MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT004sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy05sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT2068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZiY9OnB86cX7oxPmhE+eHTpwfOnF+6MT5oRPnh06cHzpxfn5McExwTHBMcExwTHBMcExwTHBMcEwQJggThAnCBGGCMEGYIEwQJggTpAnSBGmCNEGaIE2QJkgTpAnSBGWCMkGZoExQJigTlAnKBGWCMkGboE3QJmgTtAnaBG2CNkGboE1wTXBNcE1wTXBNcE1wTXBNcE1wTTAmGBOMCcYEY4IxwZhgTDAmGBOsCdYEa4I1wZpgTbAmWBOsCdYEzwTPBM8EzwTPBM8EzwTPBM8EduKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnahjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhG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YEwwJhgTjAnGBGOCMcGYYEywJlgTrAnWBGuCNcGaYE2wJlgTPBM8EzwTPBM8EzwTPBM8EzwTPBL8OpbvT34dy9+fhH+S/kn5J+2fXP9k/JP1T0xwTHBMcExwTHBMcExwTHBMcExwTBAmCBOECcIEYYIwQZggTBAmCBOkCdIEaYI0QZogTZAmSBOkCdIEZYIyQZnATlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5346MT3Qye+Hzrx/dCJ74dOfD904vuhE98Pnfh+6MT3Qye+nx8THBMcExwTHBMcExwTHBMcExwTHBOECcIEYYIwQZggTBAmCBOECcIEaYI0QZogTZAmSBOkCdIEaYI0QZmgTFAmKBOUCcoEZYIyQZmgTNAmaBO0CdoEbYI2QZugTdAmaBNcE1wTXBNcE1wTXBNcE1wTXBNcE4wJxgRjgjHBmGBMMCYYE4wJxgRrgjXBmmBNsCZYE6wJ1gRrgjXBM8EzwTPBM8EzwTPBM8EzwTOBnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlhJ4adGHZi2IlpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2olpJ6admHZi2ollJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YllJ5adWHZi2YltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24ltJ7ad2HZi24nXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr504duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMnjp04duLYiWMn6liejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l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sROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJX47l/eAW7MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbil2N5/b1w7MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHRiHnRiHnRiHnRiHnRiHnRiHnRiHnRiHnRiHnRiHg8noBPzoBPzuJzgcgI6MQ86MY/LCS4noBPzoBPzGE4wnIBOzINOzGM4wXACOjEPOjGP4QTDCaZbmG5hOsF0gukWpluYTjCdYLqF6RaWEywnWG5huYXlBMsJlltYbmE5wXKC7Ra2W9hOsJ1gu4XtFrYTbCfYbmG7hdsJbie43cLtFm4nuJ3gdgu3W7id4HaCuIW4hThBnCBuIW4hThAniFuIW6gT1AnqFuoW6gR1grqFuoU6QZ3guIXjFo4THCc4buG4heMExwmOW6ATc9GJuejEXHRiLjoxF52YL8fy7e+FXHRiLjoxF52Y6+EEdGIuOjHX5QSXE9CJuejEXJcTXE5AJ+aiE3MNJxhOQCfmohNzDScYTkAn5qITcw0nGE4w3cJ0C9MJphNMt0An5ppOMJ1guoXpFpYTLCdYbmG5heUEywmWW1huYTnBcoLtFrZb2E6wnWC7he0WthNsJ9huYbuF2wluJ7jdwu0Wbie4neB2C7dbuJ3gdoK4hbiFOEGcIG4hbiFOECeIW4hbqBPUCeoW6hbqBHWCuoW6hTpBneC4heMWjhMcJzhu4biF4wTHCY5bsBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnfjlWF5/Lww7cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJ006cduK0E6edOO3Eyc8TM+3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTJ587Z9qJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuf5647MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishMXnztn2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy07cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ25/nrjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2EzefO2fbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cTbTrztxNtOvO3E20687cTbTrztxNtOvO3E20687cTbTrztxNtOvO3E20687cTbTrztxNtOvO3E20687cTbTrztRB1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzRsUTHEh1LdCzR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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use jwt::JWT;\nuse noir_utils::HyliOutput;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::hash::Hasher;\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_EMAIL_LENGTH: u32 = 77;\nglobal NONCE_LENGTH: u32 = 16;\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate hd and nonce fields\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param b64_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of hd and nonce will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param ephemeral_pubkey: Public key of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_salt: Salt of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_expiry: Expiry of the ephemeral keypair that is used to sign messages\n * @param nonce: JWT `nonce` as a byte array of ascii characters - 32 bytes\n **/\nfn main(\n    // Hyli output infos\n    hyli: HyliOutput<306>,\n    // whats needed to build something that matches what is in blob field\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n) {\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // Get nonce claim\n    let nonce: BoundedVec<u8, NONCE_LENGTH> = jwt.get_claim_string(\"nonce\".as_bytes());\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    let email_field: Field = bytes_to_field(email.storage(), email.len());\n\n    let mut hasher = Poseidon2Hasher::default();\n    hasher.write(email_field);\n    let email_hash: Field = hasher.finish();\n\n    // email_hash:nonce:pubkey\n    let mut built_blob: BoundedVec<u8, 306> = BoundedVec::new();\n    built_blob.extend_from_array(email_hash.to_be_bytes::<32>());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(nonce.storage());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(joinLimbsToBigInt(jwt_pubkey_modulus_limbs).storage());\n\n    assert(email_hash == bytes_to_field(built_blob.storage(), 32), \"blob mail\");\n\n    assert(hyli.blob == built_blob.storage(), \"blob not matching\");\n\n    // Hyli specific asserts\n\n    assert(hyli.success == true);\n    assert(hyli.version == 1);\n    assert(hyli.initial_state_len == 4);\n    assert(hyli.next_state_len == 4);\n    assert(hyli.initial_state == [0; 4]);\n    assert(hyli.next_state == [0; 4]);\n    assert(hyli.blob_capacity == 306);\n    assert(hyli.blob_len == 306);\n    assert(hyli.blob_number == 1);\n    assert(hyli.tx_blob_count >= 1);\n}\n\nfn bytes_to_field<let LEN: u32>(bytes: [u8; LEN], len: u32) -> Field {\n    let mut result: Field = 0;\n    for i in 0..LEN {\n        // Big-endian: on \"pousse\" de 8 bits (= *256) puis on ajoute l'octet courant\n\n        if i < len {\n            result = result * 256 + (bytes[i] as Field);\n        }\n    }\n    result\n}\n\nfn u128_to_bytes(x: u128) -> [u8; 16] {\n    let mut out: [u8; 16] = [0; 16];\n\n    for i in 0..16 {\n        let shifted: u128 = x >> (i * 8);\n        // On garde uniquement les 8 bits de poids faible\n        out[i as u32] = (shifted & 0xff) as u8;\n    }\n\n    out\n}\n\n// last byte of each limb should be 0, that is why we skip it\nfn joinLimbsToBigInt(limbs: [u128; 18]) -> BoundedVec<u8, 256> {\n    let mut result = BoundedVec::new();\n    for i in 0..17 {\n        let sub: [u8] = u128_to_bytes(limbs[i]).as_slice();\n        let (sub, zero) = sub.pop_back();\n        let sub: [u8; 15] = sub.as_array();\n\n        assert(zero == 0);\n        result.extend_from_array(sub);\n    }\n\n    result.extend_from_slice([u128_to_bytes(limbs[17])[0]]);\n    result\n}\n\n#[test]\nfn encode_decode() {\n    let truc = 1234567890;\n    let result = bytes_to_field(u128_to_bytes(truc), 16) as u128;\n    println(truc);\n    println(result);\n\n    assert_eq(truc, result, \"dommach\");\n}\n","path":"/Users/matteo/projects/hyli-noir/check-jwt/src/main.nr"},"51":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/matteo/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"52":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/matteo/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/partial_hash.nr"},"54":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"55":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"94":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"95":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"97":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"98":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"99":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"101":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"102":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"109":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"141":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/matteo/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"157":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"158":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"},"167":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/poseidon/v0.2.0/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}