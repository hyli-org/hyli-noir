{"noir_version":"1.0.0-beta.14+60ccd48e18ad8ce50d5ecda9baf813b712145051","hash":"17005065457623710048","abi":{"parameters":[{"name":"hyli","type":{"kind":"struct","path":"noir_utils::HyliOutput512","fields":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"identity","type":{"kind":"string","length":256}},{"name":"tx_hash","type":{"kind":"string","length":64}},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8}},{"name":"blob_contract_name","type":{"kind":"string","length":256}},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"blob","type":{"kind":"array","length":512,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"success","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"819864067177566446":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3029459486139804503":{"error_kind":"string","string":"blob mail"},"3221523076127768791":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"5624732299715428208":{"error_kind":"string","string":"incorrect value for claim"},"5814456561209054291":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"5899151545213940874":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"7287311796025951795":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"7662373878251359219":{"error_kind":"string","string":"blob not matching"},"7688826323084302732":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"9752593157046867219":{"error_kind":"string","string":"haystack length of size 0 not supported"},"11019205087382408538":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"11544899148041293964":{"error_kind":"string","string":"partial_data length is too long"},"12087256528359734805":{"error_kind":"string","string":"needle length of size 0 not supported"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"15835548349546956319":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"17568106868988118403":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"18287357528562917927":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"}}},"bytecode":"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bw6/PEPQpNQogezyXVd40FaK0FZIoK1EhrZCAdpKOLQQQ9Bkf5wWtFUetNUitFUSaKuRoa1SgLYaDi2KIWhRZQNKILt81zUetLUitDUSaGuRoa1RgLYWDi2qIWjRZANKILt813UetPUitHUSaOuRoa1TgLYeDi2aIWjRZQNKILt81w0etI0itA0SaBuRoW1QgLYRDi26IWgxZANKILt8100etM0itE0SaJuRoW1SgLYZDi2GIWgxZQNKILt81y0etK0itC0SaFuRoW1RgLYVDi2mIWixZANKILt8120etO0itG0SaNuRoW1TgLYdDi2WIWixZQNKILt81x0etJ0itB0SaDuRoe1QgLYTDi22IWhxZANKILt8110etN0itF0SaLuRoe1SgLYbDi2OIWhxZQNKILt81z0etL0itD0SaHuRoe1RgLYXDi2uIWjxZANKILt8130etP0itH0SaPuRoe1TgLYfDi2eIWjxZQNKILt81wMetIMitAMSaAeRoR1QgHYQDi2+IWgJZANKILt810MetMMitEMSaIeRoR1SgHYYDi2BIWgJZQNKILt81yMetKMitCMSaEeRoR1RgHYUDi2hIWiJZANKILt812MetOMitGMSaMeRoR1TgHYcDi2RIWiJZQNKILt81xMetJMitBMSaCeRoZ1QgHYSDi2xIWhJZANKILt811MetNMitFMSaKeRoZ1SgHYaDi2JIWhJZQNKILt81zMetLMitDMSaGeRoZ1RgHYWDi2pIWjJZANKILt813MetPMitHMSaOeRoZ1TgHYeDi2ZIWjJZQNKILt81wsetIsitAsSaBeRoV1QgHYRDi25IWgpZANKILt810setMsitEsSaJeRoV1SgHYZDi2FIWgpZQNKILt81ysetKsitCsSaFeRoV1RgHYVDi2lIWipZANKILt812setOsitGsSaNeRoV1TgHYdDi2VIWipZQNKILt81xsetJsitBsSaDeRod1QgHYTDi21IWhpZANKILt811setNsitFsSaLeRod1SgHYbDi2NIWhpZQNKILt81zsetLsitDsSaHeRod1RgHYXDi2tIWjpZANKILt813setPsitHsSaPeRod1TgHYfDi2dIWjpZQNKILt81wcetIcitAcSaA+RoT1QgPYQDi29IWgZZANKILt810cetMcitEcSaI+RoT1SgPYYDi2D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IWjRZQNKILt81w0etI0itA0SaBuRoW1QgLYRDi26IWgxZANKILt8100etM0itE0SaJuRoW1SgLYZDi2GIWgxZQNKILt81y0etK0itC0SaFuRoW1RgLYVDi2mIWixZANKILt8120etO0itG0SaNuRoW1TgLYdDi2WIWixZQNKILt81x0etJ0itB0SaDuRoe1QgLYTDi22IWhxZANKILt8110etN0itF0SaLuRoe1SgLYbDi2OIWhxZQNKILt81z0etL0itD0SaHuRoe1RgLYXDi2uIWjxZANKILt8130etP0itH0SaPuRoe1TgLYfDi2eIWjxZQNKILt81wMetIMitAMSaAeRoR1QgHYQDi2+IWgJZANKILt810MetMMitEMSaIeRoR1SgHYYDi2BIWgJZQNKILt81yMetKMitCMSaEeRoR1RgHYUDi2hIWiJZANKILt812MetOMitGMSaMeRoR1TgHYcDi2RIWiJZQNKILt81xMetJMitBMSaCeRoZ1QgHYSDi2xIWhJZANKILt811MetNMitFMSaKeRoZ1SgHYaDi2JIWhJZQNKILt81zMetLMitDMSaGeRoZ1RgHYWDi2pIWjJZANKILt813MetPMitHMSaOeRoZ1TgHYeDi2ZIWjJZQNKILt81wsetIsitAsSaBeRoV1QgHYRDi25IWgpZANKILt810setMsitEsSaJeRoV1SgHYZDi2FIWgpZQNKILt81ysetKsitCsSaFeRoV1RgHYVDi2lIWipZANKILt812setOsitGsSaNeRoV1TgHYdDi2VIWipZQNKILt81xsetJsitBsSaDeRod1QgHYTDi21IWhpZANKILt811setNsitFsSaLeRod1SgHYbDi2NIWhpZQNKILt81zsetLsitDsSaHeRod1RgHYXDi2tIWjpZANKILt813setPsitHsSaPeRod1TgHYfDi2dIWjpZQNKILt81wcetIcitAcSaA+RoT1QgPYQDi29IWgZZANKILt810cetMcitEcSaI+RoT1SgPYYDi2DIWgZZQNKILt81ycetKcitCcSaE+RoT1RgPYUDi2jIWjSGCWQXb7rMw/acxHaMwm058jQnilAew6HRg1ByyQbUALZ5bu+8KC9FKG9kEB7iQzthQK0l3BomQxByywbUALZ5bu+8qC9FqG9kkB7jQztlQK013BomQ1B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nlvuue2eO+6565577rnvngfueeieR+557J4n7nnqnmfuee6eF+556Z5X7nntnjfueeued+55754P7vnoHtLa/fvfOuL/Miqqe6K5J7p7YrgnpntiuSe2e+K4J6574rknvnsSuCehexK5J7F7krgnqXuSuSe5e1K4J6V7UrkntXvSuCete9K5J717Mrgno3uoezK5J7N7srgnq3uyuSe7e3K4J6d7crknt3vyuCeve/K5J797CrRm//+Y+/ffPYXdU8Q9Rd1TzD3F3VPCPZ+4p6R7SrmntHvKuKesez51Tzn3lHdPBfdUdE8l93zmnsruqeKequ6p5p7q7vncPTXcU9M9tdxT2z113POFe+q6p5576rungXsauudL9zRyT2P3hLqniXvC3BPunqbuaeae5u5x3NPCPS3d08o9rd3Txj1fuaete752Tzv3tHdPB/d8456O7vnWPZ3c09k9XdzznXu6uud793RzT3f39HDPD+7p6Z4f3dPLPb3d08c9P7mnr3t+dk8/9/zinv7u+dU9A9zzm3sGuud39wxyzx/uGeyeP90zxD1/uWeoe/52zzD3/OOe4e751z0j3DPSPaPcM9o9Y9wz1j3j3DPePRPcM9E9k9wz2T1T3DPVPdPcM909M9wz0z2z3DPbPXPcM9c989wz3z0L3LPQPYvcs9g9S9yz1D3L3POfe5a7Z4V7VrpnlXtWu2eNe9a6Z5171rtng3s2umeTeza7Z4t7trpnm3u2u2eHe3a6Z5d7drtnj3v2umefe/a754B7DrrnkHsOu+eIe46655h7jrvnhHtOuueUe06754x7zrrnnHvOu+eCey6655J7Lrvninuuuueae66754Z7brrnlntuu+eOe+6655577rvngXseuueRex6754l7nrrnmXueu+eFe16655V7XrvnjXveuuede96754N7PrqHtHH//reJ+D+yi+qeaO6J7p4Y7onpnljuie2eOO6J65547onvngTuSeieRO5J7J4k7knqnmTuSe6eFO5J6Z5U7kntnjTuSeuedO5J754M7snoHuqeTO7J7J4s7snqnmzuye6eHO7J6Z5c7sntnjzuyeuefO7J754C7inonkLuKeyeIm00/4dO9j80/tdS/X/D+K8l/H9Y1e213MJeyzV7LUfotcLCXis0e61A6LXSwl4rNXutROi1ysJeqzR7rULo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2B4e3nY5sZ0Q3nZ5sT0ivO0KYjsxvO2KYntkeNuVxPao8LYri+3R4W0b7lOOCW+7qthOCm+7mthODm/b8I7OY8Pbdhbb48LbriG2x4e3XVNsTwhvu5bYnhjedm2xnRLedh2xPSm87bpie3J42/VkHGcq/KjHT06B30OMZcWCjMOiflr5Ei68Ja+COcUID+Onx2GnGb5UGue2B7/0uYTxW9xpOS2n5bScltNyWk7LaTktp+W0nFaTczsspX5FqbVjhFo7Rai1c4Rau0SotWuEWj0j1NotQq3dI9TaI0KtXhFqubrQaelzvSPU6hOh1p4RavWNUGuvCLX2jlBrnwi19o1Qq1+EWvtFqNU/Qq39I9QaEKHWARFqDYxQa1CEWoMj1DowQq0hEWodFKHW0Ai1Do5Q65AItYZFqDU8Qq0REWq5fk44rZFLqV+jItQ6NEKt0RFqjYlQa2yEWuMi1BofodZhEWodHqHWhAi1johQa2KEWkdGqHVUhFpHR6h1TIRakyLUmhyh1rERah0XodbxEWqdEKHWiRFqTYlQ66QItU6OUMv1v5yW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTmtcFpRPrPo0t5pOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltGwttze803JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScVjitVPbzFNDOaNV7gY6OKaUd0j4m9tPB3gtu3+D/qfmF32A/A+xDhN/g/0ywjwW37yz2s/KzP0rsZ4N98PjHFon9aXnZxyeV/P1/8d//UuX//SWV1SgGvRDx8cqyfAq99Bprp/PzdXJM6XneknKD50Q/rXwJm7djSk/C0/GTcirxK8krvPikmLLH8FBT/JG0LjXOiVZZ9u8ioiW2ScWvlRWqNMLQ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","debug_symbols":"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o+aoOWqO2kBtoDZQG6gN1AZqA7WB2kBtoBaoBWqBWqAWqAVqgVqgFqjVPo7KZAZMZsBkBlTuVWWiNlGbzLfaE1b6varUnrDS71Xp96r0e1XqXpW6V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9K3avS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpe5V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq1L3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Wpe1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq1L0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7VepelX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSp1r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vulel36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSt2r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6XuVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36tS96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9VqXtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qtS9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1XqXpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0qda9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0q/V6Xfq9LvVen3qvR7Vfq9Kv1elbpXpd+r0u9V6feq9HtV+r0q/V6Vfq9Kv1el36vS71Xp96r0e1X6vSr9XpV+r0rdq9LvVen3qvR7Vfq9Kv1elX6vSr9Xpd+r0u9V6feq9HtV+r0q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0UrRStFK0UrRStFK0UrRWtFa0VrRWtFa0VrRWtFa0VrRWtFG0UbRRtFG0UbRRtFG0UbRRtFG0VbRVtFW0VbRVtFW0VbRVtFW0VbRTtFO0U7RTtFO0U7RTtFO0U7R3tm+tXe2b+2d7Vt7Z/vW3tm+tXe2b+2d7Vt7Z/vW3tm+tXe2b+2jaKZopmimaKZopmimaKZopmimaKZormiuaK5ormiuaK5ormiuaK5ormihaKFooWihaGKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUulrhY4mKJiyUulrhY4mKJiyUulrhY8vS9/htA3Kfv9bd0LUPL1LK0bC1Hy9Xy3qUr2jvbt/7O9q2/s33r72zf+jvbt/7O9q2/s33r72zf+jvbt/7O9q2HooWihaKFooWihaKFooWihaKloqWipaKloqWipaKloqWipaKlopWilaKVopWilaKVopWilaKVopWitaK1orWitaK1orWitaK1orWitaKNoo2ijaKNoo2ijaKNoo2ijaKNoq2iraKtoq2iraKtoq2iPd5rfper5b3Lp8Z5lt9o8126lqHlX42z/tY462+Ns/7WOKu+11Xf64ZqnFCNE6pxQjVOvH7J6r7X1X2vq/teV/e9ru57XfW9rvpeV32vq77XVd/rqu91QzVOqMYJ1TihGidc0VzRXNFc0VzRXNFc0VzRXNFc0ULRQtFC0ULRQtFC0ULRQtFC0ULRUtFS0VLRUtFS0VLRUtFS0VLRUtFK0UrRStFK0UrRStFK0UrRStFK0VrRWtFa0VrR3nOc1X2vq/teV/e9ru57Xd33urrvdeO9o3HjPRPeeP2SjfdMeGMUbRRtFG30bKNoq2irZ1s92+rZVpl8WPJV9p4Jb7xnwhvvmfDG65dsvH7JxnsmvPGeCW+8Z8IbYon6XjdOn9vpcxNLQixJseTX9zrf5ZvJfM+EN98z4U35JSm/JN8z4c33THjzPRPelF+ivtdNsSTFkhRLUixJseTX9/rV+54Jb75nwpvvmfCm/JKUX5LvmfDmeya8+Z4Jb779Jau+102xJMWSFEtSLEmx5Nf3+tUbymQok6FMvmfCm6FnC2Uylcn3THjz7S9Z9b1uiiUplqRYkmJJiiW/vtev3lImS5ksZbL0lpSerZTJUiZLb0npLRFLUixJsSTFkhRLsvVs/f6+ZSuTrUy2Mtl6S0bPNsrkKJOjt0QsUd/r5iiTo0yKJSmWpFjy63v96l1lcpXJVSZXb4lYkqtMrjK5ektOb8kpk6dMnjJ5yqRYkmLJr+/1q/eUyfdMeOs9E956z4S3xJJ6z4S33jPhrfdMeOvtL1n1vW7pe0npe0npe0mJJSWW/Ppe57t8M1nvmfDWeya89Z4Jb4kl9Z4Jb71nwlvvmfDW21+y6nvd0veS0veS0veSEktKLPn1vX71hjIZymQok++Z8JZYUqFMhjL5nglvvf0lq77XLX0vKX0vKX0vKbGkxJJf3+tXbyqTqUymMpl6S8SSKmWylMnSW1J6S/S9pPS9pPS9pPS9pMSSEkt+fa9fva1MtjLZymTrLRFLSt9LSt9LqvWWjN6SUSZHmRxlcpRJsaTEkl/f61fvKJOjTK4yuXpLxJJaZXKVydVbsnpLVplcZXKVyVMmxZISS0o1Tp0yecrkKZOnt0QsqfdMePs9E95+z4S33/6SVd/rtmqcVo3TqnFaLGmx5Nf3+k9vv2fC2++Z8PZ7Jrz9nglviyX9nglvv2fC2++Z8PbbX7Lqe91WjdOqcVo1ToslLZb8+l6/enWO0zrH6fdMePs9E94WSzqUyVAm3zPh7be/ZNX3uq0ap1XjtGqcFktaLPn1vX71pjKZymQqk++Z8LZY0qlMpjKZektKb4lqnFaN06pxWjVOiyUtlvz6Xr96S5ksZbKVydZbIpZ0K5OtTKrGadU46nvdbmVSNU6rxmmxpMWSX9/rV+8ok6NMjjI5ekvEkh5lcpXJ1VuyektU47RqnF5lcpVJsaTFkl/f61evapw+ZfKUydNbIpa0/JKWX9LyS/r0lqjGGdU4I79k5JeMWDJiya/vdb7LN5OjM+HRmfDoTHjEktGZ8OhMeHQmPG9/yarvdUc1zsgvGfklI5aMWPLre/3qVY0zOhMenQmPzoRHLJm3h37n7aHfeXvod97+klXf645qnJFfMvJLRiwZseTX9/rVqxpnQplMZfLtL9kRSyaVyVQm3x76nbe/ZNX3uqMaZ+SXjPySEUtGLPn1vX71qsaZUiZLmSy9JWLJlDLZymTrLWm9JapxRjXOtDLZyqRYMmLJr+/1q1c1zowyKb9k5JeMWDLyS0Z+ycgvmdFbohpnVOOM/JKRXzJiyYglI79kVOOM/JKRXzLyS0YsGfklI79k5JeM/BL1ve6oxhn5JSO/ZMSSFUtWfsmqxln5JSu/ZOWXrFiy8ktWfsnKL1n5Jep73VWNs/JLVn7JiiUrlqz8klWNs/JLVn7Jyi9ZsWTll6z8kpVfsvJL1Pe6qxpn5Zes/JIVS1YsWfklqxpn5Zes/JKVX7JiycovWfklK79k5Zeo73VXNc7KL1n5JSuWrFiy8ktWNc7KL1n5JSu/ZMWSlV+y8ktWfsnKL1Hf665qnJVfsvJLVixZsWTll6xqnJVfsvJLVn7JiiUrv2Tll6z8kpVfor7XXdU4K79k5ZesWLJiycovWdU4K79k5Zes/JIVS1Z+ycovWfklK79Efa+7qnFWfsnKL1mxZMWSlV+yqnFWfsnJLzn5JSeWnPySk19y8ktOfon6XvdU45z8kpNfcmLJiSUnv+RU45z8kpNfcvJLTiw5+SUnv+Tkl5z8EvW97qnGOfklJ7/kxJITS05+yanGOfklJ7/k5JecWHLyS05+yckvOfkl6nvdU41z8ktOfsmJJSeWnPySU41z8ktOfsnJLzmx5OSXnPySk19y8kvU97qnGufkl5z8khNLTiw5+SWnGufkl5z8kpNfcmLJyS85+SW673V13+uq73VPNY7ue13d97q673V13+ue/JJTjXPyS05+yckvObHk5Jec/JKTX3LyS9T3urrvdXXf6+q+19V9r6v7Xvfkl5xqnJNfcvJLTn7JiSX3+iX3ef2S+7x+yX1ev+TU93q67/V03+vpvtfTfa+n+17v8/ol93lrnPu8fsl9Xr/kPq9fcp+XJfd5/ZL7vH7JfV6/5D6vX3Lqez3d93q67/V03+vpvtfTfa/3ef2SU9/rqe/1Pq9fcp/XL7lP6NlCmQxl8vVL7vP6Jaf7Xk/3vZ7uez3d93qf0LOlnu31S+6TymQqk6lMvn7JfVLPlspkKpOpt6T0lpQyWcpkKZOlTJaerfRsr19yn1ImS5lsZbL1lrSerZXJViZbb0nrLWllspXJViZHmRw92+jZXr/kPqNMjjI5yuToLRk92yiTq0yu3pLVW7LK5CqTq0yuMrl6ttWz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0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0chEIxONTDQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQy0clEJxOdTHQyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcjEIBODTAwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyMcnEJBOTTEwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscjEIhOLTCwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyscnEJhObTGwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccjEIROHTBwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwyccnEJROXTFwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTDwy8cjEIxOPTOQci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcY/l/QwVkIudYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51j+/R9uqIBM5ByLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51iMcyzGORbjHItxjsU4x2KcYzHOsRjnWIxzLMY5FuMci3GOxTjHYpxjMc6xGOdYjHMsxjkW4xyLcY7FOMdinGMxzrEY51j+Y+resiPJkSSBbonQB1Sx/41NTxoZdb/66Akvp2TAIA3Q86YfHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHcvRsRwdy9GxHB3L0bEcHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpb/jxFIYCfqWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6Fj+/7+N4GACO1HHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6FhCxxI6ltCxhI4ldCyhYwkdS+hYQscSOpbQsYSOJXQsoWMJHUvoWELHEjqW0LGEjiV0LKFjCR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW/xtMYCfqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6ljy2Ik6lv8bTGAn6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6Vj+bzCBnahjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylY6ljJ+pY/m8wgZ2oYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY/m/wQR2oo6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpY+dqGP5v8EEdqKOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW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lp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiWUnlp1YdmLZiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx0YnzQyfOD504P3Ti/NCJ80Mnzg+dOD904vzQifNDJ87PjwmOCY4JjgmOCY4JjgmOCY4JjgmOCcIEYYIwQZggTBAmCBOECcIEYYI0QZogTZAmSBOkCdIEaYI0QZqgTFAmKBOUCcoEZYIyQZmgTFAmaBO0CdoEbYI2QZugTdAmaBO0Ca4JrgmuCa4JrgmuCa4JrgmuCa4JxgRjgjHBmGBMMCYYE4wJxgRjgjXBmmBNsCZYE6wJ1gRrgjXBmuCZ4JngmeCZ4JngmeCZ4JngmcBOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETdSyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5ldCyjYxkdy+hYRscyOpbRsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGxjI5l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uCa4JrgmGBOMCcYEY4IxwZhgTDAmGBOMCdYEa4I1wZpgTbAmWBOsCdYEa4JngmeCZ4JngmeCZ4JngmeCZ4JHgl/H8v3Jr2P5+5PwT9I/Kf+k/ZPrn4x/sv6JCY4JjgmOCY4JjgmOCY4JjgmOCY4JwgRhgjBBmCBMECYIE4QJwgRhgjRBmiBNkCZIE6QJ0gRpgjRBmqBMUCYoE9iJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJayeunbh24tqJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzEx+d+H7oxPdDJ74fOvH90Invh058P3Ti+6ET3w+d+H7oxPfzY4JjgmOCY4JjgmOCY4JjgmOCY4JjgjBBmCBMECYIE4QJwgRhgjBBmCBNkCZIE6QJ0gRpgjRBmiBNkCYoE5QJygRlgjJBmaBMUCYoE5QJ2gRtgjZBm6BN0CZoE7QJ2gRtgmuCa4JrgmuCa4JrgmuCa4JrgmuCMcGYYEwwJhgTjAnGBGOCMcGYYE2wJlgTrAnWBGuCNcGaYE2wJngmeCZ4JngmeCZ4JngmeCZ4JrATj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx47MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7MezEsBPDTgw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7Me3EtBPTTkw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7sezEshPLTiw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw7se3EthPbTmw78dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7MSxE8dOHDtx7EQdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HcvTsTwdy9OxPB3L07E8HEv+4Fj+/3D8k/BP0j8p/6T9k+ufjH+y/okJjgmOCY4JjgmOCY4JjgmOCY4JjgnCBF8nzu+f/Jdg9hv+S7C/f/Jfgu1vaIfr8F+C/X3r9Q0eL/s68fdlXyf+vuzrxL+XpS8rX2aCrxP/Xja+bH3Z42VfJ/6+7OvE35d9nfj3Mv8Oyr+DrxP/XnZ92fiy9WWPl32d+PuyrxN/X/Z14t/L0peVL2tf5iq0q9CuQrsK11W4rsJ1Fa6rcF2F6ypcV+G6CtdVuK7CuArjKoyrMK7CuArjKoyrMK7CuArjKqyrsK7CugrrKqyrsK7CugrrKqyrsK7CcxWeq/BchecqPFfhuQrPVXiuwnMVHqvw61i+l/06lu9lv47l72Xpy8qXtS+7vmx82foyVuHXsfy+7LAKv47l72Xpy8qXtS+7vmx82foyVuHXsfy+LFiFX8fy97L0ZeXL2pddXza+bH2Zq5CuQroK6Sqkq5CuQroK6Sqkq5CuQroK5SqUq1CuQrkK5Sp8nfjiG67DOKzDY/g68W84DuGQDuVggjZBm6BN0Ca4JrgmuCa4JrgmuCa4JrgmuCa4JhgTjAnGBGOCMcGYYEwwPonjkzg+ieuTuD6J65O4Ponrk7g+ieuTuD6J65O4PonPJ/H5JD6fxOeT+HwSn33w7INnHzz74NEHv47le9mvY/le9utY/l6Wvqx8Wfuy68vGl60vYxV+Hcvvyw6r8OtY/l6Wvqx8Wfuy68vGl60vYxV+Hcvvy4JV+HUsfy9LX1a+rH3Z9WXjy9aXuQqeE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhODM+J4TkxPCeG58TwnBieE8NzYnhO/HUs3/+T+HUsfwP/n+nXsfwNxyEc0qEc2uE6jMM6mOCY4JjgmOCY4JjgmOCY4JjgmOCYIEwQJggThAnCBGGCMEGYIEwQPIm/juVbxl/H8i3jr2P5e1n6svJl7cuuLxtftr6MJ/HXsfy+rHgSfx3L38vSl5Uva192fdn4svVl9MGvY/l9WdMHv47l72Xpy8qXtS+7vmx82foyV+G6CtdVuK7CdRWuq3BdhesqXFfhugrXVRhXYVyFcRXGVRhXYVyFcRU8J6bnxPScmJ4T03Niek5Mz4npOTE9J6bnxPScmJ4T03Niek5Mz4npOTE9J6bnxPScmJ4T03Niek5Mz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObE8J5bnxPKcWJ4Ty3NieU4sz4nlObG8O5d35/LuXN6dy7tzeXcu787l3bm8O5d35/LuXN6dy7tzeXcu787l3bm8O5d35/LuXN6dy7tzeXcu787l3bm8O5d35/LuXN6dfx3L32CCMcGaYH0S1ydxfRLXJ3F9EtcncX0S1ydxfRKfT+LzSXw+ic8n8fkkPp/E55P4fBKfT+KjD34dy/eyX8fyvezXsfy9LH1Z+bL2ZdeXjS9bX0Yf/DqW35cdVuHXsfy9LH1Z+bL2ZdeXjS9bX8Yq/DqW35cFq/DrWP5elr6sfFn7suvLxpetL3MVPCe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntObM+J7TmxPSe258T2nNieE9tzYntOvJ4Tr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p1/HcvvkCZIE6QJ/Izl+hnL9TOW62cs189Yrp+xXD9juX7Gcv2M5foZy/UzlutnLL+O5e9l15eNL1tf5pPYPolNH/w6lr+XpS8rX9a+7Pqy8WXry+iDX8fy+7JLH/w6lr+XuQrXVbiuwnUVrqtwXYXrKoyrMK7CuArjKoyrMK7CuArjKoyrMK7CugqeE6/nxOs58XpOvJ4Tr+fE6znxek68nhOv58TrOfF6TryeE6/nxOs58XpOvJ4Tr+fE6zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58TxnDieE8dz4nh3Hu/O4915vDuPd+fx7jzence783h3Hu/O4915vDuPd+fx7jzence783h3Hu/O4915vDuPd+fx7jzence783h3Hu/O4915vDv/Opa/wQRrgjXBmsBz4nhOHM+J4zlxPCeO58TxnDieE8dz4nhOHM+J4zlxPCeO58T1nLj+PnH9feL6+8T194nr7xPX3yeuv09cf5+4/j5x/X3i+vvE9feJ6+8T198nrr9PXH+fuP4+cf194vr7xPX3ievvE9ffJ66/T1x/n7j+PnH9feL6+8T194nr7xPX3yeuv09cf5+4/j5x/X3i+vvE9feJ6+8T198nrr9PXH+fuP4+cf194vr7xPX3ievvE9ffJ66/T1x/n7h+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rx+7rz++4nrv5+4/vuJz38/8fnvJz7//cTnv5/4/PcTn/9+4vPu/Lw7P+/Oz7vz8+78vDs/787Pu/Pz7vy8Oz/vzs+78/Pu/Lw7P+/Oz7vz8+78vDs/787Pu/Pz7vy8Oz/vzs+78/Pu/Lw7P+/Ov47lbzBBmiBNkCZIE3h3ft6dn3fn5935eXd+3p2fd+fn3fl5d37enZ935+fd+Xl3ft6dn3fn5935eXd+3p2fd+fn3fl5d37enZ935+fd+Xl3ft6dn3fn5935eXd+3p2fd+fn3fl5d37enZ935+fd+Xl3ft6dn3fn5935eXd+3p2fd+fn3fl5d37enZ935+fd+Xl3ft6dn3fn5935eXd+3p2fd+fn3fl5d37enZ935+fd+XF3Pj/cnc8Pd+fzw935/HB3Pj/cnc8Pd+fzw935/HB3Pj/cnc8Pd+fzw935/HB3Pj/cnc8Pd+fzw935/HB3Pj/cnc8Pd+fzw935/HB3Pj/cnc8Pd+fzw9356FiOjuX8cHc+P9ydzw935/PD3fn8hKuQrkK6CukqpKuQrkK6CukqpKuQrkK6CuUqlKtQrkK5CuUqlKtQrkK5CuUqlKvQrkK7Cu0qtKvQrkK7Cu0qtKvQrgJ35/PD3fn8cHc+P9ydzw935/PD3fn8cHc+P9ydzw935/PD3fn8XBOMCcYEY4IxwZhgTDAmGBOMCcYEa4I1wZpgTbAmWBOsCdYEa4I1wTPBM8FzLzz3wnMvPPfCcy8898JzL3B3Poe78zncnc/h7nwOd+dzuDufw935HO7O53B3Poe78zncnc/h7nwOd+dzuDufw935HO7O53B3Poe78zncnf9vWF9GIx3uzudwdz6Hu/M53J3P4e58Dnfnc7g7n8Pd+RzuzueEq5CuQroK6Sqkq5CuQroK6Sqkq5CuQroK5SqUq1CuQrkK5SqUq1CuQrkK5SqUq9CuQrsK7Sq0q9CuQrsK7Sq0q9CuQrsK11W4rsJ1Fa6rcF2F6ypcV+G6CtdVuK7CuArjKoyrMK7CuArjKoyrMK7CuArjKqyrsK7CugrrKqyrsK7CugrrKqyrsK7CcxWeq/BchecqPFfhuQrPVXiuwnMVuDuf4O58grvzCe7OJ7g7n+DufIK78wls3wls3wls3wls3wls3wls3wnuzie4O5/g7nyCu/MJ7s4nuDuf4O58grvzCe7OJ7g7nwgThAnCBGGCMEGYIEwQJkgTpAnSBGmCNEGaIE2QJkgTpAnKBGWCMkGZoEzA3fkEd+cT3J1PcHc+wd35BHfnE9ydT3B3PsHd+QR35xPcnU9wdz7B3fkEd+cT7V647oXrXrjuheteuO6F61647oXrXrjuheteGPfCuBe4O5/g7nyCu/OJcRXGVRhXYVyFcRXWVVhXYV2FdRXWVVhXYV2FdRXWVVhX4bkKz1V4rsJzFZ6r8FyF5yo8V+G5Ct6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O+tYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5ehYjo7l6FiOjuXoWI6O5aR35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6dfx3L32CCZ4JngmeCZwLvzjqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M55d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+fy7lzencu7c3l3Lu/O5d25vDuXd+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bv67OKf57+Kc5r+Lc5r/Ls5p/rs4p/nv4pz27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c5cJygRlgjJBmaBN4N25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d25vTu3d+f27tzendu7c3t3bu/O7d35ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935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O/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ347l54OvYCdeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTvx3L1z8Xrp147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiZdOzItOzItOzItOzItOzItOzItOzItOzItOzItOzOvlAjoxLzoxr+GC4QI6MS86Ma/hguECOjEvOjGv6YLpAjoxLzoxr+mC6QI6MS86Ma/pgumC5SssX2G5YLlg+QrLV1guWC5YvsLyFbYLtgu2r7B9he2C7YLtK2xfYbtgu+D4CsdXOC44Lji+wvEVjguOC46vcHyFxwWPCx5f4fEVHhc8Lnh8hcdXeFzwuCC+QnyFuCAuiK8QXyEuiAviK8RXqAvqgvoK9RXqgrqgvkJ9hbqgLri+wvUVrguuC66vcH2F64Lrgusr0IkZdGIGnZhBJ2bQiRl0Yr4dy69/LmTQiRl0YgadmPFyAZ2YQSdmDBcMF9CJGXRixnDBcAGdmEEnZkwXTBfQiRl0YsZ0wXQBnZhBJ2ZMF0wXLF9h+QrLBcsFy1egEzOWC5YLlq+wfIXtgu2C7StsX2G7YLtg+wrbV9gu2C44vsLxFY4LjguOr3B8heOC44LjKxxf4XHB44LHV3h8hccFjwseX+HxFR4XPC6IrxBfIS6IC+IrxFeIC+KC+ArxFeqCuqC+Qn2FuqAuqK9QX6EuqAuur3B9heuC64LrK1xf4brguuD6CnbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBO/HcvXPxemnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGUnLjtx2YnLTlx24uLfJ2bZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy5+75xlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduP33idtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cfN752w7cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzE479PPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJh98759iJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxMdOfOzEx0587MTHTnzsxMdOfOzEx0587MTHTnzsxMdOfOzEx0587MTHTnzsxMdOfOzEx0587MTHTnzsxMdOfOxEHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxJP7eWccSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LImdqGOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6ltTfO+tYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiU6luhYomOJjiW1E3Us0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFExxIdS3Qs0bFEx5Lr7511LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMcSHUt0LNGxRMeSayfqWKJjiY4lOpboWKJjiY4lOpboWKJjiY4lOpboWKJjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lOpbqWKpjqY6lL37vXB1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsXTQidWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHUt1LNWxVMdSHcv7gwuOr3B8heOC44LjKxxf4XHB44LHV3h8hccFjwseX+HxFR4XPC6IrxBfIS6IC+IrxFeIC+KC+ArxFeqCuqC+Qn2FuoDfO1fHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSyddqKOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6li6+L1zdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTH0mUn6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpTqW6liqY6mOpZvfO1fHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1LdSzVsVTHUh1L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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use jwt::JWT;\nuse noir_utils::HyliOutput512 as HyliOutput;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::hash::Hasher;\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_EMAIL_LENGTH: u32 = 77;\nglobal NONCE_LENGTH: u32 = 16;\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate hd and nonce fields\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param b64_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of hd and nonce will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param ephemeral_pubkey: Public key of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_salt: Salt of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_expiry: Expiry of the ephemeral keypair that is used to sign messages\n * @param nonce: JWT `nonce` as a byte array of ascii characters - 32 bytes\n **/\nfn main(\n    // Hyli output infos\n    hyli: HyliOutput,\n    // whats needed to build something that matches what is in blob field\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n) {\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // Get nonce claim\n    let nonce: BoundedVec<u8, NONCE_LENGTH> = jwt.get_claim_string(\"nonce\".as_bytes());\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    let email_field: Field = bytes_to_field(email.storage(), email.len());\n\n    let mut hasher = Poseidon2Hasher::default();\n    hasher.write(email_field);\n    let email_hash: Field = hasher.finish();\n\n    // email_hash:nonce:pubkey\n    let mut built_blob: BoundedVec<u8, 512> = BoundedVec::new();\n    built_blob.extend_from_array(email_hash.to_be_bytes::<32>());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(nonce.storage());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(joinLimbsToBigInt(jwt_pubkey_modulus_limbs).storage());\n\n    assert(email_hash == bytes_to_field(built_blob.storage(), 32), \"blob mail\");\n\n    assert(hyli.blob == built_blob.storage(), \"blob not matching\");\n\n    // Hyli specific asserts\n\n    assert(hyli.success == true);\n    assert(hyli.version == 1);\n    assert(hyli.initial_state_len == 4);\n    assert(hyli.next_state_len == 4);\n    assert(hyli.initial_state == [0; 4]);\n    assert(hyli.next_state == [0; 4]);\n    assert(hyli.blob_capacity == 512);\n    assert(hyli.blob_len == 306);\n    assert(hyli.blob_number == 1);\n    assert(hyli.tx_blob_count >= 1);\n}\n\nfn bytes_to_field<let LEN: u32>(bytes: [u8; LEN], len: u32) -> Field {\n    let mut result: Field = 0;\n    for i in 0..LEN {\n        // Big-endian: on \"pousse\" de 8 bits (= *256) puis on ajoute l'octet courant\n\n        if i < len {\n            result = result * 256 + (bytes[i] as Field);\n        }\n    }\n    result\n}\n\nfn u128_to_bytes(x: u128) -> [u8; 16] {\n    let mut out: [u8; 16] = [0; 16];\n\n    for i in 0..16 {\n        let shifted: u128 = x >> (i * 8);\n        // On garde uniquement les 8 bits de poids faible\n        out[i as u32] = (shifted & 0xff) as u8;\n    }\n\n    out\n}\n\n// last byte of each limb should be 0, that is why we skip it\nfn joinLimbsToBigInt(limbs: [u128; 18]) -> BoundedVec<u8, 256> {\n    let mut result = BoundedVec::new();\n    for i in 0..17 {\n        let sub: [u8] = u128_to_bytes(limbs[i]).as_slice();\n        let (sub, zero) = sub.pop_back();\n        let sub: [u8; 15] = sub.as_array();\n\n        assert(zero == 0);\n        result.extend_from_array(sub);\n    }\n\n    result.extend_from_slice([u128_to_bytes(limbs[17])[0]]);\n    result\n}\n\n#[test]\nfn encode_decode() {\n    let truc = 1234567890;\n    let result = bytes_to_field(u128_to_bytes(truc), 16) as u128;\n    println(truc);\n    println(result);\n\n    assert_eq(truc, result, \"dommach\");\n}\n","path":"/Users/matteo/projects/hyli-noir/check-jwt/src/main.nr"},"51":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/matteo/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/lib.nr"},"52":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/matteo/nargo/github.com/zkemail/noir-jwt/v0.5.1/src/partial_hash.nr"},"54":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"55":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"94":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"95":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"97":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"98":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"99":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"101":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"102":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"109":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"141":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/matteo/nargo/github.com/zkpassport/noir_rsa/v0.9.1/src/rsa.nr"},"157":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"158":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"},"167":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/matteo/nargo/github.com/noir-lang/poseidon/v0.2.0/src/poseidon2.nr"}},"expression_width":{"Bounded":{"width":4}}}