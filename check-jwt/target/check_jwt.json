{"noir_version":"1.0.0-beta.11+fd3925aaaeb76c76319f44590d135498ef41ea6c","hash":"4169979028731617602","abi":{"parameters":[{"name":"version","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"initial_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"next_state_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"next_state","type":{"kind":"array","length":4,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"identity_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"identity","type":{"kind":"string","length":256},"visibility":"public"},{"name":"tx_hash","type":{"kind":"string","length":64},"visibility":"public"},{"name":"index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_number","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_index","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_contract_name_len","type":{"kind":"integer","sign":"unsigned","width":8},"visibility":"public"},{"name":"blob_contract_name","type":{"kind":"string","length":256},"visibility":"public"},{"name":"blob_capacity","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob_len","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"blob","type":{"kind":"array","length":306,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"public"},{"name":"tx_blob_count","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"public"},{"name":"success","type":{"kind":"boolean"},"visibility":"public"},{"name":"partial_data","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":640,"type":{"kind":"integer","sign":"unsigned","width":8}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"partial_hash","type":{"kind":"array","length":8,"type":{"kind":"integer","sign":"unsigned","width":32}},"visibility":"private"},{"name":"full_data_length","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"base64_decode_offset","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"},{"name":"jwt_pubkey_modulus_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_pubkey_redc_params_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"},{"name":"jwt_signature_limbs","type":{"kind":"array","length":18,"type":{"kind":"integer","sign":"unsigned","width":128}},"visibility":"private"}],"return_type":null,"error_types":{"285656119219400463":{"error_kind":"string","string":"Field failed to decompose into specified 32 limbs"},"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"5675127253506927136":{"error_kind":"string","string":"utils::search could not find needle in haystack"},"5727012404371710682":{"error_kind":"string","string":"push out of bounds"},"5795655218219125583":{"error_kind":"string","string":"Field failed to decompose into specified 8 limbs"},"6314603625877298116":{"error_kind":"string","string":"haystack length of size 0 not supported"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"6521531773258950550":{"error_kind":"string","string":"blob mail"},"6543056410826478903":{"error_kind":"string","string":"incorrect value for claim"},"6668324276689745315":{"error_kind":"string","string":"Field failed to decompose into specified 4 limbs"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"7788270038095378938":{"error_kind":"string","string":"substring not present in main text (match found if a padding text included. is main text correctly formatted?)"},"8403890105346170400":{"error_kind":"string","string":"Field failed to decompose into specified 31 limbs"},"11393010598460336492":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"integer","sign":"unsigned","width":8},{"kind":"integer","sign":"unsigned","width":32}]},"11856048133850814249":{"error_kind":"string","string":"Field failed to decompose into specified 1 limbs"},"13815800804469369678":{"error_kind":"string","string":"partial_data length is too long"},"14225679739041873922":{"error_kind":"string","string":"Index out of bounds"},"14870952237766754546":{"error_kind":"string","string":"Field failed to decompose into specified 30 limbs"},"15412340888643424233":{"error_kind":"string","string":"needle length of size 0 not supported"},"16982834386335340233":{"error_kind":"string","string":"blob not matching"},"17135372224865900210":{"error_kind":"string","string":"Field failed to decompose into specified 15 limbs"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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0qynzHrarGfMetas58x63qwXzHrRrJfMetmsV8x61azXzHrdrDfMetN+zRL7Nd8y//lts94x612z3jPrfbM+MOtDsz4y62OzPjHrU7M+M+tzs74w60uzvjLra7O+Metbs74z63uzlpn1g1nLzVph1kqzVpm12qw1Zq0160ez1pm13v2HNz3h8YcPPemx95TH3tMee8947D3rsfecx97zHnsveOy96LH3ksfeyx57r3jsveqx95rH3usee2947L3psZd8k17g2nvYY2+Wx95sj705HntzPfbmeezN99hb4LG30GNvkcfeYo+9JR57Sz32HvHYe9Rj7zGPveSlberae8u+dM69tz323vHYe9dj7z2Pvfc99j7w2PvQY+8jj72PPfY+8dj71GPvM4+9zz32vvDY+9Jj7yuPva899r7x2PvWY+87j73vPfaWeez94LG33GNvhcfeSo+9VR57qz321njsrfXY+9Fjb53H3np7L/nsbP+1q/3XSHldeXllZaymMmHF4vGyWKI6FouXV5RGrbJYrDoRi0eteEW0Jharq6qurK6I1CRKE9Xxysry0mgiUl6e/APVkrPl36+XKK+pjVbXWOWVkbKKqlistqKytrasNlYbr7FKE9GaiBWNW1ZVabSqptK8fml5WV0sEUmUJWqqy2sTVcn/sTu5Grhz+nxd5x8y4fdn/m9+Y65sB//9W47XilrlZWW18dLaSDRSaX6oqoqYCVRVXhGpiMQqYjWlFdFobUVZRTxRlYhbiUhZtDZifshonf1ase4spra9f5Kve5n9uvUF3j8PH869XnPX+9EqjcfjidJ4aXXEqouURayy6liivLY8WhWvqKyurownakrr4tU15v8iNVVWxKqoqq6qTtRWRqsqamqiseR7MfkPNzSC34/TwPfjQ8B7qLYu+VRH3gLf22+Dc8H53vZ7T8qF7km54540FLgns+B7Qt67FgL3zvkP7Ph9/3wudI+ng/d4JHiP3wbv8TvgPS4H73Fc6B7HHfe4kcA9ng3f41nwPSbnQprAXNjuH5Lz+Xqf23OGngszwLkwCpwL74Bz4V1wLsTBuVAhNBcqHHNhV4G5MAeeC7PhuTALngvknEkXmDNfwXPmS9AzXwjNrZng3BoNzq13wbn1Hji3KsC5lRCaWwnH3GosMLfmwnNrDjy3ZsNzaxY8t8g5mCEwB7+G5yA5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upJ9bf9b3lPsa7cY7an2tVuN9sr2tf0yuIp97Tajvap97XajvZp97Q6jvbp97U6jPc2+dpfRXsO6dsYXrmlf2/dVa9nXjhvtte1r++3nOva1fT+4rn1t3w+uZ1/b94Pr29f2/eAG9rV9P7ihfW3fD25kX9v3gxvb1/b94Cb2tX0/2G5f2/eDHfa1/b5Pp33tHqPdZV070xfvtq/t++8e+9q+/97Uvrbvvzezr+37783ta/v+ewv72r7/3tK+tu+/t7Kv7fvvre1r+/57G+vajX6d39a+3X7bsJ19bb9t2N6+tt827GBf228bdrSv7bcNO9nX9svJzta1437bsIt9bb9t2NW+tt827GZf228bdrev7bcNe9jX9tuGPe1r+23DXva1/bZhb/vaftuwj31tv23Y176277+T9rV9/72ffW3ff+9vX9v33wfY1/b994H2tX3/fZB17Ubffx9sX9v334fY1/b996H2tRvNc6TDQBufY6e2w5OZ49bG9Rujec3HxfArhK1hPMfG8NAeTB/5HPuIZK6tdcq5FcFuea5QOWbCcVpOy2k5LafltJyW03JaTstpOS2nlTk3aRa1y6bWZItaK1nUmmJRa6pFrZUtaq1iUWtVi1qrWdRa3aLWNItazhc6LXluDYtaa1rUWsui1toWtdaxqLWuRa31LGqtb1FrA4taG1rU2sii1sYWtTaxqNVuUavDolanRa0ui1rdFrV6LGptalFrM4tam1vU2sKi1pYWtbayqLW1RS3Xz+mb1jazqF3bWtTazqLW9ha1drCotaNFrZ0sau1sUWsXi1q7WtTazaLW7ha19rCotadFrb0sau1tUWsfi1r7WtRKWtTaz6LW/ha1DrCodaBFrYMsah1sUesQi1qHWtRy/S+n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOq29aa8yidjktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bScltNyWk7LaTktp+W0nJbTclpOy2k5LafltJyW03JaTstpOS2n5bSc1n9Ja41Z1C6n5bSc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","debug_symbols":"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Mfk/xeSL/r9UTP7Pp0/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJrz/++fTJP58++Q//fPrkn0+f/PPpkz/+f+PTJ6s2PAfMKghfWNXP3/reyY5ZfJsj6i/fO1mY+w05jFZnmRwl63snOQjW907yEeZ+wOv3ThZS/fyt750szOrnLMn9y/dOFqYaFeNCxfgX3ztZSPXzt753spDq54+/d7JQKI9+/d6JgRV3/vq9k8Sz750szOvNJ/SX750szOtNr6/a8IWplq7+8/dOdszYlxKv3zsRsOLv1e+dUCa+f/ok65HTwsXvnSzMeuRVRx5//P69k8Sz750sTLVVR65gqq06cv/j9++dLEy1VUc+//j9eycLU20VhOdeGXXk+6dPckcuL3J972TVnOeeXF7D2vhLtb987yTxb/reyaoj3z99knazhPjseycLcyMwq37ff++k/XHleycL00LW2/7leycL88qyhvYv3ztZmFeWldLreydZKb2+d7IKwlNtFYRnoS9V4EEV+N/wvROh1vrS904OrAroH/rgSVVZr5LwrJT+qe+dLKT6+Qe+d0Kt9dn3Tham3Xzgq4IlH/ifv3eyY1U//9D3Tg7UP45Pn1Sx9v69k3z0P/W9k4V5E1kY+5fvnSxMtSyXPSkY3zHtZj3t1987ObAqoH/ogydVZb1KwrNS+qe+d7KQ6uef/d4Jtda677+ssvDj0ydZIZyF0GffO1mYxRJZE/2X750szHrk9NPZ904Wplo++vW9k7yyz793sjDV8i7PvneyMNVWmbj+8dv3TnasCuF/vndyYKplGfGfvndyoP7x1w+eeFEazQrgv3zvZGEazUrdVRiedba5Vf9SAZ6lsz/1vZOF6YOslF5NHfMWhSrli987Sfyp750spPr5Z793Qq11ztb90ydpN/3/U987WZh3kWPgL987SVwV41kpffa9k4Wplg9rfe8kH9bn3ztZmAVd6eqz750sTDXqyL/43snCVKOOXKgj53snBx6Vw///9MGTRcfMPv3eycJ8Dlmme+17JztmPXIW5J5972Rh1iPn5fzleycLs5Yvr/zi904WplpWSq/vnWSl9PreSVZKr++drNrwVMvbXN87WZhqeUMZBfZPn2Ql7iry7n+8fu/kwKqA/qEPnlSV9f/6iycLqgL6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Wixp+SUtv6Tll7T8Es29js57HZ33OjrvdXTe6+i812n5Ja0ep+WXtPySll/SYknLL2n5JS2/pOWXaO51dN7r6LzX0Xmvo/NeR+e9TssvafU4Lb+k5Ze0/JIWS1p+ScsvafklLb9Ec6+j815H572Oznsdnfc6Ou91Rn6J5l5Hc68z8ktGfsmIJSO/ZOSXjPySkV+i815H572Oznsdnfc6I5aMWDLyS0Y9zsgvGfklI79kxJKRXzLyS3Te6+i81xn1OKMeR+e9js57HZ33OjrvdUZ+yajHGfklI79E572OznudkV8y8ktGfonOe51RjzPqcUZ+ic57HZ33OjrvdUZ+yajHGfklI79E572OznudkV8y8ktGfonOe51RjzPqcUZ+ic57HZ33OjrvdUZ+yajHGfklI79E572OznudkV8y8ktGfonOe51RjzPqcUZ+ic57HZ33OjrvdUZ+yajHGfklI79E572OznudkV8y8ktGfonOe51RjzPqcUZ+ic57HZ33OjrvdUZ+yajHGfklI79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktWfonOe51Vj7PqcVZ+ic57HZ33OjrvdVZ+yarHWfklK79E572OznudlV+y8ktOfonOe51Tj3PqcU5+ic57HZ33OjrvdU5+yanHOfklJ79E572Oznudk19y8ktOfonOe51Tj3PqcU5+ic57HZ33OjrvdU5+yanHOfklJ79E572Oznudk19y8ktOfonOe51Tj3PqcU5+ic57HZ33OjrvdU5+yanHOfklJ79E572Oznudk19y8ktOfonOe51Tj3PqcU5+ic57HZ33OjrvdU5+yanHOfklJ79E572Oznudk19y8ktOfonOe51Tj3PqcU5+ic57HZ33OjrvdU5+yanHOfklJ79E572Oznudk19y8ktOfsnJL9Hc62judTT3Opp7Hc29juZe5+SXnHqck19y8kt03uvovNc5+SUnv+Tkl+i819Hc62judTX3upp7Xc29ruZe9/n8kn2+Hmefzy/Z5/NLVue9rs573efzS/b5/JJ9Pr9kdd7rau51Nfe6mntdzb2u5l5Xc6/7fH7JPl+Ps8/nl+zz+SWr815X572uzntdnfe6v7nX+Lu87/JlyXtpunRdhi7/bVrs8+3j7PPt4+zz7ePs8+3j7PPt4+zz7ePs8+3j7PPt4+zz7ePsk8qWypbKlsqWypbKVspWylbKVspWylbKVspWylbKVsrWytbK1srWytbK1srWytbK1srWyjbKNso2yjbKNso2yjbKNso2yjbKtsq2yrbKtsq2yrbKtsq2yrbKtsp2ynbKdsp2ynbKdsp2ynbKdsr27fatfbt9a99u39q327f27fatfbt9a99u39q327f27fatfbt9a4+ymbKZspmymbKZspmymbKZspmymbK5srmyubK5srmyubK5srmyubK5soWyhbKFsoWyiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlphYYmKJiSUmlrhY4mKJiyUulrhY4mKJiyUulrhY4mLJO/f63wLivnOvv0vXZegydVm6bF2OLleX9126sn27fevfbt/6t9u3/u32rX+7fevfbt/6t9u3/u32rX+7fevfbt96KFsoWyhbKFsoWyhbKFsoWyhbKlsqWypbKlsqWypbKlsqWypbKlspWylbKVspWylbKVspWylbKVspWytbK1srWytbK1srWytbK1srWyvbKNso2yjbKNso2yjbKNso2yjbKNsq2yrbKtsq2yrbKtsq2/sep/4uV5f3Xb49znv5l23/Ll2Xoct/Pc761+Osfz3O+tfjrOZeV3OvG+pxQj1OqMcJ9Tjx+SWr815X572uzntdnfe6Ou91Nfe6mntdzb2u5l5Xc6+rudcN9TihHifU44R6nHBlc2VzZXNlc2VzZXNlc2VzZXNlC2ULZQtlC2ULZQtlC2ULZQtlC2VLZUtlS2VLZUtlS2VLZUtlS2VLZStlK2UrZStlK2UrZStlK2UrZStla2VrZWtla2X73uOszntdnfe6Ou91dd7r6rzX1XmvG98ZjRvfO+GNzy/Z+N4Jb4yyjbKNso3ubZRtlW11b6t7W93bqpIvS/6Ufe+EN753whvfO+GNzy/Z+PySje+d8Mb3Tnjjeye8IZZo7nXj9LmdPjexJMSSFEt+c6/7d/lVMr93wpvfO+FN+SUpvyS/d8Kb3zvhze+d8Kb8Es29boolKZakWJJiSYolv7nXP73fO+HN753w5vdOeFN+Scovye+d8Ob3Tnjzeye8+c2XrOZeN8WSFEtSLEmxJMWS39zrn95QJUOVDFXyeye8Gbq3UCVTlfzeCW9+8yWruddNsSTFkhRLUixJseQ39/qnt1TJUiVLlSw9JaV7K1WyVMnSU1J6SsSSFEtSLEmxJMWSbN1bf79v2apkq5KtSraektG9jSo5quToKRFLNPe6OarkqJJiSYolKZb85l7/9K4quarkqpKrp0QsyVUlV5VcPSWnp+RUyVMlT5U8VVIsSbHkN/f6p/dUye+d8Nb3Tnjreye8JZbU905463snvPW9E9765ktWc69b+l5S+l5S+l5SYkmJJb+51/27/CpZ3zvhre+d8Nb3TnhLLKnvnfDW905463snvPXNl6zmXrf0vaT0vaT0vaTEkhJLfnOvf3pDlQxVMlTJ753wllhSoUqGKvm9E9765ktWc69b+l5S+l5S+l5SYkmJJb+51z+9qUqmKpmqZOopEUuqVMlSJUtPSekp0feS0veS0veS0veSEktKLPnNvf7pbVWyVclWJVtPiVhS+l5S+l5Sradk9JSMKjmq5KiSo0qKJSWW/OZe//SOKjmq5KqSq6dELKlVJVeVXD0lq6dkVclVJVeVPFVSLCmxpNTj1KmSp0qeKnl6SsSS+t4Jb3/vhLe/d8Lb33zJau51Wz1Oq8dp9TgtlrRY8pt7/U9vf++Et793wtvfO+Ht753wtljS3zvh7e+d8Pb3Tnj7my9Zzb1uq8dp9TitHqfFkhZLfnOvf3r1Hqf1Hqe/d8Lb3zvhbbGkQ5UMVfJ7J7z9zZes5l631eO0epxWj9NiSYslv7nXP72pSqYqmark9054WyzpVCVTlUw9JaWnRD1Oq8dp9TitHqfFkhZLfnOvf3pLlSxVslXJ1lMilnSrkq1Kqsdp9Tiae91uVVI9TqvHabGkxZLf3Ouf3lElR5UcVXL0lIglParkqpKrp2T1lKjHafU4varkqpJiSYslv7nXP73qcfpUyVMlT0+JWNLyS1p+Scsv6dNToh5n1OOM/JKRXzJiyYglv7nX/bv8Kjl6Jzx6Jzx6Jzxiyeid8Oid8Oid8HzzJau51x31OCO/ZOSXjFgyYslv7vVPr3qc0Tvh0Tvh0TvhEUvmm6Hf+Wbod74Z+p1vvmQ197qjHmfkl4z8khFLRiz5zb3+6VWPM6FKpir5zZfsiCWTqmSqkt8M/c43X7Kae91RjzPyS0Z+yYglI5b85l7/9KrHmVIlS5UsPSViyZQq2apk6ylpPSXqcUY9zrQq2aqkWDJiyW/u9U+vepwZVVJ+ycgvGbFk5JeM/JKRXzKjp0Q9zqjHGfklI79kxJIRS0Z+yajHGfklI79k5JeMWDLyS0Z+ycgvGfklmnvdUY8z8ktGfsmIJSuWrPySVY+z8ktWfsnKL1mxZOWXrPySlV+y8ks097qrHmfll6z8khVLVixZ+SWrHmfll6z8kpVfsmLJyi9Z+SUrv2Tll2judVc9zsovWfklK5asWLLyS1Y9zsovWfklK79kxZKVX7LyS1Z+ycov0dzrrnqclV+y8ktWLFmxZOWXrHqclV+y8ktWfsmKJSu/ZOWXrPySlV+iuddd9Tgrv2Tll6xYsmLJyi9Z9Tgrv2Tll6z8khVLVn7Jyi9Z+SUrv0Rzr7vqcVZ+ycovWbFkxZKVX7LqcVZ+ycovWfklK5as/JKVX7LyS1Z+ieZed9XjrPySlV+yYsmKJSu/ZNXjrPySk19y8ktOLDn5JSe/5OSXnPwSzb3uqcc5+SUnv+TEkhNLTn7Jqcc5+SUnv+Tkl5xYcvJLTn7JyS85+SWae91Tj3PyS05+yYklJ5ac/JJTj3PyS05+yckvObHk5Jec/JKTX3LySzT3uqce5+SXnPySE0tOLDn5Jace5+SXnPySk19yYsnJLzn5JSe/5OSXaO51Tz3OyS85+SUnlpxYcvJLTj3OyS85+SUnv+TEkpNfcvJLdN7r6rzX1dzrnnocnfe6Ou91dd7r6rzXPfklpx7n5Jec/JKTX3JiyckvOfklJ7/k5Jdo7nV13uv/L1VJ+SU673V13uue/JJTj3PyS05+yckvObHkPr/kns8vuefzS+75/JLT3OvpvNfTea+n815P572eznu95/NL7vl6nHs+v+Sezy+55/NL7vlYcs/nl9zz+SX3fH7JPZ9fcpp7PZ33ejrv9XTe6+m819N5r/d8fslp7vU093rP55fc8/kl94TuLVTJUCU/v+Sezy85nfd6Ou/1dN7r6bzXe0L3lrq3zy+5J1XJVCVTlfz8kntS95aqZKqSqaek9JSUKlmqZKmSpUqW7q10b59fck+pkqVKtirZekpa99aqZKuSraek9ZS0KtmqZKuSo0qO7m10b59fcs+okqNKjio5ekpG9zaq5KqSq6dk9ZSsKrmq5KqSq0qu7m11b6vft1MlT5U8VfL0lJzu7VTJUyVPT8npKfl6nLOvxzn7/JLTea+n815P572efX7J2dfjnH1+ydnnl5zOez2d93r2+SVnn19y9vklp/Nez74e5+zrcc4+v+R03uvpvNfTea9nn19y9vU4Z59fcvb5JafzXk/nvZ59fsnZ55ecfX7J6bzXs1AlQ5UMVTJUSbFE572efX7JWaiSoUqmKvn5JafzXs9SlUxV8vNLTue9nqUqmapkqpKlSoolOu/17PNLzkqVLFWyVMnSUyKWWKmSrUq2npLWU9KqZKuSrUq2KimW6LzXs88vORtVclTJUSVHT4lYYqNKjio5ekpGT8mokqtKriq5qqRYovNez1a/b6tKriq5quTqKRFL7FTJUyVPT8npKTlV8lTJUyVPlRRLdN7r+eeXnH89zvnnl5x/fsnpvNfTea/nn19y/vkl559fcjrv9fzrcc6/Huf880tO572ezns9nfd6/vkl51+Pc/75JeefX3I67/V03uv555ecf37J+eeXnM57Pf96nPOvxzl3VTJUSbFE572ef37JeaiSoUqGKvn5JafzXs9DlUxV8vNLTue9nqcqmapkqpKpSoolOu/1/PNLzkuVLFWyVMnSUyKWeKmSpUqWnpLSU1KqZKuSrUq2KimW6LzX888vOW9VslXJViVbT4lY4qNKjio5ekpGT8mokqNKjio5qqRYovNez1e/b6tKriq5quTqKRFLfFXJVSVXT8npKTlV8lTJUyVPlRRLdN7r+en37VTJzy+5+PyS03mvp/NeLz6/5OLzSy4+v+R03utp7vU093qaez3NvZ7mXk9zrxefX3KhHic+v+Ti80tO572eznu9+PySi88vufj8ktN5r6e519Pc62nu9TT3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4nE+8TifeJxPPM4nHucTj/OJx3csx3csx3csx3csx3csx3csx3csx3csx3csx3csx9752Dsfe+dj73zsnY+987F3PvbOx9752Dsfe+dj73zsnY+987F3PvbOx9752Dsfe+dj73zsnY+987F3PvbOx9752Dsfe+dj73zsnY+987F3PvbOx9752Dsfe+dj73zsnY+987F3PvbOx9752Dsfe+dj73zsnY+9M/dYhnsswz2W4R7LcI9luMcy3GMZ7rEM91iGeyzDPZbhHstwj2W4xzLcYxnusQz3WJZ7LMs9luUey3KPZbnHsv/2WPoN9LfzPtjt2we7fftgt28f7Pbtg/nEfTCfuA/mE/fBfOI+mE/cx6jAqMCowKjAqcCpwKnAqcCpAL3zPtjt2we7fftgt28f7Pbtg/nEfTCfuA/mE/fBfOI+mE/cJ6ggqCCoIKggqCCpIKkgqSCpALt9+2C3bx/s9u2D3b797bH8Cw4B5hP3wXziPphP3AfzifsUFRQVFBUUFRQVFBU0FfzmE98P+GWiv7eN3nkf9M77oHfeB73zPuid90HvvA96533QO++D3nkf9M77DBUMFQwVDBUMFQwVDBUsFSwVLBUsFSwVLBUsFSwVLBUsFRwVHBUcFRwVHBUcFaB33ge98z7onfdB77yG3nkNvfMaeuc19M5r6J3X0DuvoXdeQ++8ht557aECowKjAqMCowKjAqMCowKjAqMCowKnAqcCpwKnAqcCpwKnAqcCpwKngqCCoIKggqCCoIKggqCCoIKggqCCpIKkgqSCpIKkgqSCpIKkgqSCpIKigqKCooKigqKCooKigqKCooKigqaCpoKmgqaC3/fEfgP87WzY7VvDbt8advvWsNu3hvnENcwnrmE+cQ3ziWuYT1wbKhgqGCoYKhgqWCpYKlgqWCpA77yG3b417PatYbdvDbt9a5hPXMN84hrmE9cwn7iG+cS1o4KjgqOCo4KjAswnrmM+cR3zieuYT1zHbt86dvvWsdu3jt2+/e2x/AuWAf52dswnrmM+cR3zietGBUYFRgVGBUYFRgVGBb/5xH6DPwXvVwJH77yO3nkdvfM6eud19M7r6J3X0Tuvo3deR++8jt55PaggqCCoIKggqCCoIKggqCCpIKkgqSCpIKkgqSCpIKkgqSCpoKigqKCooKigqAC98zp653X0zuvondfRO6+jd15H77yO3nkdvfM6euf1poKmgqaCpoKmgqGCoYKhgqGCoYKhgqGCoYKhgqGCpYKlgqWCpYKlgqWCpYKlgqWCpYKjgqOCo4KjgqOCo4KjgqOCowL2zsHemXssyz2W5R7Lco9lucey3GNZ7rEs91iWeyzLPZblHstyj2W5x7LcY1nusSz3WJZ7LMs9luUey3KPZbnHstxj2X97LP0G+Ns5sNu3gd2+Dez2bWC3bwPziRuYT9zAfOIG5hM3MJ+4EVQQVBBUEFQQVBBUkFSQVJBUwN45sNu3gd2+Dez2bWC3bwPziRuYT9zAfOIG5hM3MJ+4UVRQVFBUUFRQVFBUUFTQVNBUgN2+Dez2bWC3bwO7ffvbY/kXDINlgL+dA/OJG5hP3BgqGCoYKhgqGCoYKhgq+M0nvh/wy8T3K0Gwdw72zsHeOdg7B3vnYO8c7J2DvXOwdw72zsHeOdg7B3vnYO8c7J3jqOCo4KgA84mbmE/cxHziJuYTNzGfuIl3LJt4x7KJdyybeMeyiXcsmw8VGBUYFRgVGBWwd072zsneOdk7J3vnZO+c7J2TvXOyd072zsneOdk7J3vnZO+c7J2TvXOyd072zsneOdk7J3vnZO+c7J2TvXOyd072zsneOdk7J3vnZO+c7J2TvXOyd072zsneOdk7J3vnZO+c7J2TvXOyd072zsneOdk7J3vnZO/MPZblHstyj2W5x7LcY1nusSz3WJZ7LMs9luUey3KPZbnHstxjWe6xLPdYlnssyz2W5R7Lco9lucey3GNZ7rHsvz2WfgP87ZzY7dvEbt8mdvs2sdu3ifnETcwnbmI+cRPziZuYT9w8KjgqOCo4KjgqOCrAfOIW5hO3MJ+4xd65sNu3hd2+Lez2bWG3bwvziVuYT9zCfOIW5hO3MJ+4ZVRgVGBUYFRgVGBUYFRgVOBUgN2+Lez2bWG3bwu7fVv4fw9sYT5xC/OJW5hP3MJ84hbmE7eCCoIKggqCCoIKggqCCn7zie8H/DLx/UpQ7J2LvXOxdy72zsXeudg7F3vnYu9c7J2LvXOxdy72zsXeudg7F3vnKiooKigqKCooKmgqaCpoKuA7luI7luI7luI7luI7luI7luI7luI7luI7luI7lmLvXOydi71zsXcu9s7F3rnYOxd752LvXOydi71zsXcu9s7F3rnYOxd752LvXOydi71zsXcu9s7F3rnYOxd752LvXOydi71zs3du9s7N3rnZOzd752bv3Oydm71zs3du9s7N3rnZOzd752bv3Oydm71zs3du9s7N3pl7LMs9luUey3KPZbnHstxjWe6xLPdYlnssyz2W5R7Lco9lucey3GNZ7rEs91iWeyzLPZblHstyj2W5x7LcY9l/eyz9BvjbubHbt43dvm3s9m1jt28b84nbmE/cxnziNuYTtzGfuF1UUFRQVFBUUFRQVFBUUFTQVMDeubHbt43dvm3s9m1jt28b84nbmE/cxnziNuYTtzGfuD1UMFQwVDBUMFQwVDBUMFQwVIDdvm3s9m1jt28bu33b+H8PbGM+cRvziduYT9zGfOI25hO3jwqOCo4KjgqOCo4Kjgp+84nvB/wy8f1K0Oydh73zsHce9s7D3nnYOw9752HvPOydh73zsHce9s7D3nnYOw975zEqMCowKjAqMCowKnAqcCrgO5bhO5bhO5bhO5bhO5bhO5bhO5bhO5bhO5bhO5Zh7zzsnYe987B3HvbOw9552DsPe+dh7zzsnYe987B3HvbOw9552DsPe+dh7zzsnYe987B3HvbOw9552DsPe+dh7zzsnYe987B3HvbOw9552DsPe+dh7zzsnYe987B3HvbOw9552DsPe+dh7zzsnYe987B3HvbOw96ZeyzLPZblHstyj2W5x7LcY1nusSz3WJZ7LMs9luUey3KPZbnHstxjWe6xLPdYlnssyz2W5R7Lco9lucey3GPZf3ss/Qb423mx27eL3b5d7PbtYrdvl/OJy/nE5Xzicj5xOZ+4nE9czicu5xOX84nL+cTlfOJyPnE5n7icT1z2zovdvl3s9u1it28Xu327nE9czicu5xOX84nL+cTlfOJyPnE5n7icT1zOJy7nE5fzicv5xOV84mK3bxe7fbvY7dvFbt8u/t8Du5xPXM4nLucTl/OJy/nE5Xzicj5xOZ+4nE9czicu5xOX84m/PZb3K8Fvj+X9SrDsnZe987J3XvbOy9552Tsve+dl77zsnZe987J3XvbOy9552Tsve+flfOJyPnE5n7icT1zOJy7nE5fzicv5xOU7luU7luU7luU7luU7luU7luU7luU7luU7luU7lmXvvOydl73zsnde9s7L3nnZOy9752XvfOydj73zsXc+9s7H3vnYOx9752PvfOydj73zsXc+9s7H3vnYOx97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MFQwVDBUsFSwVLBUsFSwVLBUsFSwVLBUsFRwVHBUcFRwVHBUcFRwVHBUcFRAJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJhqZaGSikYlGJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJjqZ6GSik4lOJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJgaZGGRikIlBJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJiaZmGRikolJJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJhaZWGRikYlFJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJjaZ2GRik4lNJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJg6ZOGTikIlDJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJi6ZuGTikolLJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYlHJh6ZeGTikYncYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHsv/AyogE7nHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHss//2DARWQidxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMei3GPxbjHYtxjMe6xGPdYjHssxj0W4x6LcY/FuMdi3GMx7rEY91iMeyzGPRbjHotxj8W4x2LcYzHusRj3WIx7LMY9FuMe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1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUsqWNJHUvqWFLHkjqW1LGkjiV1LKljSR1L6lhSx5I6ltSxpI4ldSypY0kdS+pYUseSOpbUsaSOJXUs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pWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXQspWMpHUvpWErHUjqW0rGUjqV0LKVjKR1L6VhKx1I6ltKxlI6ldCylYykdS+lYSsdSOpbSsZSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfy32ACO1HH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LP8NJrATj52oY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWNpHUvrWFrH0jqW1rG0jqV1LK1jaR1L61hax9I6ltaxtI6ldSytY2kdS+tYWsfSOpbWsbSOpXUsrWO5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lv8GE9iJOparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqWq2O5OparY7k6lqtjuTqW/wYT2InHTtSxXB3L/XMs/RnW4ZNgfodvJ36H4xAOnwT7GcqhHa7DOKzDY/h24nc4DuFggmeCZ4JngmeCZ4JHgj/H8h2OQzikQzm0w3UYh3UwwTHBMcExwTHBMcExwTHBMcExwTFBmCBMECYIE4QJwgRhgjBBmCBMkCZIE6QJ0gRpgjRBmiBNkCZIE5QJygRlgjJBmaBMUCYoE5QJygRtgjZBm6BN0CZoE7QJ2gRtgjbBNcE1wTXBNcE1wTXBNcE1wTXBNcGYYEwwJhgTjAnGBGOCMcGYYEywJlgTrAnsxLATw04MOzHsxLATw04MOzHsxLATw04MOzHsxLATw04MOzHsxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLQT005MOzHtxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLITy04sO7HsxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxLYT205sO7HtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHThw7cezEsRPHTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTlw7ce3EtRPXTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5347MRnJz478dmJz058duKzE5+d+OzEZyc+O/HZic9OfHbisxOfnfjsxGcnPjvx2YnPTnx24rMTn5346MT5oRPnh06cHzpxfujE+aET54dOnB86cX7oxPmhE+fnxwTHBMcExwTHBMcExwTHBMcExwTHBGGCMEGYIEwQJggThAnCBGGCMEGaIE2QJkgTpAnSBGmCNEGaIE1QJigTlAnKBGWCMkGZoExQJigTtAnaBG2CNkGboE3QJmgTtAnaBNcE1wTXBNcE1wTXBNcE1wTXBNcEY4IxwZhgTDAmGBOMCcYEY4IxwZpgTbAmWBOsCdYEa4I1wZpgTfBM8EzwTPBM8EzwTPBM8EzwTGAnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx048duKxE4+deOzEYyceO/HYicdOPHbisROPnXjsxGMnHjvx2InHTjx24rETj5147MRjJx478diJx07UsYyOZXQso2MZHcvoWEbHMjqW0bGMjmV0LKNjGR3L6FhGxzI6ltGx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dmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YdmLbiW0ntp3YduK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EaydeO/HaiddOvHbitROvnXjtxGsnXjvx2onXTrx24rUTr5147cRrJ1478dqJ1068duK1E6+deO3EayeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyeOnTh24tiJYyfqWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6ViejuXpWJ6O5elYno7l6Vie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jKswrsK6CusqrKuwrsK6CusqrKuwrsK6CusqPFfhuQrPVXiuwnMVnqvwXIXnKjxXwbtzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TurGM5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWo2M5OpajYzk6lqNjOTqWk96d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzendO787p3Tm9O6d35/TunN6d07tzenf+Opa/wQTPBM8EzwTPBN6ddSxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3J0LEfHcnQsR8dydCxHx3LKu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5dy7vzuXdubw7l3fn8u5c3p3Lu3N5d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c/HdxTvPfxTnNfxfnNP9dnNP8d3FO89/FOe3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fnLhOUCcoEZYI2QZvAu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p3bu3N7d27vzu3dub07t3fn9u7c3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr3fl6d77ena935+vd+Xp3vt6dr3fn6935ene+3p2vd+fr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Thx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYiW/H8vr3wrATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATh5047MRhJw47cdiJw04cduKwE4edOOzEYScOO3HYicNOHHbisBOHnTjsxGEnDjtx2InDThx24rATp5047cRpJ047cdqJ006cfD8x006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx8nPnTDtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTp5047cRpJ047cdqJ006cduK0E6edOO3EaSdOO3HaidNOnHbitBOnnTjtxGknTjtx2onTTpx24rQTl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MTl9xOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduLi585ZduKyE5eduOzEZScuO3HZictOXHbishOXnbjsxGUnLjtx2YnLTlx24rITl5247MRlJy47cdmJy05cduKyE5eduOzEZScuO3HZictOXHbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidvvJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjtxG0nbjtx24nbTtx24rYTt5247cRtJ247cduJ207cduK2E7eduO3EbSduO3HbidtO3HbithO3nbjt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","file_map":{"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let mut result = self.len().cmp(other.len());\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0);\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"50":{"source":"use jwt::JWT;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::hash::Hasher;\n\nglobal MAX_PARTIAL_DATA_LENGTH: u32 = 640; // signed data length after partial SHA\nglobal MAX_EMAIL_LENGTH: u32 = 77;\nglobal NONCE_LENGTH: u32 = 16;\n\n/**\n * @brief Verify JWT signature (RSA/SHA256 only) and validate hd and nonce fields\n *\n * @param partial_data: OIDC JWT (id_token) base64 data (`$header.$payload`) as byte array of ascii characters\n *                      We do partial SHA on the data up to hd field outside of the circuit, to reduce constraints\n *                      This field only contains the bytes after partial SHA; padded to MAX_PARTIAL_DATA_LENGTH\n * @param partial_hash: The 256-bit partial hash of the `data`\n * @param full_data_length: The full length of the `data` (before partial SHA)\n * @param b64_offset: Offset needed in `partial_data` to make the payloadB64 a multiple of 4\n *                    Signed data is $header.$payload. $payload might not be a multiple of 4 in `partial_data`, so we need to offset\n *                    Not attack-able by giving an incorrect offset, as string match of hd and nonce will fail\n * @param jwt_pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n * @param jwt_pubkey_redc_params_limbs: RSA reduction parameters limbs\n * @param jwt_signature_limbs: RSA signature limbs\n * @param domain: Domain name (`hd` key) as a byte array of ascii characters padded to MAX_DOMAIN_LENGTH\n * @param ephemeral_pubkey: Public key of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_salt: Salt of the ephemeral keypair that is used to sign messages\n * @param ephemeral_pubkey_expiry: Expiry of the ephemeral keypair that is used to sign messages\n * @param nonce: JWT `nonce` as a byte array of ascii characters - 32 bytes\n **/\nfn main(\n    // Hyli output infos\n    version: pub u32,\n    initial_state_len: pub u32,\n    initial_state: pub [u8; 4],\n    next_state_len: pub u32,\n    next_state: pub [u8; 4],\n    identity_len: pub u8,\n    identity: pub str<256>,\n    tx_hash: pub str<64>,\n    // ------ Blobs ------\n    index: pub u32,\n    blob_number: pub u32,\n    // --- Blob\n    blob_index: pub u32,\n    blob_contract_name_len: pub u8,\n    blob_contract_name: pub str<256>,\n    blob_capacity: pub u32,\n    blob_len: pub u32,\n    blob: pub [u8; 306],\n    tx_blob_count: pub u32,\n    success: pub bool,\n    // whats needed to build something that matches what is in blob field\n    partial_data: BoundedVec<u8, MAX_PARTIAL_DATA_LENGTH>,\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    jwt_pubkey_modulus_limbs: [u128; 18],\n    jwt_pubkey_redc_params_limbs: [u128; 18],\n    jwt_signature_limbs: [u128; 18],\n) {\n    // Init JWT struct and verify signature\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        jwt_pubkey_modulus_limbs,\n        jwt_pubkey_redc_params_limbs,\n        jwt_signature_limbs,\n    );\n    jwt.verify();\n\n    // Get nonce claim\n    let nonce: BoundedVec<u8, NONCE_LENGTH> = jwt.get_claim_string(\"nonce\".as_bytes());\n\n    // Assert email_verified claim\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n\n    // Get email claim\n    let email: BoundedVec<u8, MAX_EMAIL_LENGTH> = jwt.get_claim_string(\"email\".as_bytes());\n    let email_field: Field = bytes_to_field(email.storage(), email.len());\n\n    let mut hasher = Poseidon2Hasher::default();\n    hasher.write(email_field);\n    let email_hash: Field = hasher.finish();\n\n    // email_hash:nonce:pubkey\n    let mut built_blob: BoundedVec<u8, 306> = BoundedVec::new();\n    built_blob.extend_from_array(email_hash.to_be_bytes::<32>());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(nonce.storage());\n    built_blob.extend_from_slice(\":\".as_bytes());\n    built_blob.extend_from_slice(joinLimbsToBigInt(jwt_pubkey_modulus_limbs).storage());\n\n    assert(email_hash == bytes_to_field(built_blob.storage(), 32), \"blob mail\");\n\n    assert(blob == built_blob.storage(), \"blob not matching\");\n\n    // Hyli specific asserts\n\n    assert(success == true);\n    assert(version == 1);\n    assert(initial_state_len == 4);\n    assert(next_state_len == 4);\n    assert(initial_state == [0; 4]);\n    assert(next_state == [0; 4]);\n    assert(blob_capacity == 306);\n    assert(blob_len == 306);\n    assert(blob_number == 1);\n    assert(tx_blob_count >= 1);\n}\n\nfn bytes_to_field<let LEN: u32>(bytes: [u8; LEN], len: u32) -> Field {\n    let mut result: Field = 0;\n    for i in 0..LEN {\n        // Big-endian: on \"pousse\" de 8 bits (= *256) puis on ajoute l'octet courant\n\n        if i < len {\n            result = result * 256 + (bytes[i] as Field);\n        }\n    }\n    result\n}\n\nfn u128_to_bytes(x: u128) -> [u8; 16] {\n    let mut out: [u8; 16] = [0; 16];\n\n    for i in 0..16 {\n        let shifted: u128 = x >> (i * 8);\n        // On garde uniquement les 8 bits de poids faible\n        out[i as u32] = (shifted & 0xff) as u8;\n    }\n\n    out\n}\n\n// last byte of each limb should be 0, that is why we skip it\nfn joinLimbsToBigInt(limbs: [u128; 18]) -> BoundedVec<u8, 256> {\n    let mut result = BoundedVec::new();\n    for i in 0..17 {\n        let sub: [u8] = u128_to_bytes(limbs[i]).as_slice();\n        let (sub, zero) = sub.pop_back();\n        let sub: [u8; 15] = sub.as_array();\n\n        assert(zero == 0);\n        result.extend_from_array(sub);\n    }\n\n    result.extend_from_slice([u128_to_bytes(limbs[17])[0]]);\n    result\n}\n\n#[test]\nfn encode_decode() {\n    let truc = 1234567890;\n    let result = bytes_to_field(u128_to_bytes(truc), 16) as u128;\n    println(truc);\n    println(result);\n\n    assert_eq(truc, result, \"dommach\");\n}\n","path":"/Users/lancelot/Programming/Hyl/hyli-noir/check-jwt/src/main.nr"},"51":{"source":"mod partial_hash;\n\nuse base64::BASE64_URL_DECODER;\nuse bignum::{params::BigNumParams, RuntimeBigNum};\nuse nodash::str_to_u64;\nuse partial_hash::partial_sha256_var_end;\nuse rsa::rsa::verify_sha256_pkcs1v15;\nuse sha256::sha256_var;\nuse string_search::{StringBody, SubString};\n\n/**\n * @brief Struct representing a JWT. Use the init functions to create an instance\n *        Currently only supports RSA 2048/SHA256 signatures\n **/\npub struct JWT<let MAX_DATA_LENGTH: u32> {\n    data: BoundedVec<u8, MAX_DATA_LENGTH>,\n    pubkey_modulus_limbs: [u128; 18],\n    redc_params_limbs: [u128; 18],\n    signature_limbs: [u128; 18],\n    partial_hash: [u32; 8],\n    full_data_length: u32,\n    base64_decode_offset: u32,\n    is_partial_hash: bool, // compile time variable used internally\n}\n\nimpl<let MAX_DATA_LENGTH: u32> JWT<MAX_DATA_LENGTH> {\n    /**\n    * @brief Initialize JWT struct\n    *\n    * @param data: Signed JWT data (base64 encoded `$header.$payload`) as byte array of ascii characters\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Any 4x multiple from the payload start index.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs (2048-bit split into 18 limbs)\n    * @param signature_limbs: RSA signature limbs (2048-bit split into 18 limbs)\n    **/\n    pub fn init(\n        data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(data.len() <= MAX_DATA_LENGTH, \"data length is too long\");\n\n        JWT {\n            data,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            // below fields are not relevant unless for partial hash\n            full_data_length: MAX_DATA_LENGTH,\n            partial_hash: [0; 8],\n            is_partial_hash: false,\n        }\n    }\n\n    /**\n    * @brief Initialize JWT with partial SHA256 hash'ed input\n    *        Since SHA hash is expensive to compute in circuit, we can optimize by pre-hashing up to a certain block outside the circuit,\n    *        and verify for correctness in the circuit. This is possible since SHA works in incremental blocks.\n    *        You can pre-hash up to the SHA-256 block from where you want to extract a claim.\n    *\n    * @param partial_data: Signed JWT data (base64 encoded `$header.$payload`) after partial hashed block\n    * @param partial_hash: The 256-bit partial hash of the `partial_data` up to a certain block\n    * @param full_data_length: The full length of the `data` (before partial SHA)\n    * @param base64_decode_offset: The offset from which we will start base64 decoding the data.\n    *                                   Trimming `offset` nubmer of bytes from the data should it base64 decode-able.\n    * @param pubkey_modulus_limbs: RSA public key modulus limbs (2048-bit split into 18 limbs)\n    * @param redc_params_limbs: RSA reduction parameters limbs\n    * @param signature_limbs: RSA signature limbs\n    **/\n    pub fn init_with_partial_hash(\n        partial_data: BoundedVec<u8, MAX_DATA_LENGTH>,\n        partial_hash: [u32; 8],\n        full_data_length: u32,\n        base64_decode_offset: u32,\n        pubkey_modulus_limbs: [u128; 18],\n        redc_params_limbs: [u128; 18],\n        signature_limbs: [u128; 18],\n    ) -> JWT<MAX_DATA_LENGTH> {\n        assert(partial_data.len() <= MAX_DATA_LENGTH, \"partial_data length is too long\");\n\n        JWT {\n            data: partial_data,\n            full_data_length,\n            partial_hash,\n            base64_decode_offset,\n            pubkey_modulus_limbs,\n            redc_params_limbs,\n            signature_limbs,\n            is_partial_hash: true,\n        }\n    }\n\n    /**\n    * @brief Verify JWT signature with RSA 2048/SHA256\n    **/\n    pub fn verify(mut self) {\n        let mut data_hash: [u8; 32] = [0; 32];\n\n        if (!self.is_partial_hash) {\n            // this is a compile time conditional\n            // Hash the data using SHA256\n            data_hash = sha256_var(self.data.storage(), self.data.len() as u64);\n        } else {\n            // Compute the full SHA256 hash with the given partial hash\n            data_hash = partial_sha256_var_end(\n                self.partial_hash,\n                self.data.storage(),\n                self.data.len() as u64,\n                self.full_data_length as u64,\n            );\n        }\n\n        // Verify RSA signature\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(false, self.pubkey_modulus_limbs, self.redc_params_limbs);\n\n        let signature = RuntimeBigNum { params, limbs: self.signature_limbs };\n\n        assert(verify_sha256_pkcs1v15(data_hash, signature, 65537));\n    }\n\n    /**\n    * @brief Get a string claim from the JWT payload\n    *\n    * @param KEY_LENGTH: The length of the claim key\n    * @param MAX_VALUE_LENGTH: The maximum length of the claim value\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        self.get_claim::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key, true)\n    }\n\n    /**\n    * @brief Assert a string claim in the JWT payload.\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_string<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: BoundedVec<u8, MAX_VALUE_LENGTH>,\n    ) {\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> =\n            self.get_claim_string::<KEY_LENGTH, MAX_VALUE_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a number (u64) claim from the JWT payload\n    *        Refer to `get_claim_string` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_number<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> u64 {\n        let claim = self.get_claim::<KEY_LENGTH, 20>(claim_key, false);\n        str_to_u64(claim.storage())\n    }\n\n    /**\n    * @brief Assert a number (u64) claim in the JWT payload.\n    *        Refer to `get_claim_number` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_number<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: u64,\n    ) {\n        let value = self.get_claim_number::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Get a boolean claim from the JWT payload\n    * @param claim_key: The claim key\n    * @return: The claim value\n    **/\n    pub fn get_claim_bool<let KEY_LENGTH: u32>(self, claim_key: [u8; KEY_LENGTH]) -> bool {\n        let value = self.get_claim::<KEY_LENGTH, 5>(claim_key, false);\n        let mut is_true = true;\n        for i in 0..4 {\n            is_true = is_true & (value.storage()[i] == \"true\".as_bytes()[i]);\n        }\n        let is_false = value.storage() == \"false\".as_bytes();\n\n        assert(is_true | is_false, \"incorrect value for claim\");\n        is_true\n    }\n\n    /**\n    * @brief Assert a boolean claim in the JWT payload.\n    *        Refer to `get_claim_bool` for details on the `KEY_LENGTH` and `MAX_VALUE_LENGTH`.\n    * @param claim_key: The claim key\n    * @param claim_value: The claim value to assert\n    **/\n    pub fn assert_claim_bool<let KEY_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        claim_value: bool,\n    ) {\n        let value = self.get_claim_bool::<KEY_LENGTH>(claim_key);\n        assert(value == claim_value, \"incorrect value for claim\");\n    }\n\n    /**\n    * @brief Internal function to get claim bytes from the JWT payload\n    **/\n    fn get_claim<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        claim_key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        //Safety: extract the value in unconstrained mode, and verify later\n        let value: BoundedVec<u8, MAX_VALUE_LENGTH> = unsafe {\n            self.extract_claim_unconstrained::<KEY_LENGTH, MAX_VALUE_LENGTH>(\n                claim_key,\n                is_value_quoted,\n            )\n        };\n\n        // constrain the extracted value is present in the payload using string_search lib\n        // haystack is the base64 decoded payload;\n        let haystack = self.prepare_haystack();\n\n        // needle is the key with quotes around it - searching for just the key string might return false positives from elsewhere\n        // Note: key length is known at compile time as this lib doesn't support runtime keys\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = claim_key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // assert value after quoted key is a colon\n        let colon_index = position + KEY_LENGTH + 2; // +2 for the quotes around the key\n        assert(haystack.body[colon_index] == 58); // :\n\n        // assert the value is correct - string have quotes around them, numbers and booleans don't\n        let mut value_start_index = colon_index + 1; // Value starts after the colon\n        let mut index_after_value = value_start_index + value.len(); // Index after the value, quoted or otherwise\n\n        if (is_value_quoted) {\n            // adjust start index for the quotes around the value\n            value_start_index = value_start_index + 1; // Adjust for the quote before the value\n            index_after_value = index_after_value + 2; // Adjust for the quotes around the value\n\n            // assert the char before and after the value is a quote\n            assert(haystack.body[value_start_index - 1] == 34); // \"\n            assert(haystack.body[index_after_value - 1] == 34); // \"\n        }\n\n        // assert the value is correct\n        for i in 0..MAX_VALUE_LENGTH {\n            if (i < value.len()) {\n                assert(haystack.body[value_start_index + i] == value.storage()[i]);\n            }\n        }\n\n        // assert the char after the value is a comma or a closing brace (last claim in the payload)\n        let char_after_value = haystack.body[index_after_value];\n        assert((char_after_value == 44) | (char_after_value == 125)); // , or }\n\n        value\n    }\n\n    /**\n    * @brief Internal function to prepare the haystack for string search (base64 decoded payload with offset applied)\n    **/\n    fn prepare_haystack(\n        self,\n    ) -> StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> {\n        // We need to decode the payload from the payload_b64_offset; i.e. data.slice(0, base64_decode_offset)\n        let mut data_to_b64_decode: [u8; MAX_DATA_LENGTH] = [0; MAX_DATA_LENGTH];\n\n        // Conditional inside the for loop blows up the constraint size\n        // So we fill the full MAX_DATA_LENGTH (rotate on overflow) and prepare a BoundedVec with the correct length later\n        for i in 0..MAX_DATA_LENGTH {\n            data_to_b64_decode[i] =\n                self.data.storage()[(i + self.base64_decode_offset) % self.data.len()];\n        }\n\n        let data_to_decode_bv: BoundedVec<u8, MAX_DATA_LENGTH> = BoundedVec::from_parts(\n            data_to_b64_decode,\n            self.data.len() - self.base64_decode_offset,\n        );\n\n        // Decode the payload\n        let payload: BoundedVec<u8, ((MAX_DATA_LENGTH / 4) * 3)> =\n            BASE64_URL_DECODER::decode_var(data_to_decode_bv); // b64 decoded length is ceil(MAX_DATA_LENGTH / 3) * 4\n\n        // Create the haystack\n        let haystack: StringBody<((((MAX_DATA_LENGTH / 4) * 3) + 31) / 31) * 31, (((MAX_DATA_LENGTH / 4) * 3) + 31) / 31, ((MAX_DATA_LENGTH / 4) * 3)> =\n            StringBody::new(payload.storage(), payload.len());\n\n        haystack\n    }\n\n    /**\n    * @brief Unconstrained function to extract claim bytes from the JWT payload\n    **/\n    pub unconstrained fn extract_claim_unconstrained<let KEY_LENGTH: u32, let MAX_VALUE_LENGTH: u32>(\n        self,\n        key: [u8; KEY_LENGTH],\n        is_value_quoted: bool,\n    ) -> BoundedVec<u8, MAX_VALUE_LENGTH> {\n        let haystack = self.prepare_haystack();\n\n        let mut key_with_quote: [u8; KEY_LENGTH + 2] = [0; KEY_LENGTH + 2];\n        key_with_quote[0] = 34; // ascii for quote\n        for i in 0..KEY_LENGTH {\n            key_with_quote[i + 1] = key[i];\n        }\n        key_with_quote[KEY_LENGTH + 1] = 34; // ascii for quote\n\n        let mut needle\n            : SubString<(((KEY_LENGTH + 2) + 31) / 31) * 31, (KEY_LENGTH + 2) / 31, (KEY_LENGTH + 2)> =\n            SubString::new(key_with_quote, key_with_quote.len());\n\n        let (result, position): (bool, u32) = haystack.substring_match(needle);\n        assert(result, \"key not found in the payload\");\n\n        // Get the value after the key\n        let mut value_start_idx = position + key.len() + 3; // +3 for the quote around the key and the colon\n        if (is_value_quoted) {\n            value_start_idx += 1; // +1 for the quote before the value\n        }\n\n        let mut value: BoundedVec<u8, MAX_VALUE_LENGTH> = BoundedVec::new();\n\n        for i in 0..MAX_VALUE_LENGTH {\n            let val = haystack.body[value_start_idx + i];\n            if ((val == 34) | (val == 44) | (val == 125)) {\n                break;\n            }\n            value.push(haystack.body[value_start_idx + i]);\n        }\n\n        value\n    }\n}\n\n#[test]\nfn test_verify() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_verify_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n}\n\n#[test]\nfn test_get_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_get_claim_string_partial_hash() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let partial_data: BoundedVec<u8, 256> = BoundedVec::from_array([\n        106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107, 78, 69,\n        77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120, 102, 100,\n        109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85, 115, 73, 109,\n        53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73,\n        122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74, 104, 98, 71, 108,\n        106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115, 73, 109, 108, 104,\n        100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78, 121, 119, 105, 89,\n        88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84, 73, 122, 76, 106,\n        81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86, 52, 99, 67, 73, 54,\n        77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 1;\n    let partial_hash = [\n        2065651337, 2814693704, 862745553, 2384319000, 1412758034, 3553265356, 3156727610,\n        4160738201,\n    ];\n    let full_data_length = 268;\n\n    let jwt = JWT::init_with_partial_hash(\n        partial_data,\n        partial_hash,\n        full_data_length,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email: BoundedVec<u8, 100> = jwt.get_claim_string(\"email\".as_bytes());\n    let expected_email: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    assert(email == expected_email);\n}\n\n#[test]\nfn test_assert_claim_string() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let value: BoundedVec<u8, 100> = BoundedVec::from_array(\"alice@test.com\".as_bytes());\n    jwt.assert_claim_string(\"email\".as_bytes(), value);\n}\n\n#[test]\nfn test_get_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let iat: u64 = jwt.get_claim_number(\"iat\".as_bytes());\n    let expected_iat: u64 = 1737642217;\n    assert(iat == expected_iat);\n}\n\n#[test]\nfn test_assert_claim_number() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let expected_iat: u64 = 1737642217;\n    jwt.assert_claim_number(\"iat\".as_bytes(), expected_iat);\n}\n\n#[test]\nfn test_get_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let email_verified: bool = jwt.get_claim_bool(\"email_verified\".as_bytes());\n    assert(email_verified);\n}\n\n#[test]\nfn test_assert_claim_bool() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    jwt.assert_claim_bool(\"email_verified\".as_bytes(), true);\n}\n\n#[test]\nfn test_get_last_claim() {\n    let pubkey_modulus_limbs = [\n        484791102317025465533947056954494751,\n        689128460766062759582134715581990032,\n        810523707777777878428965619663888709,\n        184404549238669475316963116864788898,\n        93466218048229154672139102341852900,\n        584828628768888069086079532464056431,\n        97425187031931427039620311245463762,\n        26273806718910063326353308419294998,\n        788747954066548540615875263034804664,\n        889704621954975151388848797463892494,\n        311999144542197118282319553447935979,\n        569776388981460921496753063185331362,\n        903966640703701959992132828577771898,\n        159022820921763067563807580152706463,\n        503819859541011037194389727017199051,\n        1078173269124751507098806957834900664,\n        808018922828293630146825008649069450,\n        163,\n    ];\n    let redc_params_limbs = [\n        1143167338325541577958669340190596824,\n        782066667103526839077340987159104121,\n        1067845759344375818181746341911682002,\n        880124617802511701465844415806808588,\n        285259139341669707856057706066903101,\n        1230850420220071595120007854793337041,\n        243441877489860292941608721967510056,\n        821283804950244931298352888469271304,\n        265590023859021620015146340457966193,\n        955602690275722281613949658760787989,\n        704159826142581942518373637894303280,\n        313938418637521056314346970388282852,\n        296174013877567499290252280618882959,\n        127533166408087917092441034792304239,\n        486694435757811118946661778147879193,\n        742440511645057019411661928820777129,\n        106100992772450627263374716203348785,\n        6409,\n    ];\n    let signature_limbs = [\n        782421962573548264472674190647943355,\n        528649442614902878048130358901749842,\n        795671681115216636642039527621785323,\n        342055983261463759066440970886912343,\n        320943042314824191484469254030368420,\n        233931545977215775766660875366648712,\n        166738968145911552289782464945436391,\n        1280090914380823160665554635957223606,\n        225322564371992173705155119766257284,\n        1012067778676730712845356243167441596,\n        337008035250054394089555850701430953,\n        441480997772890594691718538441538925,\n        1266099611422563733802354067242028554,\n        163890419575820619684088542045789366,\n        71236811945264458762129145425586273,\n        106105739687938386497215871288359508,\n        598323717706499880526430558338637686,\n        97,\n    ];\n    let data: BoundedVec<u8, 512> = BoundedVec::from_array([\n        101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122, 73, 49, 78, 105, 73, 115, 73,\n        110, 82, 53, 99, 67, 73, 54, 73, 107, 112, 88, 86, 67, 74, 57, 46, 101, 121, 74, 112, 99,\n        51, 77, 105, 79, 105, 74, 111, 100, 72, 82, 119, 79, 105, 56, 118, 100, 71, 86, 122, 100,\n        67, 53, 106, 98, 50, 48, 105, 76, 67, 74, 122, 100, 87, 73, 105, 79, 105, 74, 66, 81, 107,\n        78, 69, 77, 84, 73, 122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 120,\n        102, 100, 109, 86, 121, 97, 87, 90, 112, 90, 87, 81, 105, 79, 110, 82, 121, 100, 87, 85,\n        115, 73, 109, 53, 118, 98, 109, 78, 108, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73,\n        122, 77, 84, 73, 122, 73, 105, 119, 105, 90, 87, 49, 104, 97, 87, 119, 105, 79, 105, 74,\n        104, 98, 71, 108, 106, 90, 85, 66, 48, 90, 88, 78, 48, 76, 109, 78, 118, 98, 83, 73, 115,\n        73, 109, 108, 104, 100, 67, 73, 54, 77, 84, 99, 122, 78, 122, 89, 48, 77, 106, 73, 120, 78,\n        121, 119, 105, 89, 88, 86, 107, 73, 106, 111, 105, 77, 84, 73, 122, 77, 84, 73, 122, 77, 84,\n        73, 122, 76, 106, 81, 49, 78, 106, 81, 49, 78, 106, 81, 49, 78, 105, 73, 115, 73, 109, 86,\n        52, 99, 67, 73, 54, 77, 84, 99, 53, 79, 84, 107, 53, 79, 84, 107, 53, 79, 88, 48,\n    ]);\n    let base64_decode_offset = 37;\n\n    let jwt = JWT::init(\n        data,\n        base64_decode_offset,\n        pubkey_modulus_limbs,\n        redc_params_limbs,\n        signature_limbs,\n    );\n\n    jwt.verify();\n\n    let exp: u64 = jwt.get_claim_number(\"exp\".as_bytes()); // exp is the last claim in the test payload\n    let expected_exp: u64 = 1799999999;\n    assert(exp == expected_exp);\n}\n","path":"/Users/lancelot/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/lib.nr"},"52":{"source":"// Copied form https://raw.githubusercontent.com/zkemail/zkemail.nr/refs/heads/main/lib/src/partial_hash.nr\n// Use dependency one zkemail.nr is updated to bignum 0.6.0\n\nuse std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L23\n// Convert 64-byte array to array of 16 u32s\npub fn msg_u8_to_u32(msg: [u8; BLOCK_SIZE]) -> [u32; 16] {\n    let mut msg32: [u32; 16] = [0; 16];\n\n    for i in 0..16 {\n        let mut msg_field: Field = 0;\n        for j in 0..4 {\n            msg_field = msg_field * 256 + msg[64 - 4 * (i + 1) + j] as Field;\n        }\n        msg32[15 - i] = msg_field as u32;\n    }\n\n    msg32\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L38\nunconstrained fn build_msg_block_iter<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n    for k in 0..block_input {\n        msg_block[k] = msg[msg_start + k];\n    }\n    (msg_block, block_input)\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L59\n// Verify the block we are compressing was appropriately constructed\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: [u8; 64],\n    msg_start: u32,\n) -> u32 {\n    let mut msg_byte_ptr: u32 = 0; // Message byte pointer\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n\n    for k in msg_start..msg_end {\n        if k < message_size {\n            assert_eq(msg_block[msg_byte_ptr], msg[k]);\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\nglobal BLOCK_SIZE: u32 = 64;\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L86-L116\n/**\n * Partially computes a SHA256 hash of a message but does not finalize\n * @notice can be used for post-partial hashing where client proves part of hash and relies on server to finish\n * \n *\n * @param N: the length of the message to hash.\n *  --- WARNING: N must be divisible by BLOCK_SIZE such that N % BLOCK_SIZE == 0 \n *      otherwise the remaining bytes will not be inputted when computing the initial hash\n * @param msg: the preimage to begin hashing\n * @return the intermediate hash state\n */\npub fn partial_sha256_var_start<let N: u32>(msg: [u8; N]) -> [u32; 8] {\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut h: [u32; 8] = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ]; // Intermediate hash, starting with the canonical initial value\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) = unsafe { build_msg_block_iter(msg, N, msg_start) };\n        if msg_start < N {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, N, msg_block, msg_start);\n            if msg_start < N {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < N {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < N) & (msg_byte_ptr == BLOCK_SIZE) & (msg_start < message_size) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    h\n}\n\n// https://github.com/noir-lang/noir/blob/76eec710ff73e5e45fdddcd41ae2cd74e879cfa5/noir_stdlib/src/hash/sha256.nr#L85\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the remaining preimage\n * @param real_message_size -= the total size of the preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u64,\n    real_message_size: u64,\n) -> [u8; 32] {\n    let message_size = message_size as u32; // noir stdlib uses u64\n    let real_message_size = real_message_size as u32; // noir stdlib uses u64\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: [u8; BLOCK_SIZE] = [0; BLOCK_SIZE];\n    let mut msg_byte_ptr = 0; // Pointer into msg_block\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_u8_to_u32(msg_block), h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block_iter(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    msg_block[msg_byte_ptr] = 1 << 7;\n    let last_block = msg_block;\n    msg_byte_ptr = msg_byte_ptr + 1;\n\n    unsafe {\n        let (new_msg_block, new_msg_byte_ptr) = pad_msg_block(msg_block, msg_byte_ptr);\n        msg_block = new_msg_block;\n        if is_unconstrained() {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    if !is_unconstrained() {\n        for i in 0..64 {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n\n        // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n        // the 1 and 0s fill up the current block, which we then compress accordingly.\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for _i in 57..64 {\n            if msg_byte_ptr <= 63 & msg_byte_ptr >= 57 {\n                assert_eq(msg_block[msg_byte_ptr], zero);\n                msg_byte_ptr += 1;\n            }\n        }\n    }\n\n    if msg_byte_ptr >= 57 {\n        h = sha256_compression(msg_u8_to_u32(msg_block), h);\n\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, real_message_size) };\n\n    if !is_unconstrained() {\n        for i in 0..56 {\n            if i < msg_byte_ptr {\n                assert_eq(msg_block[i], last_block[i]);\n            } else {\n                assert_eq(msg_block[i], zero);\n            }\n        }\n\n        let len = 8 * real_message_size;\n        let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n        for i in 56..64 {\n            assert_eq(msg_block[i], len_bytes[i - 56]);\n        }\n    }\n\n    hash_final_block(msg_block, h)\n}\n\nunconstrained fn pad_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n) -> ([u8; BLOCK_SIZE], u32) {\n    // If i >= 57, there aren't enough bits in the current message block to accomplish this, so\n    // the 1 and 0s fill up the current block, which we then compress accordingly.\n    if msg_byte_ptr >= 57 {\n        // Not enough bits (64) to store length. Fill up with zeros.\n        for i in msg_byte_ptr..BLOCK_SIZE {\n            msg_block[i] = 0;\n        }\n        (msg_block, BLOCK_SIZE)\n    } else {\n        (msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: [u8; BLOCK_SIZE],\n    mut msg_byte_ptr: u32,\n    message_size: u32,\n) -> [u8; BLOCK_SIZE] {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 (i.e. until msg_byte_ptr = 56).\n    for i in msg_byte_ptr..56 {\n        msg_block[i] = 0;\n    }\n\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..8 {\n        msg_block[56 + i] = len_bytes[i];\n    }\n    msg_block\n}\n\nfn hash_final_block(msg_block: [u8; BLOCK_SIZE], mut state: [u32; 8]) -> [u8; 32] {\n    let mut out_h: [u8; 32] = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_u8_to_u32(msg_block), state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[7 - j] as Field).to_le_bytes();\n        for k in 0..4 {\n            out_h[31 - 4 * j - k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n","path":"/Users/lancelot/nargo/github.com/zkemail/noir-jwt/saleel/deps-update-beta11/src/partial_hash.nr"},"54":{"source":"unconstrained fn __boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    let mut r: [Field; Range] = [0; Range];\n    for i in limit..Range {\n        r[i] = 1;\n    }\n    r\n}\n\n/**\n * @brief Return a size-Range array of values that describe whether an index `i` is in the range `0<=i<limit`\n * @details When evaluating variable-length loops of size `limit`, it is neccessary to iterate over a maximum bound defined at compile-time\n *          Any constraints or evaluations that occur where `i >= limit` must be discarded.\n *          This is most efficiently performed by using predicate `Field` values, where `predicate[i] = 0` if `i < limit`, otherwise `predicate[i] = 1`.\n *          This method efficiently generates such predicate values more efficiently than querying whether `i <= limit` at every iteration.\n *          Gate cost is 3 * Range\n **/\npub fn boundary_check<let Range: u32>(limit: u32) -> [Field; Range] {\n    // Safety: r contains claims about whether `r[i] >= limit`. the rest of this function checks this claim is correct\n    let r = unsafe { __boundary_check(limit) };\n\n    let mut transition_index = 0;\n    // **\n    // We have an array of Field elements `r` such that:\n    // if i < limit, `r = 0`\n    // if i >= limit, `r = 1`\n    // We validate the predicate list `r` is correct by checking:\n    // 1. every r[i] element is 0 or 1\n    // 2. if r[i] = 1, r[i+1] must also be 1\n    // 3. if r[i] = 0 and r[i+1] = 1, then i == limit\n    // we check point 3 by tracking a `transition_index` variable, where\n    // transition_index += (1 - r[i]) * (r[i+1]) * i\n    // i.e. if r[i] == 0 and r[i+1] == 1, transition_index += i\n    //      else transition_index += 0\n    // NOTE: total constraint cost is 3 gates per iteration\n    // **\n    if Range > 0 {\n        for i in 0..Range - 1 {\n            assert_eq(r[i] * r[i], r[i]);\n            assert_eq(r[i] * r[i + 1], r[i]);\n            let idx = (r[i + 1] * (1 - r[i])) * (i as Field + 1);\n            transition_index = transition_index + idx;\n            std::as_witness(transition_index);\n        }\n        assert_eq(r[Range - 1] * r[Range - 1], r[Range - 1]);\n        transition_index = transition_index + (1 - r[Range - 1]) * limit as Field;\n        assert(transition_index == limit as Field);\n        r\n    } else {\n        [0; Range]\n    }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/boundary_check.nr"},"55":{"source":"use super::defaults::{\n    BASE64_ELEMENTS_PER_CHUNK, BASE64_PADDING_CHAR, BYTES_PER_CHUNK, INVALID_DECODE_VALUE,\n};\n\npub use crate::boundary_check::boundary_check;\nuse crate::tables::{\n    BASE64_DECODE_BE_TABLE, BASE64_DECODE_BE_URL_TABLE, BASE64_DECODE_BE_URL_VAR_TABLE,\n    BASE64_DECODE_BE_VAR_TABLE,\n};\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4)\npub mod Base64DecodeBE {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 0>(input)\n    }\n}\n\n/// Decoder methods that use the standard Base64 Alphabet (base64) specified in RFC 4648\n/// (https://datatracker.ietf.org/doc/html/rfc4648#section-4), but WITHOUT padding\npub mod Base64DecodeBENoPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 0>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 0>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5\npub mod Base64DecodeBEUrlSafe {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 0, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 0, 1>(input)\n    }\n}\n\n/// Decoder methods that use the URL and Filename Safe Alphabet specified in RFC 4648\n/// https://datatracker.ietf.org/doc/html/rfc4648#section-5, but WITH padding added\npub mod Base64DecodeBEUrlSafeWithPad {\n    pub fn decode<let InputBytes: u32, let OutputBytes: u32>(\n        input: [u8; InputBytes],\n    ) -> [u8; OutputBytes] {\n        crate::decoder::decode::<InputBytes, OutputBytes, 1, 1>(input)\n    }\n\n    pub fn decode_var<let MaxInputBytes: u32, let MaxOutputBytes: u32>(\n        input: BoundedVec<u8, MaxInputBytes>,\n    ) -> BoundedVec<u8, MaxOutputBytes> {\n        crate::decoder::decode_var::<MaxInputBytes, MaxOutputBytes, 1, 1>(input)\n    }\n}\n\n/**\n * @brief Return a human-readable error if the input is invalid Base64\n * @details We constrain the decoding to be correct by using a lookup table to decode Base64.\n *          Validation is performed by batch-checking that no lookups returned an error state.\n *          This produces unhelpful error messages so we put this sanitised check in an unconstrained fn\n **/\nunconstrained fn __validate_decoded(decoded: Field, input_byte: u8, offset: u32) {\n    assert(\n        decoded != INVALID_DECODE_VALUE,\n        f\"DecodeError: invalid symbol {input_byte}, offset {offset}.\",\n    );\n}\n\n/**\n * @brief Given a variable-sized number of Base64 encoded characters, return a *claim* about how many are padding chars\n * @note The returned value is only a claim and must be validated\n **/\nunconstrained fn __get_num_padding_chars_var<let InputElements: u32>(\n    input: BoundedVec<u8, InputElements>,\n) -> (bool, bool) {\n    let len = input.len();\n    let r1 = if len > 1 {\n        input.get(len - 2) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    let r2 = if len > 0 {\n        input.get(len - 1) == BASE64_PADDING_CHAR\n    } else {\n        false\n    };\n    (r1, r2)\n}\n\n/**\n * @brief Take an array of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\nfn decode<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: [u8; InputElements],\n) -> [u8; OutputBytes] {\n    let rem = OutputBytes % 3;\n    // Calculate the number of padding characters and the length of the input without padding\n    let num_padding_chars = if rem == 1 {\n        2\n    } else if rem == 2 {\n        1\n    } else {\n        0\n    };\n\n    // Assert that the output length & input length are correct\n    // Every 3 output chars will be encoded as 4 base64 input chars\n    let encoded_length = (OutputBytes + 2) / 3 * 4; // ceil(input * 4 / 3)\n    if Pad != 0 {\n        assert(\n            encoded_length == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {encoded_length} input elements, but got {InputElements}.\",\n        );\n        // enforce Base64 padding is valid\n        if num_padding_chars == 2 {\n            let offset = InputElements - 1;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n            let offset = InputElements - 2;\n            assert(\n                input[offset] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        } else if num_padding_chars == 1 {\n            let offset = InputElements - 1;\n            assert(\n                input[InputElements - 1] == BASE64_PADDING_CHAR,\n                f\"DecodeError: expected padding at offset {offset}.\",\n            );\n        }\n    } else {\n        let expected = encoded_length - num_padding_chars;\n        assert(\n            encoded_length - num_padding_chars == InputElements,\n            f\"DecodeError: invalid input length for specified output length. Expected {expected} input elements, but got {InputElements}.\",\n        );\n    }\n\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n    let num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    // validity_check = accumulator value that we add every output from BASE64_DECODE_BE_TABLE into.\n    // Invalid error states will return a lookup value of -2^32 , which will cause `validity_check` to fail a 32-bit range check.\n    // This batch-validation technique is more efficient than asserting every returned token is valid.\n    let mut validity_check: Field = 0;\n    if num_chunks > 0 {\n        let final_chunk = num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte: u8 = input[offset];\n                let index = input_byte as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_TABLE[index]\n                } else {\n                    BASE64_DECODE_BE_TABLE[index]\n                };\n                validity_check += decoded;\n                slice += decoded as Field;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n\n        // process the final chunk, which may contain padding\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        let base64_elements_in_final_chunk = if Pad != 0 {\n            InputElements - base64_offset - num_padding_chars\n        } else {\n            InputElements - base64_offset\n        };\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte: u8 = input[offset];\n            let index = input_byte as u32;\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_TABLE[index]\n            } else {\n                BASE64_DECODE_BE_TABLE[index]\n            };\n            validity_check += decoded;\n            slice += decoded as Field;\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n        }\n\n        // If any lookups returned an error state, this 32-bit range check will fail.\n        validity_check.assert_max_bit_size::<32>();\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Take a variable-length vector of Base64 values and convert back into ASCII\n *        Each Base64 value is 6 bits. This method will produce a byte array where data is concatenated so that there are no sparse bits\n *        (e.g. encoding 4 ASCII values produces 24 bits of Base64 data = 3 bytes of output data)\n **/\npub fn decode_var<let InputElements: u32, let OutputBytes: u32, let Pad: u1, let UseURLTable: u1>(\n    input: BoundedVec<u8, InputElements>,\n) -> BoundedVec<u8, OutputBytes> {\n    // We don't know how many padding bytes the input string contains - we use an unconstrained fn to return a *claim* that we will later validate\n    let (has_first_padding_byte_claim, has_second_padding_byte_claim) = if (Pad == 1) {\n        // Safety: get claims about whether the bytes input[input.len() - 2] and input[input.len() - 1] are padding chars\n        // we validate this later on by requiring these characters equal BASE64_PADDING_CHAR by looking up BASE64_DECODE_BE_VAR_TABLE\n        unsafe {\n            crate::decoder::__get_num_padding_chars_var::<InputElements>(input)\n        }\n    } else {\n        (false, false)\n    };\n\n    // num_padding_chars is a claim that depends on has_first_padding_byte_claim and has_second_padding_byte_claim being correct\n    let num_padding_chars: u32 = if Pad == 1 {\n        has_first_padding_byte_claim as u32 + has_second_padding_byte_claim as u32\n    } else {\n        0\n    };\n\n    let input_length = input.len();\n    let input = input.storage();\n\n    // boundary_flags = array of Field elements.\n    // if `i < input_length, boundary_flags[i] = 0`\n    // if `i >= input_length, boundary_flags[i+1] = 1`\n    // used as cheap(ish) predicates when iterating over bounded vector elements\n    let boundary_flags: [Field; InputElements] = boundary_check(input_length);\n    let mut result: [u8; OutputBytes] = [0; OutputBytes];\n\n    let max_num_chunks = (InputElements / BASE64_ELEMENTS_PER_CHUNK)\n        + (InputElements % BASE64_ELEMENTS_PER_CHUNK != 0) as u32;\n\n    let mut validity_check: Field = 0;\n    // if statement should be known at compile time\n    if max_num_chunks > 0 {\n        let final_chunk: u32 = max_num_chunks - 1;\n\n        for i in 0..final_chunk {\n            let mut slice: Field = 0;\n            for j in 0..BASE64_ELEMENTS_PER_CHUNK {\n                slice *= 64;\n                let offset = i * BASE64_ELEMENTS_PER_CHUNK + j;\n                let input_byte = input[offset];\n\n                let mut decode_index: Field = 0;\n                if Pad == 1 {\n                    let mut might_be_second_padding_char = 0;\n                    let mut might_be_first_padding_char = 0;\n                    // These if statements should not cost extra gates as the condition is known at compile time\n                    if (offset + 2 < InputElements) {\n                        might_be_first_padding_char = (1 - boundary_flags[offset])\n                            * (1 - boundary_flags[offset + 1])\n                            * boundary_flags[offset + 2];\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else if (offset + 1 < InputElements) {\n                        // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                        might_be_first_padding_char =\n                            (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                        might_be_second_padding_char =\n                            (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                    } else // last character\n                    {\n                        might_be_first_padding_char = 0;\n                        might_be_second_padding_char = (1 - boundary_flags[offset]);\n                    }\n\n                    // Cases where we need to require a padding character is present:\n                    // Case 1: we are at byte position `input.len() - 2` and `has_first_padding_byte_claim = true`\n                    // Case 2: we are at byte position `input.len() - 1` and `has_second_padding_byte_claim = true`\n                    let require_padding = might_be_first_padding_char\n                        * has_first_padding_byte_claim as Field\n                        + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n\n                    // The `decode_index` is used to map the input Base64 character into an output decoded character.\n                    // We know `input_byte` is in the range 0-255 , so we use a size 768 lookup to handle the following 3 cases:\n                    // Case 1 (index range 0-255): No special cases. We decode the Base64 ASCII char into an ASCII char\n                    // Case 2 (index range 256-511): We have exceeded the length of the input. The only valid input is 0, which decodes to 0 (all other byte values return an error state)\n                    // Case 3 (index range 512-767): A claim has been made that a padding byte is present, and we are at the appropriate byte location to check this.\n                    //                               The only valid input is BASE64_PADDING_CHAR, which decodes to 0. All other inputs return an error state\n                    decode_index =\n                        input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n                } else {\n                    decode_index = input_byte as Field + boundary_flags[offset] * 256;\n                }\n                decode_index.assert_max_bit_size::<32>();\n                let decode_index = decode_index as u32;\n                let decoded = if UseURLTable == 1 {\n                    BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n                } else {\n                    BASE64_DECODE_BE_VAR_TABLE[decode_index]\n                };\n\n                validity_check += decoded;\n                slice += decoded;\n                // Safety: get a sensible error message out if the decoding is invalid.\n                // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n                // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n                // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n                // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n                unsafe {\n                    __validate_decoded(decoded, input_byte, offset);\n                }\n            }\n            // convert the decoded slice into bytes and populate result array\n            let slice_bytes: [u8; 30] = slice.to_be_bytes();\n            for j in 0..BYTES_PER_CHUNK {\n                result[i * BYTES_PER_CHUNK + j] = slice_bytes[j];\n            }\n        }\n        // process the final chunk\n        let base64_offset: u32 = final_chunk * BASE64_ELEMENTS_PER_CHUNK;\n        let byte_offset = final_chunk * BYTES_PER_CHUNK;\n        // might include padding characters\n        let base64_elements_in_final_chunk = InputElements - base64_offset;\n\n        // pack the base64 values into the field element\n        let mut slice: Field = 0;\n        for j in 0..base64_elements_in_final_chunk {\n            slice *= 64;\n            let offset = base64_offset + j;\n            let input_byte = input[offset];\n\n            let mut decode_index: Field = 0;\n            if Pad == 1 {\n                let mut might_be_second_padding_char = 0;\n                let mut might_be_first_padding_char = 0;\n                // These if statements should not cost extra gates as the condition is known at compile time\n                if (offset + 2 < InputElements) {\n                    might_be_first_padding_char = (1 - boundary_flags[offset])\n                        * (1 - boundary_flags[offset + 1])\n                        * boundary_flags[offset + 2];\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else if (offset + 1 < InputElements) {\n                    // might_be_second_padding_char = (1 - boundary_flags[offset]) + (boundary_flags[offset + 1]);\n                    might_be_first_padding_char =\n                        (1 - boundary_flags[offset]) * (1 - boundary_flags[offset + 1]);\n                    might_be_second_padding_char =\n                        (1 - boundary_flags[offset]) * (boundary_flags[offset + 1]);\n                } else // last character\n                {\n                    might_be_first_padding_char = 0;\n                    might_be_second_padding_char = (1 - boundary_flags[offset]);\n                }\n\n                let require_padding = might_be_first_padding_char\n                    * has_first_padding_byte_claim as Field\n                    + (might_be_second_padding_char * has_second_padding_byte_claim as Field);\n                decode_index =\n                    input_byte as Field + boundary_flags[offset] * 256 + require_padding * 512;\n            } else {\n                decode_index = input_byte as Field + boundary_flags[offset] * 256;\n            }\n            decode_index.assert_max_bit_size::<32>();\n            let decode_index = decode_index as u32;\n\n            let decoded = if UseURLTable == 1 {\n                BASE64_DECODE_BE_URL_VAR_TABLE[decode_index]\n            } else {\n                BASE64_DECODE_BE_VAR_TABLE[decode_index]\n            };\n            // Safety: get a sensible error message out if the decoding is invalid.\n            // Note that we *constrain* the encoding is correct by performing a range check on `validity_check`\n            // If the decoding is invalid, `decoded = -2^{32}`. We add up all `decoded` values and apply a 32-bit range check.\n            // Given all valid encodings are 8-bit, as long as the input length is less than 2^24 bytes, it is not possible to\n            // underflow validity_check with an invalid encoding, and then overflow again by adding up valid encodings\n            unsafe {\n                __validate_decoded(decoded, input_byte, offset);\n            }\n            validity_check += decoded;\n            slice += decoded as Field;\n        }\n\n        validity_check.assert_max_bit_size::<32>();\n\n        for _ in base64_elements_in_final_chunk..BASE64_ELEMENTS_PER_CHUNK {\n            slice *= 64;\n        }\n\n        let slice_bytes: [u8; 30] = slice.to_be_bytes();\n        let num_bytes_in_final_chunk = OutputBytes - byte_offset;\n        for i in 0..num_bytes_in_final_chunk {\n            result[byte_offset + i] = slice_bytes[i];\n        }\n    }\n\n    if Pad == 1 {\n        assert(input_length % 4 == 0, \"base64 encoded strings must be a multiple of 4 bytes\");\n    }\n\n    if has_first_padding_byte_claim {\n        assert(has_second_padding_byte_claim, \"if first byte contains padding so must the second\");\n    }\n    let output_length = ((input_length * 3) / 4) - num_padding_chars;\n    BoundedVec::from_parts_unchecked(result, output_length)\n}\n\n#[test]\nfn test_decode_empty() {\n    let input: [u8; 0] = [];\n    let expected: [u8; 0] = [];\n    let result = Base64DecodeBE::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_padding() {\n    // f\n    let input: [u8; 4] = [90, 103, 61, 61];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 4] = [90, 109, 56, 61];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard_no_pad() {\n    // f\n    let input: [u8; 2] = [90, 103];\n    let expected: [u8; 1] = [102];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // fo\n    let input: [u8; 3] = [90, 109, 56];\n    let expected: [u8; 2] = [102, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: [u8; 4] = [90, 109, 57, 118];\n    let expected: [u8; 3] = [102, 111, 111];\n    let result = Base64DecodeBENoPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_max_byte() {\n    let expected: [u8; 1] = [255];\n\n    let input: [u8; 4] = [47, 119, 61, 61]; // \"/w==\"\n    let result: [u8; 1] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [47, 119]; // \"/w\"\n    let result: [u8; 1] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 4] = [95, 119, 61, 61]; // \"_w==\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 2] = [95, 119]; // \"_w\"\n    let result: [u8; 1] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 255, offset 0\")]\nfn test_decode_invalid() {\n    let input: [u8; 2] = [255, 255];\n    let _: [u8; 1] = Base64DecodeBENoPad::decode(input);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_standard_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_standard() {\n    // test decoding / and +\n    let input: [u8; 4] = [47, 43, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBE::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 95, offset 0\")]\nfn test_decode_underscore_with_standard() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let _: [u8; 2] = Base64DecodeBE::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe_with_pad() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafeWithPad::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 47, offset 0\")]\nfn test_decode_slash_with_url_safe() {\n    // test decoding / and +\n    let input: [u8; 3] = [47, 43, 65];\n    let _: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n}\n\n#[test]\nfn test_decode_url_safe() {\n    // test decoding _ and -\n    let input: [u8; 3] = [95, 45, 65];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid input length for specified output length. Expected 3 input elements, but got 4.\")]\nfn test_decode_url_safe_no_pad_fail_with_padding() {\n    // test decoding _ and -\n    let input: [u8; 4] = [95, 45, 65, 61];\n    let expected: [u8; 2] = [255, 224];\n    let result: [u8; 2] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_ascii() {\n    // base64: SGVsbG8gV29ybGQh\n    let input: [u8; 16] = [83, 71, 86, 115, 98, 71, 56, 103, 86, 50, 57, 121, 98, 71, 81, 104];\n    // \"Hello World!\"\n    let expected: [u8; 12] = [72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100, 33];\n\n    // all configurations should decode the same way\n    let result: [u8; 12] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 12] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_utf8() {\n    // base64: 44GT44KT44Gr44Gh44Gv44CB5LiW55WM77yB\n    let input: [u8; 36] = [\n        52, 52, 71, 84, 52, 52, 75, 84, 52, 52, 71, 114, 52, 52, 71, 104, 52, 52, 71, 118, 52, 52,\n        67, 66, 53, 76, 105, 87, 53, 53, 87, 77, 55, 55, 121, 66,\n    ];\n    // non-ascii utf-8: \"Hello, World!\" in Japanese\n    let expected: [u8; 27] = [\n        227, 129, 147, 227, 130, 147, 227, 129, 171, 227, 129, 161, 227, 129, 175, 227, 128, 129,\n        228, 184, 150, 231, 149, 140, 239, 188, 129,\n    ];\n\n    // all configurations should decode the same way\n    let result: [u8; 27] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafeWithPad::decode(input);\n    assert(result == expected);\n    let result: [u8; 27] = Base64DecodeBEUrlSafe::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_multi_chunks() {\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: [u8; 44] = [\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ];\n\n    let input: [u8; 60] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ];\n    let result: [u8; 44] = Base64DecodeBE::decode(input);\n    assert(result == expected);\n\n    let input: [u8; 59] = [\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ];\n    let result = Base64DecodeBENoPad::decode(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_with_padding() {\n    // Raw bh: GxMlgwLiypnVrE2C0Sf4yzhcWTkAhSZ5+WERhKhXtlU=\n    // Translated directly to ASCII\n    let input: [u8; 44] = [\n        71, 120, 77, 108, 103, 119, 76, 105, 121, 112, 110, 86, 114, 69, 50, 67, 48, 83, 102, 52,\n        121, 122, 104, 99, 87, 84, 107, 65, 104, 83, 90, 53, 43, 87, 69, 82, 104, 75, 104, 88, 116,\n        108, 85, 61,\n    ];\n\n    let result: [u8; 32] = Base64DecodeBE::decode(input);\n    let expected: [u8; 32] = [\n        27, 19, 37, 131, 2, 226, 202, 153, 213, 172, 77, 130, 209, 39, 248, 203, 56, 92, 89, 57, 0,\n        133, 38, 121, 249, 97, 17, 132, 168, 87, 182, 85,\n    ];\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_empty() {\n    let input: BoundedVec<u8, 0> = BoundedVec::new();\n    let expected: BoundedVec<u8, 0> = BoundedVec::new();\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_padding() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103, 61, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBE::decode_var(input);\n    println(f\"result {result}\");\n    println(f\"expected {expected}\");\n\n    assert(result == expected);\n\n    // fo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 8> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 6> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBE::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_standard_no_pad() {\n    // f\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 103]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    // fo\n    println(f\"result {result}, expected {expected}\");\n\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 56]);\n\n    assert(result == expected);\n\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n\n    // foo\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([90, 109, 57, 118]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([102, 111, 111]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n\n    assert(result == expected);\n}\n\n#[test(should_fail_with = \"DecodeError: invalid symbol 61, offset 3\")]\nfn test_decode_var_no_pad_fail_with_padding() {\n    // test decoding / and +\n    let input: BoundedVec<u8, 4> = BoundedVec::from_array([47, 43, 65, 61]);\n    let expected: BoundedVec<u8, 3> = BoundedVec::from_array([255, 224]);\n    let result = Base64DecodeBENoPad::decode_var(input);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var() {\n    // base64: \"SGVsbG8sIFdvcmxkIQ==\"\n    let input: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81, 61, 61,\n    ]);\n    // base64: \"SGVsbG8sIFdvcmxkIQ\"\n    let input_no_pad: BoundedVec<u8, 24> = BoundedVec::from_array([\n        83, 71, 86, 115, 98, 71, 56, 115, 73, 70, 100, 118, 99, 109, 120, 107, 73, 81,\n    ]);\n    // \"Hello, World!\"\n    let expected: BoundedVec<u8, 16> =\n        BoundedVec::from_array([72, 101, 108, 108, 111, 44, 32, 87, 111, 114, 108, 100, 33]);\n\n    // all configurations should decode the same way\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    println(f\"result {result}, expected {expected}\");\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n\n#[test]\nfn test_decode_var_multi_chunks() {\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52, 61,\n    ]);\n    // base64: \"VGhlIHF1aWNrIGJyb3duIGZveCBqdW1wcyBvdmVyIHRoZSBsYXp5IGRvZy4=\"\n    let input_no_pad: BoundedVec<u8, 64> = BoundedVec::from_array([\n        86, 71, 104, 108, 73, 72, 70, 49, 97, 87, 78, 114, 73, 71, 74, 121, 98, 51, 100, 117, 73,\n        71, 90, 118, 101, 67, 66, 113, 100, 87, 49, 119, 99, 121, 66, 118, 100, 109, 86, 121, 73,\n        72, 82, 111, 90, 83, 66, 115, 89, 88, 112, 53, 73, 71, 82, 118, 90, 121, 52,\n    ]);\n    // \"The quick brown fox jumps over the lazy dog.\"\n    let expected: BoundedVec<u8, 48> = BoundedVec::from_array([\n        84, 104, 101, 32, 113, 117, 105, 99, 107, 32, 98, 114, 111, 119, 110, 32, 102, 111, 120, 32,\n        106, 117, 109, 112, 115, 32, 111, 118, 101, 114, 32, 116, 104, 101, 32, 108, 97, 122, 121,\n        32, 100, 111, 103, 46,\n    ]);\n\n    // all configurations should give the same encoding\n    let result = Base64DecodeBE::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBENoPad::decode_var(input_no_pad);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafeWithPad::decode_var(input);\n    assert(result == expected);\n    let result = Base64DecodeBEUrlSafe::decode_var(input_no_pad);\n    assert(result == expected);\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir_base64/v0.4.2/src/decoder.nr"},"94":{"source":"use crate::constants::TWO_POW_120;\nuse crate::fns::{\n    expressions::evaluate_quadratic_expression,\n    unconstrained_helpers::{\n        __add_with_flags, __from_field, __neg_with_flags, __sub_with_flags, __validate_gt_remainder,\n        __validate_in_field_compute_borrow_flags,\n    },\n    unconstrained_ops::{__add, __div, __mul, __neg, __sub, __udiv_mod},\n};\nuse crate::params::BigNumParams as P;\nuse std::cmp::Ordering;\n\n/**\n * In this file:\n *\n * conditional_select\n * assert_is_not_equal\n * eq\n * validate_in_field\n * validate_in_range\n * validate_quotient_in_range\n * validate_gt\n * neg\n * add\n * sub\n * mul\n * div\n * udiv_mod\n * udiv\n * umod\n * gt \n * check_gt_with_flags\n */\n\npub(crate) fn limbs_to_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    limbs: [u128; N],\n) -> Field {\n    if N > 2 {\n        // validate that the limbs is less than the modulus the grumpkin modulus\n        let mut grumpkin_modulus = [0; N];\n        grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n        grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n        grumpkin_modulus[2] = 0x3064;\n        validate_gt::<N, MOD_BITS>(grumpkin_modulus, limbs);\n        // validate that the limbs are in range\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n    }\n    // validate the limbs sum up to the field value\n    if N < 2 {\n        limbs[0] as Field\n    } else if N == 2 {\n        validate_in_range::<_, N, MOD_BITS>(limbs);\n        (limbs[0] + limbs[1] * TWO_POW_120) as Field\n    } else {\n        // validate_in_range::<N, 254>(limbs);\n        (\n            limbs[0] as Field\n                + limbs[1] as Field * TWO_POW_120 as Field\n                + limbs[2] as Field * TWO_POW_120 as Field * TWO_POW_120 as Field\n        )\n    }\n}\n\npub(crate) fn from_field<let N: u32, let MOD_BITS: u32>(\n    _params: P<N, MOD_BITS>,\n    field: Field,\n) -> [u128; N] {\n    // Safety: we check that the resulting limbs represent the intended field element\n    // we check the bit length, the limbs being max 120 bits, and the value in total is less than the field modulus\n    let result: [u128; N] = unsafe { __from_field::<N>(field) };\n    if !std::runtime::is_unconstrained() {\n        // validate the limbs are in range and the value in total is less than 2^254\n        let mut grumpkin_modulus = [0; N];\n        if N > 2 {\n            grumpkin_modulus[0] = 0x33e84879b9709143e1f593f0000001;\n            grumpkin_modulus[1] = 0x4e72e131a029b85045b68181585d28;\n            grumpkin_modulus[2] = 0x3064;\n        }\n        if MOD_BITS > 253 {\n            // this means that the field modulus is larger than grumpkin modulus so we have to check if the element fields in the field size are less than the grumpkin modulus.\n            // also for correct params N is always larger than 3 here\n            validate_gt::<N, MOD_BITS>(grumpkin_modulus, result);\n        } else if MOD_BITS < 253 {\n            // this means that the field modulus is smaller than grumpkin modulus so we have to check if the element fields in the field size\n            validate_in_field(_params, result);\n        } else {\n            // this is the tricky part, when MOD_BITS = 253, so we have to compare the limbs of the modulus to the grumpkin modulus limbs\n            // any bignum with 253 bits will have 3 limbs\n\n            // if modulus is larger than grumpkin modulus, this will be true\n            let mut gt_grumpkin = false;\n            for i in 0..3 {\n                if !gt_grumpkin {\n                    if _params.modulus[2 - i] < grumpkin_modulus[2 - i] {\n                        gt_grumpkin = true;\n                    }\n                }\n            }\n            let result_2 = if gt_grumpkin {\n                _params.modulus\n            } else {\n                grumpkin_modulus\n            };\n            validate_gt::<N, MOD_BITS>(result_2, result);\n        }\n\n        // validate the limbs sum up to the field value\n        let TWO_POW_120_FIELD = TWO_POW_120 as Field;\n        let field_val = if N < 2 {\n            result[0] as Field\n        } else if N == 2 {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field + result[1] as Field * TWO_POW_120_FIELD\n        } else {\n            validate_in_range::<_, N, MOD_BITS>(result);\n            result[0] as Field\n                + result[1] as Field * TWO_POW_120_FIELD\n                + result[2] as Field * TWO_POW_120_FIELD * TWO_POW_120_FIELD\n        };\n        assert_eq(field_val, field);\n    }\n\n    result\n}\n\n/**\n* @brief given an input seed, generate a pseudorandom BigNum value\n* @details we hash the input seed into `modulus_bits * 2` bits of entropy,\n* which is then reduced into a BigNum value\n* We use a hash function that can be modelled as a random oracle\n* This function *should* produce an output that is a uniformly randomly distributed value modulo BigNum::modulus()\n**/\n\npub(crate) fn derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let mut rolling_seed: [u8; SeedBytes + 1] = [0; SeedBytes + 1];\n    for i in 0..SeedBytes {\n        rolling_seed[i] = seed[i];\n        assert_eq(rolling_seed[i], seed[i]);\n    }\n\n    let mut hash_buffer: [u8; N * 2 * 15] = [0; N * 2 * 15];\n\n    let mut rolling_hash_fields: [Field; (SeedBytes / 31) + 1] = [0; (SeedBytes / 31) + 1];\n    let mut seed_ptr = 0;\n    for i in 0..(SeedBytes / 31) + 1 {\n        let mut packed: Field = 0;\n        for _ in 0..31 {\n            if (seed_ptr < SeedBytes) {\n                packed *= 256;\n                packed += seed[seed_ptr] as Field;\n                seed_ptr += 1;\n            }\n        }\n        rolling_hash_fields[i] = packed;\n    }\n\n    let compressed =\n        poseidon::poseidon2::Poseidon2::hash(rolling_hash_fields, (SeedBytes / 31) + 1);\n    let mut rolling_hash: [Field; 2] = [compressed, 0];\n\n    let num_hashes = (240 * N) / 254 + (((30 * N) % 32) != 0) as u32;\n    for i in 0..num_hashes - 1 {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        for j in 0..30 {\n            hash_buffer[i * 30 + j] = hash[j];\n        }\n        rolling_hash[1] += 1;\n    }\n\n    {\n        let hash: Field = poseidon::poseidon2::Poseidon2::hash(rolling_hash, 2);\n        let hash: [u8; 32] = hash.to_le_bytes();\n        let remaining_bytes = 30 * N - (num_hashes - 1) * 30;\n        for j in 0..remaining_bytes {\n            hash_buffer[(num_hashes - 1) * 30 + j] = hash[j];\n        }\n    }\n\n    let num_bits = MOD_BITS * 2;\n    let num_bytes = num_bits / 8 + ((num_bits % 8) != 0) as u32;\n\n    let bits_in_last_byte = num_bits as u8 % 8;\n    let last_byte_mask = (1 as u8 << bits_in_last_byte) - 1;\n    hash_buffer[num_bytes - 1] = hash_buffer[num_bytes - 1] & last_byte_mask;\n\n    let num_bigfield_chunks = (2 * N) / (N - 1) + (((2 * N) % (N - 1)) != 0) as u32;\n    let mut byte_ptr = 0;\n\n    // we want to convert our byte array into bigfield chunks\n    // each chunk has at most N-1 limbs\n    // to determine the exact number of chunks, we need the `!=` or `>` operator which is not avaiable when defining array sizes\n    // so we overestimate at 4\n    // e.g. if N = 20, then we have 40 limbs we want to reduce, but each bigfield chunk is 19 limbs, so we need 3\n    // if N = 2, we have 4 limbs we want to reduce but each bigfield chunk is only 1 limb, so we need 4\n    // max possible number of chunks is therefore 4\n    let mut bigfield_chunks: [[u128; N]; 4] = [[0; N]; 4];\n    for k in 0..num_bigfield_chunks {\n        let mut bigfield_limbs: [u128; N] = [0; N];\n        let mut num_filled_bytes = (k * 30);\n        if num_bytes >= num_filled_bytes {\n            let mut num_remaining_bytes = num_bytes - num_filled_bytes;\n            let mut num_remaining_limbs =\n                (num_remaining_bytes / 15) + (num_remaining_bytes % 15 > 0) as u32;\n            let mut more_than_N_minus_one_limbs = (num_remaining_limbs > (N - 1)) as u32;\n            let mut num_limbs_in_bigfield = more_than_N_minus_one_limbs * (N - 1)\n                + num_remaining_limbs * (1 - more_than_N_minus_one_limbs);\n\n            for j in 0..num_limbs_in_bigfield {\n                let mut limb: u128 = 0;\n                for _ in 0..15 {\n                    let need_more_bytes = (byte_ptr < num_bytes);\n                    let mut byte = hash_buffer[byte_ptr];\n                    limb *= (256 * need_more_bytes as u128 + (1 - need_more_bytes as u128));\n                    limb += byte as u128 * need_more_bytes as u128;\n                    byte_ptr += need_more_bytes as u32;\n                }\n                bigfield_limbs[num_limbs_in_bigfield - 1 - j] = limb;\n            }\n            bigfield_chunks[num_bigfield_chunks - 1 - k] = bigfield_limbs;\n        }\n    }\n\n    let mut bigfield_rhs_limbs: [u128; N] = [0; N];\n    bigfield_rhs_limbs[N - 1] = 1;\n    validate_in_range::<_, _, MOD_BITS>(bigfield_rhs_limbs);\n\n    let mut result: [u128; N] = [0; N];\n\n    for i in 0..num_bigfield_chunks {\n        let bigfield_lhs_limbs = bigfield_chunks[i];\n\n        result = mul(params, result, bigfield_rhs_limbs);\n        result = add(params, result, bigfield_lhs_limbs);\n    }\n\n    result\n}\n\n/**\n    * @brief Validate self != other\n    * @details If A == B, then A == B mod N.\n    *          We can efficiently evaluate A == B mod N where N = circuit modulus\n    *          This method is *sound*, but not *complete* (i.e. A != B but A == B mod N)\n    *          However the probability of an honest Prover being unable to satisfy this check is tiny!\n    *          (todo: compute how tiny)\n    **/\npub(crate) fn assert_is_not_equal<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) {\n    let mut l: Field = 0;\n    let mut r: Field = 0;\n    let mut modulus_mod_n: Field = 0;\n    for i in 0..N {\n        l *= TWO_POW_120 as Field;\n        r *= TWO_POW_120 as Field;\n        modulus_mod_n *= TWO_POW_120 as Field;\n        l += lhs[N - i - 1] as Field;\n        r += rhs[N - i - 1] as Field;\n        modulus_mod_n += params.modulus[N - i - 1] as Field;\n    }\n\n    // lhs can be either X mod N or P + X mod N\n    // rhs can be either Y mod N or P + Y mod N\n    // If lhs - rhs = 0 mod P then lhs - rhs = 0, P or -P mod N\n    let diff = l - r;\n    let target = diff * (diff + modulus_mod_n) * (diff - modulus_mod_n);\n    assert(target != 0, \"asssert_is_not_equal fail\");\n}\n\npub(crate) fn eq<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> bool {\n    let diff = sub::<_, MOD_BITS>(params, lhs, rhs);\n    // if self == other, possible values of `diff` will be `p` or `0`\n    // (the subtract operator constrains diff to be < ceil(log(p)))\n    // TODO: can do this more efficiently via witngen in unconstrained functions?\n    let is_equal_modulus: bool = diff == params.modulus;\n    let is_equal_zero: bool = diff.all(|elem| elem == 0);\n    is_equal_modulus | is_equal_zero\n}\n\npub(crate) fn is_zero<let N: u32, let MOD_BITS: u32>(val: [u128; N]) -> bool {\n    val.all(|limb| limb == 0)\n}\n\npub(crate) fn validate_in_field<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) {\n    // N.B. need to combine with validate_in_range if `self` limbs have not been range constrained\n    let mut p_minus_self: [Field; N] = [0; N];\n    let modulus: [u128; N] = params.modulus;\n    for i in 0..N {\n        p_minus_self[i] = (modulus[i] as Field - val[i] as Field);\n    }\n    let borrow_flags = unsafe { __validate_in_field_compute_borrow_flags(params, val) };\n    p_minus_self[0] += (borrow_flags[0] as Field * TWO_POW_120 as Field);\n    for i in 1..N - 1 {\n        p_minus_self[i] +=\n            (borrow_flags[i] as Field * TWO_POW_120 as Field - borrow_flags[i - 1] as Field);\n    }\n    p_minus_self[N - 1] -= (borrow_flags[N - 2] as Field);\n    validate_in_range::<_, _, MOD_BITS>(p_minus_self);\n}\n\n/**\n* @brief Validate a BigNum instance is correctly range constrained to contain no more than Params::modulus_bits()\n**/\npub(crate) fn validate_in_range<T, let N: u32, let MOD_BITS: u32>(limbs: [T; N])\nwhere\n    T: Into<Field>,\n{\n    for i in 0..(N - 1) {\n        limbs[i].into().assert_max_bit_size::<120>();\n    }\n\n    limbs[N - 1].into().assert_max_bit_size::<MOD_BITS - ((N - 1) * 120)>();\n}\n\n/**\n* @brief validate quotient produced from `evaluate_quadratic_expression` is well-formed\n* @description because the inputs into evaluate_quadratic_expression may cause the quotient to extend beyond `Params::modulus_bits`.\n*              We allow the quotient to extend 6 bits beyond Params::modulus_bits()\n*              Why is this?\n*              several factors:    1. quotient * modulus , limbs cannot overflow field boundary (254 bits)\n*                                  2. in `evaluate_quadratic_expression`, we require that for `expression - quotient * modulus`,\n*                                     limbs cannot exceed 246 bits (246 magic number due to a higher number adding extra range check gates)\n*              because of factor 2 and the fact that modulus limbs are 120 bits, quotient limbs cannot be >126 bits\n*\n*              Note: doesn't this mean that final_limb_bits should be constrained to be 126 bits, not modulus_bits() - ((N - 1) * 120) + 6?\n*              TODO: think about this more! we want the range constraint we apply to be as small as allowable as this is more efficient\n**/\npub(crate) fn validate_quotient_in_range<let N: u32, let MOD_BITS: u32>(limbs: [u128; N]) {\n    for i in 0..(N) {\n        (limbs[i] as Field).assert_max_bit_size::<120>();\n    }\n    // Note: replace magic number 6 with definition\n    (limbs[N - 1] as Field).assert_max_bit_size::<MOD_BITS - ((N - 1) * 120) + 6>();\n}\n\n// validate that lhs - rhs does not underflow i.e. lhs > rhs\npub(crate) fn validate_gt<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) {\n    // so we do... p - x - r = 0 and there might be borrow flags\n    // a - b = r\n    // p + a - b - r = 0\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    validate_in_range::<_, _, MOD_BITS>(result);\n    assert(!underflow, \"BigNum::validate_gt check fails\");\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n}\n\npub(crate) fn neg<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __neg(params.modulus, val)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, borrow_flags) = unsafe { __neg_with_flags(params.modulus, val) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n        let result_limb = modulus[0] + (borrow_flags[0] as u128 * TWO_POW_120) - val[0] - result[0];\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let result_limb = modulus[i] + (borrow_flags[i] as u128 * TWO_POW_120)\n                - val[i]\n                - result[i]\n                - borrow_flags[i - 1] as u128;\n            assert(result_limb == 0);\n        }\n        let result_limb = modulus[N - 1] - val[N - 1] - result[N - 1] - borrow_flags[N - 2] as u128;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn add<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            // __add_u128(params, lhs, rhs)\n            __add(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        let (result, carry_flags, borrow_flags, overflow_modulus) =\n            unsafe { __add_with_flags(params.modulus, lhs, rhs) };\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut subtrahend: [u128; N] = [0; N];\n        if (overflow_modulus) {\n            subtrahend = modulus;\n        }\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = lhs[0] as Field + rhs[0] as Field\n            - subtrahend[0] as Field\n            - result[0] as Field\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = lhs[i] as Field + rhs[i] as Field\n                - subtrahend[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry\n                + borrow_sub_carry * TWO_POW_120 as Field;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = lhs[N - 1] as Field + rhs[N - 1] as Field\n            - subtrahend[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\npub(crate) fn sub<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    if std::runtime::is_unconstrained() {\n        // Safety: not need to constrain in unconstrained runtime\n        unsafe {\n            __sub(params.modulus, lhs, rhs)\n        }\n    } else {\n        // so we do... p - x - r = 0 and there might be borrow flags\n        // a - b = r\n        // p + a - b - r = 0\n        let (result, carry_flags, borrow_flags, underflow) =\n            unsafe { __sub_with_flags(params.modulus, lhs, rhs) };\n\n        validate_in_range::<_, _, MOD_BITS>(result);\n        let modulus = params.modulus;\n\n        let mut addend: [u128; N] = [0; N];\n        if (underflow) {\n            addend = modulus;\n        }\n\n        let borrow_sub_carry = borrow_flags[0] as Field - carry_flags[0] as Field;\n        let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n            + addend[0] as Field\n            + lhs[0] as Field\n            - rhs[0] as Field\n            - result[0] as Field;\n        assert(result_limb == 0);\n        for i in 1..N - 1 {\n            let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n            let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n            let result_limb = borrow_sub_carry * TWO_POW_120 as Field\n                + addend[i] as Field\n                + lhs[i] as Field\n                - rhs[i] as Field\n                - result[i] as Field\n                - prev_borrow_sub_carry;\n            assert(result_limb == 0);\n        }\n        let borrow_sub_carry = borrow_flags[N - 2] as Field - carry_flags[N - 2] as Field;\n        let result_limb = addend[N - 1] as Field + lhs[N - 1] as Field\n            - rhs[N - 1] as Field\n            - result[N - 1] as Field\n            - borrow_sub_carry as Field;\n        assert(result_limb == 0);\n        result\n    }\n}\n\n// Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n//       via evaluate_quadratic_expression\n// e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n//      will create much fewer constraints than calling `mul` and `add` directly\npub(crate) fn mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let result = unsafe { __mul::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[lhs]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [result],\n            [true],\n        );\n    }\n    result\n}\n\n// Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\npub(crate) fn div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    assert(\n        params.has_multiplicative_inverse,\n        \"BigNum has no multiplicative inverse. Use udiv for unsigned integer division\",\n    );\n    let result = unsafe { __div::<_, MOD_BITS>(params, lhs, rhs) };\n    if !std::runtime::is_unconstrained() {\n        evaluate_quadratic_expression(\n            params,\n            [[result]],\n            [[false]],\n            [[rhs]],\n            [[false]],\n            [lhs],\n            [true],\n        );\n    }\n    result\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) fn udiv_mod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let (quotient, remainder) = unsafe { __udiv_mod(numerator, divisor) };\n    if !std::runtime::is_unconstrained() {\n        // self / divisor = quotient rounded\n        // quotient * divisor + remainder - self = 0\n        evaluate_quadratic_expression(\n            params,\n            [[quotient]],\n            [[false]],\n            [[divisor]],\n            [[false]],\n            [numerator, remainder],\n            [true, false],\n        );\n        // we need (remainder < divisor)\n        // implies (divisor - remainder > 0)\n        validate_gt::<_, MOD_BITS>(divisor, remainder);\n    }\n    (quotient, remainder)\n}\n\n/**\n* @brief udiv_mod performs integer division between numerator, divisor\n*\n* i.e. return param is floor(numerator / divisor)\n**/\npub(crate) fn udiv<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).0\n}\n\n/**\n* @brief udiv_mod performs integer modular reduction\n*\n* i.e. 1. numerator % divisor = return value\n**/\npub(crate) fn umod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    udiv_mod::<_, MOD_BITS>(params, numerator, divisor).1\n}\n\n// a comparison function. returns true if lhs > rhs and false otherwise\npub(crate) fn cmp<let N: u32, let MOD_BITS: u32>(lhs: [u128; N], rhs: [u128; N]) -> Ordering {\n    let (underflow, result, carry_flags, borrow_flags) =\n        unsafe { __validate_gt_remainder(lhs, rhs) };\n    // if underflow is true, swap lhs and rhs\n    let (lhs, rhs) = if underflow { (rhs, lhs) } else { (lhs, rhs) };\n\n    check_gt_with_flags::<N, MOD_BITS>(lhs, rhs, result, borrow_flags, carry_flags);\n    if lhs == rhs {\n        Ordering::equal()\n    } else if underflow {\n        Ordering::less()\n    } else {\n        Ordering::greater()\n    }\n}\n\n// the constraining function for the results returned by __validate_gt_remainder. this is used in both comparisons and validate gt\npub(crate) fn check_gt_with_flags<let N: u32, let MOD_BITS: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n    result: [u128; N],\n    borrow_flags: [bool; N],\n    carry_flags: [bool; N],\n) {\n    let mut addend: [Field; N] = [0; N];\n    let result_limb = lhs[0] as Field - rhs[0] as Field + addend[0] - result[0] as Field\n        + (borrow_flags[0] as Field - carry_flags[0] as Field) * TWO_POW_120 as Field;\n    assert(result_limb == 0);\n\n    for i in 1..N - 1 {\n        let prev_borrow_sub_carry = borrow_flags[i - 1] as Field - carry_flags[i - 1] as Field;\n        let borrow_sub_carry = borrow_flags[i] as Field - carry_flags[i] as Field;\n        let result_limb = lhs[i] as Field - rhs[i] as Field + addend[i] as Field\n            - result[i] as Field\n            - prev_borrow_sub_carry\n            + borrow_sub_carry * TWO_POW_120 as Field;\n        assert(result_limb == 0);\n    }\n\n    let result_limb = lhs[N - 1] as Field - rhs[N - 1] as Field + addend[N - 1] as Field\n        - result[N - 1] as Field\n        - borrow_flags[N - 2] as Field\n        + carry_flags[N - 2] as Field;\n    assert(result_limb == 0);\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/constrained_ops.nr"},"95":{"source":"use crate::utils::split_bits;\n\nuse crate::constants::{TWO_POW_120, TWO_POW_126, TWO_POW_246};\nuse crate::fns::{\n    constrained_ops::validate_quotient_in_range, unconstrained_helpers::__barrett_reduction,\n};\nuse crate::params::BigNumParams as P;\n\n/**\n* @brief Given a degree-2 BigNum expression that is equal to 0 mod p, compute the quotient and borrow flags \n* @description The expression is of the form:\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] = quotient * modulus\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The borrow flags describe whether individual Field limbs will underflow when evaluating the above relation.\n* For example, when computing the product a * b - q * p = 0, it is possible that:\n*      1. a[0]*b[0] - p[0]*q[0] = -2^{120}\n*      2. a[0]*b[1] + a[1]*b[0] - p[0]*q[1] - p[1]*q[0] = 1\n* In the above example, the value represented by these two limbs is zero despite each limb being nonzero.\n* In this case, to correctly constrain the result, we must add (at least) 2^{120} from the first limb and subtract 1 from the second.\n*\n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\n\nunconstrained fn compute_quadratic_expression_with_borrow_flags<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N], [Field; 2 * N - 2]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut mulout_p = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n\n    let mut mulout_n: [Field; 2 * N] = [0; 2 * N];\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout_p, 2 * N);\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, MOD_BITS, params.modulus);\n    assert(remainder == [0; N]);\n    for i in 0..N {\n        for j in 0..N {\n            mulout_n[i + j] += quotient[i] as Field * params.modulus[j] as Field;\n        }\n    }\n\n    // compute borrow flags from mulout_p and mulout_n\n    let mut borrow_flags: [Field; 2 * N - 2] = [0; 2 * N - 2];\n    let borrow_shift: Field = TWO_POW_246; // 2^{246}\n    let borrow_carry: Field = TWO_POW_126; // 2^{246 - 120} = 2^{126}\n    let downshift: Field = 1 / (TWO_POW_120 as Field);\n\n    // determine whether we need to borrow from more significant limbs.\n    // initial limb is \"simple\" comparison operation\n    // TODO: check how expensive `lt` operator is w.r.t. witness generation\n    borrow_flags[0] = mulout_p[0].lt(mulout_n[0]) as Field;\n    // we have 2N - 2 borrow flags. The number of limbs from our product computation is 2N - 1\n    // and there is nothing to borrow against for the final limb.\n    let mut hi_bits =\n        (mulout_p[0] - mulout_n[0] + (borrow_flags[0] as Field * borrow_shift)) * downshift;\n    for i in 1..(N + N - 2) {\n        // compute the contribution from limb `i-1` that gets added into limb `i`, and add into limb `i`\n        // let hi_bits = (mulout_p.get(i - 1) - mulout_n.get(i - 1) + (borrow_flags.get(i - 1) * borrow_shift))\n        //     * downshift;\n        mulout_p[i] += hi_bits;\n\n        // determine whether negative limb values are greater than positive limb values\n        let underflow: Field =\n            mulout_p[i].lt(mulout_n[i] + (borrow_flags[i - 1] * borrow_carry)) as Field;\n        borrow_flags[i] = underflow;\n\n        hi_bits = (\n            mulout_p[i] - mulout_n[i] + (borrow_flags[i] * borrow_shift)\n                - (borrow_flags[i - 1] * borrow_carry)\n        )\n            * downshift;\n    }\n\n    (quotient, remainder, borrow_flags)\n}\n\n/**\n* @brief Computes the result of a linear combination of (possibly negative) BigNum values (unconstrained)\n**/\n// NOTE: modulus2 is structured such that all limbs will be greater than 0, even when subtracting.\n// To do this, when computing `p - x`, we ensure that each limb in `p` is greater than each limb in `x`.\n// We know that, for a valid bignum element, the limbs in `x` will be <2^{120}\n// Therefore each of the limbs in `p` (except the most significant) will borrow 2^{120} from the more significant limb.\n// Finally, to ensure we do not underflow in the most significant limb, we use `2p` instead of `p`\nunconstrained fn __add_linear_expression<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n    flags: [bool; M],\n) -> ([u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut sum: [u128; N] = [0; N];\n    // TODO: ugly! Will fail if input array is empty\n    let modulus2: [u128; N] = params.double_modulus;\n    for i in 0..M {\n        if (flags[i]) {\n            for j in 0..N {\n                sum[j] = sum[j] + (modulus2[j] as Field - x[i][j] as Field) as u128;\n                // assert(x[i][j].lt(modulus2[j]));\n            }\n        } else {\n            for j in 0..N {\n                sum[j] = sum[j] + x[i][j];\n            }\n        }\n    }\n    // problem if we normalize when used in computing quotient\n    sum\n}\n\n/**\n* @brief computes the limb products of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\nunconstrained fn compute_quadratic_expression_product<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> [Field; 2 * N] {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mut lhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut rhs: [[u128; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n\n    for i in 0..NUM_PRODUCTS {\n        lhs[i] = __add_linear_expression(params, lhs_terms[i], lhs_flags[i]);\n        rhs[i] = __add_linear_expression(params, rhs_terms[i], rhs_flags[i]);\n    }\n\n    let add: [u128; N] = __add_linear_expression(params, linear_terms, linear_flags);\n\n    let mut mulout: [Field; 2 * N] = [0; 2 * N];\n\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                mulout[i + j] += (lhs[k][i] as Field * rhs[k][j] as Field);\n            }\n        }\n        mulout[i] += add[i] as Field;\n    }\n    mulout\n}\n\n/**\n* @brief computes the quotient/remainder of a quadratic expression\n* @details see compute_quadratic_expression_with_borrow_flags for full description\n**/\npub(crate) unconstrained fn compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> ([u128; N], [u128; N]) {\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    let mulout: [Field; (N * 2)] = compute_quadratic_expression_product(\n        params,\n        lhs_terms,\n        lhs_flags,\n        rhs_terms,\n        rhs_flags,\n        linear_terms,\n        linear_flags,\n    );\n    let mut relation_result: [u128; 2 * N] = split_bits::__normalize_limbs(mulout, 2 * N);\n\n    // size 4\n    // a[3] * b[3] = a[6] = 7\n    // TODO: ugly! Will fail if input slice is empty\n    let k = MOD_BITS;\n\n    let (quotient, remainder) =\n        __barrett_reduction(relation_result, params.redc_param, k, params.modulus);\n\n    let mut q = quotient;\n    let mut r = remainder;\n    (q, r)\n}\n\n/**\n* @brief Constrain a degree-2 BigNum expression to be equal to 0 modulo self.modulus\n* @description The expression is of the form (when evaluated as an integer relation):\n*\n* \\sum_{i=0}^{NUM_PRODUCTS - 1} ((\\sum_{j=0}^{LHS_N-1}lhs[i][j]) * (\\sum_{j=0}^{RHS_N-1}rhs[i][j])) + \\sum_{i=0}^{ADD_N - 1}linear_terms[i] - quotient * modulus = 0\n*\n* The intent is to capture an arbitrary degree-2 expression within the limitations of Noir (no efficient dynamically-sized vectors)\n*\n* Note: this method requires the remainder term of the expression to be ZERO\n* When performing BigNum arithmetic, we want to represent desired BigNum operations in a way that minimizes the number of modular reductions that are required.\n* This can be achieved by minimizing the number of degree-2 relations required.\n*\n* The expensive parts of this algorithm are the following:\n*      1. evaluating the limb products required to compute `lhs * rhs`\n*      2. applying range constraints to validate the result is 0\n*\n* Range constraints are needed for the following reason:\n* When evaluating the above expression over N-limb BigNum objects, the result will consist of 2N - 1 limbs.\n* Each limb will be in the range [0, ..., 2^{240 + twiddle_factor} - 1] (twiddle_factor needs to be less than 6).\n* Because of the subtractions, the limbs may underflow and represent NEGATIVE values.\n* To account for this, we allow the Prover to borrow values from more significant limbs and add them into less significant limbs\n* (explicitly, we can borrow 2^{126} from limb `i + 1` to add `2^{246}` into `i`).\n* To ensure this has been done correctly, we validate that the borrow-adjusted limbs are all-zero for the first 120 bits.\n* We do *this* by multiplying the borrow-adjusted limbs by 1 / 2^{120} modulo CircutModulus, and we validate the result is in the range [0, ..., 2^{126} - 1].\n* TODO: explain why this check works. It's statistically sound but not perfectly sound. Chance of the check failing is ~1 in 2^{120}\n* I believe this is the most efficient way of performing the zero-check for this relation as it only requires `2N - 2` 126-bit range checks.\n* TODO: explain why we apply a 126-bit range check, this feels like a magic number\n* (it is. we could go higher, up to the number of bits in the CircuitModulus - 121, but 126 *should be* sufficient and is much cheaper)\n* TODO: apply checks in this method to validate twiddle_factor does not exceed 6\n* \n* @param lhs_terms a 2D array of BigNum\n* @param lhs_flags a 2D array of sign flags\n* @param rhs_terms a 2D array of BigNum\n* @param rhs_flags a 2D array of sign flags\n* @param linear_terms an array of BigNum\n* @param linear_flags an array of sign flags\n**/\npub(crate) fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: P<N, MOD_BITS>,\n    lhs_terms: [[[u128; N]; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[[u128; N]; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [[u128; N]; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    // use an unconstrained function to compute the value of the quotient\n    let (quotient, _, borrow_flags): ([u128; N], [u128; N], [Field; 2 * N - 2]) = unsafe {\n        compute_quadratic_expression_with_borrow_flags::<_, MOD_BITS, _, _, _, _>(\n            params,\n            lhs_terms,\n            lhs_flags,\n            rhs_terms,\n            rhs_flags,\n            linear_terms,\n            linear_flags,\n        )\n    };\n\n    // constrain the quotient to be in the range [0, ..., 2^{m} - 1], where `m` is log2(modulus) rounded up.\n    // Additionally, validate quotient limbs are also in the range [0, ..., 2^{120} - 1]\n    validate_quotient_in_range::<_, MOD_BITS>(quotient);\n    // TODO, validate we do not overflow N2 when multiplying and N when adding\n    // (should be a compile-time check...unconstrained function?)\n    // Compute the linear sums that represent lhs_1, rhs_1, lhs_2, rhs_2, add\n    let mut t0: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t1: [[Field; N]; NUM_PRODUCTS] = [[0; N]; NUM_PRODUCTS];\n    let mut t4: [Field; N] = [0; N];\n\n    // TODO: this is super nasty as it requires a multiplication\n    let double_modulus: [u128; N] = params.double_modulus;\n\n    for k in 0..NUM_PRODUCTS {\n        for i in 0..N {\n            for j in 0..LHS_N {\n                // note: if is_negative is not known at comptime this is very expensive\n                if (lhs_flags[k][j]) {\n                    t0[k][i] -= lhs_terms[k][j][i] as Field;\n                    t0[k][i] += double_modulus[i] as Field;\n                } else {\n                    t0[k][i] += lhs_terms[k][j][i] as Field;\n                }\n            }\n            for j in 0..RHS_N {\n                if (rhs_flags[k][j]) {\n                    t1[k][i] -= rhs_terms[k][j][i] as Field;\n                    t1[k][i] += double_modulus[i] as Field;\n                } else {\n                    t1[k][i] += rhs_terms[k][j][i] as Field;\n                }\n            }\n        }\n    }\n    for i in 0..N {\n        for j in 0..ADD_N {\n            if (linear_flags[j]) {\n                t4[i] -= linear_terms[j][i] as Field;\n                t4[i] += double_modulus[i] as Field;\n            } else {\n                t4[i] += linear_terms[j][i] as Field;\n            }\n        }\n    }\n\n    // We want to evaluate that t0 * t1 + t2 * t3 + t4 - Quotient * Modulus = 0, evaluated over the integers\n    // For this we need to be able to borrow values from more-significant limbs into less-significant limbs,\n    // so that we can ensure that no limbs will underflow for an honest Prover\n    let mut product_limbs: [Field; 2 * N] = [0; 2 * N];\n\n    // Compute the product t0 * t1 + t2 * t3 + t4 - Quotient * Modulus\n    // TODO: this is super nasty as it requires a multiplication\n    for i in 0..N {\n        for j in 0..N {\n            for k in 0..NUM_PRODUCTS {\n                if k == 0 {\n                    let new_term =\n                        t0[k][i] * t1[k][j] - quotient[i] as Field * params.modulus[j] as Field;\n                    std::as_witness(new_term); // width-4 optimization (n.b. might not be optimal if t2, t3 input arrays are nonzero)\n                    product_limbs[i + j] += new_term;\n                } else {\n                    product_limbs[i + j] += t0[k][i] * t1[k][j] as Field;\n                }\n            }\n            if (NUM_PRODUCTS == 0) {\n                product_limbs[i + j] -= quotient[i] as Field * params.modulus[j] as Field;\n            }\n        }\n        product_limbs[i] += t4[i];\n    }\n\n    // each limb product represents the sum of 120-bit products.\n    // by setting the borrow value to 2^246 we are restricting this method's completeness to expressions\n    // where no more than 64 limb products are summed together.\n    // TODO: check in unconstrained function that this condition is satisfied\n    // TODO: define trade-offs regarding the value of borrow_shift\n    // (the larger the value, the greater the range check that is required on product_limbs)\n    // (126-bit range check is a sweet spot for the barretenberg backend as it decomposes into 9 14-bit range checks)\n    // (the barretenberg backend can evaluate these in 5.25 gates. 127 bits costs 6.5 gates)\n    let borrow_shift: Field = 0x40000000000000000000000000000000000000000000000000000000000000; // 2^{246}\n    let borrow_carry: Field = 0x40000000000000000000000000000000; // 2^{246 - 120} = 2^{126}\n    // N.B. borrow_flags is `Field` type because making it `bool` would apply boolean constraints to all `N2` array entries.\n    //      We only use `N2 - 2` borrow flags so applying 1-bit range checks on the array elements we use is more efficient.\n    // TODO: Once it is possible to perform arithmetic on generics we can use `borrow_flags: [bool;N+N-2]` to avoid this issue\n    borrow_flags[0].assert_max_bit_size::<1>();\n    product_limbs[0] += borrow_flags[0] * borrow_shift;\n    for i in 1..(N + N - 2) {\n        borrow_flags[i].assert_max_bit_size::<1>();\n        product_limbs[i] += (borrow_flags[i] * borrow_shift - borrow_flags[i - 1] * borrow_carry);\n    }\n    product_limbs[N + N - 2] -= borrow_flags[N + N - 3] as Field * borrow_carry;\n\n    // Final step: Validate `product_limbs` represents the integer value `0`\n    // Each element `i` in `product_limbs` overlaps in bitrange with element `i+1`, EXCEPT for the low 120 bits\n    // i.e. we need to do the following for each limb `i`:\n    //      1. validate the limb's low-120 bits equals zero\n    //      2. compute the limb \"carry\" by right-shifting by 2^{120}\n    //      3. add the carry into limb `i+1`\n    // We can efficiently do all of the above by multiplying the limb by 2^{-120} and constraining the result to be <2^{126}\n    // (if the low 120 bits are nonzero the result will underflow and product a large value that cannot be range constrained)\n    // (the probability of an underflow value satisfying a 126-bit range constraint is approx. 2^{k - 126},\n    //  where k is the number of bits in the prime field)\n    // We then add the result into the next limb and repeat.\n    let hi_shift: Field = 0x1000000000000000000000000000000;\n    let hi_downshift: Field = 1 / hi_shift;\n    for i in 0..N + N - 2 {\n        product_limbs[i] *= hi_downshift;\n        std::as_witness(product_limbs[i]);\n        product_limbs[i].assert_max_bit_size::<126>(); // N.B. is this sufficient? going beyond 126 costs us 1 gate per limb\n        product_limbs[i + 1] += product_limbs[i];\n    }\n    // the most significant limb has no limb to \"carry\" values into - the entire limb must equal zero\n    assert(product_limbs[N + N - 2] == 0);\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/expressions.nr"},"97":{"source":"use crate::utils::map::invert_array;\n/// conversions between big endian and little endian byte arrays and BigNum instances\n/// the byte serialization should have `(MOD_BITS + 7) / 8` bytes.\n/// each 120-bit limb is represented by 15 bytes, and there are fewer bytes for covering the most significant limb\npub(crate) fn from_be_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    let num_bits = (MOD_BITS + 7) / 8 * 8;\n    assert(num_bits >= MOD_BITS);\n    assert(num_bits - MOD_BITS < 8);\n    let mut result: [u128; N] = [0; N];\n\n    let excess_bytes = N * 15 - (MOD_BITS + 7) / 8;\n    let final_limb_bytes = 15 - excess_bytes;\n    let mut limb: Field = 0;\n    let mut k = 0;\n    for _j in 0..final_limb_bytes {\n        limb *= 256;\n        limb += x[k] as Field;\n        k += 1;\n    }\n    limb.assert_max_bit_size::<128>();\n    result[N - 1] = limb as u128;\n\n    for i in 1..N {\n        let mut limb: Field = 0;\n        for _j in 0..15 {\n            limb *= 256;\n            limb += x[k] as Field;\n            k += 1;\n        }\n        limb.assert_max_bit_size::<128>();\n        result[N - i - 1] = limb as u128;\n    }\n\n    let most_significant_byte: Field = x[0] as Field;\n\n    most_significant_byte.assert_max_bit_size::<8 - ((MOD_BITS + 7) / 8 * 8 - MOD_BITS)>();\n    result\n}\n\npub(crate) fn to_be_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let mut result: [u8; (MOD_BITS + 7) / 8] = [0; (MOD_BITS + 7) / 8];\n    // the last limb will not have all the 15 bytes so we deal with the full limbs first\n    for i in 0..N - 1 {\n        let index = N - i - 2;\n        let limb_bytes: [u8; 15] = (val[index] as Field).to_be_bytes();\n        for j in 0..15 {\n            // we leave the space for the first byte empty, which would take (MOD_BITS+7)/8 - MOD_BITS/8 bytes\n            result[i * 15 + j + (MOD_BITS + 7) / 8 - (N - 1) * 15] = limb_bytes[j];\n        }\n    }\n    // now we deal with the last limb\n    let last_limb_bytes: [u8; ((MOD_BITS + 7) / 8 - (N - 1) * 15)] =\n        (val[N - 1] as Field).to_be_bytes();\n\n    for i in 0..((MOD_BITS + 7) / 8 - (N - 1) * 15) {\n        result[i] = last_limb_bytes[i];\n    }\n    result\n}\n\npub(crate) fn to_le_bytes<let N: u32, let MOD_BITS: u32>(\n    val: [u128; N],\n) -> [u8; (MOD_BITS + 7) / 8] {\n    let result_be: [u8; (MOD_BITS + 7) / 8] = to_be_bytes(val);\n    let result = invert_array(result_be);\n    result\n}\n\npub(crate) fn from_le_bytes<let N: u32, let MOD_BITS: u32>(\n    x: [u8; (MOD_BITS + 7) / 8],\n) -> [u128; N] {\n    // make the bytes big endian\n    let be_x = invert_array(x);\n    from_be_bytes(be_x)\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/serialization.nr"},"98":{"source":"use crate::constants::{TWO_POW_119, TWO_POW_120};\nuse crate::fns::unconstrained_ops::{__add, __gte, __mul, __neg, __one, __pow};\nuse crate::params::BigNumParams as P;\nuse crate::utils::msb::get_msb;\nuse crate::utils::split_bits::__normalize_limbs;\n\npub(crate) unconstrained fn __from_field<let N: u32>(field: Field) -> [u128; N] {\n    let mut x = field;\n    let x_first_u128 = (x as u128);\n    let first: u128 = x_first_u128 % TWO_POW_120;\n    // this becomes the same as a integer division because we're removing the remainder\n    x = (x - (first as Field)) / (TWO_POW_120 as Field);\n    let x_second_u128 = (x as u128);\n    let second = x_second_u128 % TWO_POW_120;\n    x = (x - (second as Field)) / (TWO_POW_120 as Field);\n    let x_third_u128 = (x as u128);\n    let third = x_third_u128 % TWO_POW_120;\n    let mut result: [u128; N] = [0; N];\n    if N > 2 {\n        result[0] = first;\n        result[1] = second;\n        result[2] = third;\n    }\n    if N == 2 {\n        result[0] = first;\n        result[1] = second;\n    }\n    if N == 1 {\n        result[0] = first;\n    }\n    result\n}\n\npub(crate) unconstrained fn __validate_in_field_compute_borrow_flags<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [bool; N] {\n    let mut flags: [bool; N] = [false; N];\n    let modulus: [u128; N] = params.modulus;\n    flags[0] = modulus[0] < val[0];\n    for i in 1..N - 1 {\n        flags[i] = modulus[i] < val[i] + flags[i - 1] as u128;\n    }\n    flags\n}\n\npub(crate) unconstrained fn __validate_gt_remainder<let N: u32>(\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> (bool, [u128; N], [bool; N], [bool; N]) {\n    let mut a = lhs;\n    let mut b = rhs;\n    let underflow = !__gte(lhs, rhs);\n\n    let mut result: [u128; N] = [0; N];\n    // swap a and b if there's an underflow\n    let (a, b) = if underflow { (b, a) } else { (a, b) };\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N] = [false; N];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = a[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = b[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = (borrow * TWO_POW_120 + add_term - sub_term);\n\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (underflow, result, carry_flags, borrow_flags)\n}\n\npub(crate) unconstrained fn __neg_with_flags<let N: u32>(\n    modulus: [u128; N],\n    val: [u128; N],\n) -> ([u128; N], [bool; N - 1]) {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow_in: u128 = 0;\n\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    for i in 0..N {\n        let sub_term = val[i] + borrow_in;\n        let borrow = (sub_term > modulus[i]) as u128;\n        result[i] = borrow * TWO_POW_120 + modulus[i] - sub_term;\n\n        borrow_in = borrow;\n        if (i < N - 1) {\n            borrow_flags[i] = borrow != 0;\n        }\n    }\n    (result, borrow_flags)\n}\n\npub(crate) unconstrained fn __add_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let add_res = __helper_add(lhs, rhs);\n    let overflow = __gte(add_res, modulus);\n\n    let mut subtrahend: [u128; N] = [0; N];\n    let mut result: [u128; N] = [0; N];\n\n    if overflow {\n        subtrahend = modulus;\n    }\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term = lhs[i] + rhs[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry as u128;\n\n        let sub_term = subtrahend[i] + borrow_in;\n\n        let mut borrow: u128 = (sub_term > add_term) as u128;\n        result[i] = borrow * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow as u128;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, overflow)\n}\n\npub(crate) unconstrained fn __sub_with_flags<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [bool; N], [bool; N - 1], bool) {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let underflow = !__gte(lhs, rhs);\n    let addend: [u128; N] = if underflow { modulus } else { [0; N] };\n    let mut result: [u128; N] = [0; N];\n\n    let mut carry_in: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    let mut borrow_flags: [bool; N - 1] = [false; N - 1];\n    let mut carry_flags: [bool; N] = [false; N];\n    for i in 0..N {\n        let mut add_term: u128 = lhs[i] + addend[i] + carry_in;\n        let mut carry = (add_term as u128 >= TWO_POW_120) as u128;\n        add_term -= carry * TWO_POW_120;\n        carry_in = carry;\n\n        let sub_term = rhs[i] + borrow_in;\n        let mut borrow = (sub_term > add_term) as u128;\n        result[i] = borrow as u128 * TWO_POW_120 + add_term - sub_term;\n        borrow_in = borrow;\n\n        // Only set `borrow` and `carry` if they differ\n        if (carry != borrow) {\n            carry_flags[i] = carry != 0;\n            if (i < N - 1) {\n                borrow_flags[i] = borrow != 0;\n            }\n        }\n    }\n    (result, carry_flags, borrow_flags, underflow)\n}\n\n/**\n * @brief BARRETT_REDUCTION_OVERFLOW_BITS defines how large an input to barrett reduction can be\n * @details maximum value = modulus^2 <<BARRETT_REDUCTION_OVERFLOW_BITS\n *          see __barrett_reduction for more details\n **/\ncomptime global BARRETT_REDUCTION_OVERFLOW_BITS: u32 = 4;\n\npub(crate) unconstrained fn __barrett_reduction<let N: u32>(\n    x: [u128; 2 * N],\n    redc_param: [u128; N],\n    k: u32,\n    modulus: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mulout_field: [Field; 3 * N] = [0; 3 * N];\n    for i in 0..(N + N) {\n        for j in 0..N {\n            mulout_field[i + j] += x[i] as Field * redc_param[j] as Field;\n        }\n    }\n\n    let mulout: [u128; 3 * N] = __normalize_limbs(mulout_field, 3 * N);\n\n    // When we apply the barrett reduction, the maximum value of the output will be\n    // <= p * (1 + x/2^{2k})\n    // where p = modulus,\n    //       x = reduction input\n    // if x > p * p, we need k to be larger than modulus_bits()\n    // we hardcode k = 4, which means that the maximum value of x is approx. 16 * p * p\n    // this should be larger than most values put into `evaluate_quadratic_expression`\n    // TODO: try and detect cases where x might be too large at comptime\n    // N.B. BARRETT_REDUCTION_OVERFLOW_BITS affects how `redc_param` is generated.\n    // `redc_param` = 2^{modulus_bits() * 2 + BARRETT_REDUCTION_OVERFLOW_BITS} / modulus\n    // NOTE: very niche edge case error that we need to be aware of:\n    //       N must be large enough to cover the modulus *plus* BARRETT_REDUCTION_OVERFLOW_BITS\n    //       i.e. a 359-bit prime needs (I think) 4 limbs to represent or we may overflow when calling __barrett_reduction\n    let mut quotient = __shr(mulout, (k + k + BARRETT_REDUCTION_OVERFLOW_BITS));\n    // the quotient has bunch of zero limbs now, so we can just take the first N limbs as a result\n    let mut smaller_quotient = [0; N];\n    for i in 0..N {\n        smaller_quotient[i] = quotient[i] as u128;\n    }\n\n    // N.B. we assume that the shifted quotient cannot exceed 2 times original bit size.\n    //      (partial_quotient_full should be just slightly larger than the modulus, we could probably represent with a size N+1 array)\n    let partial_quotient_full: [Field; 3 * N] = __into_field_array(quotient);\n\n    // quotient_mul_modulus_normalized can never exceed input value `x` so can fit into size-2 array\n    let mut quotient_mul_modulus_normalized: [Field; 2 * N] = [0; 2 * N];\n\n    // First, accumulate the products into quotient_mul_modulus_normalized\n    for j in 0..N {\n        for i in 0..(N + N - j) {\n            quotient_mul_modulus_normalized[i + j] +=\n                partial_quotient_full[i] * modulus[j] as Field;\n        }\n    }\n\n    // Then, split the accumulated values and propagate higher bits\n    let long_quotient_mul_modulus_normalized: [u128; 2 * N] =\n        __normalize_limbs(quotient_mul_modulus_normalized, 2 * N);\n    let mut quotient_mul_modulus_normalized: [u128; N] = [0; N];\n    for i in 0..N {\n        quotient_mul_modulus_normalized[i] = long_quotient_mul_modulus_normalized[i];\n    }\n\n    let mut long_remainder = __helper_sub(x, long_quotient_mul_modulus_normalized);\n    // ugly but have to remove a bunch of zeros from this\n    let mut remainder = [0; N];\n    for i in 0..N {\n        remainder[i] = long_remainder[i];\n    }\n    // barrett reduction is quirky so might need to remove a few modulus from the remainder\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n    if (__gte(remainder, modulus)) {\n        remainder = __helper_sub(remainder, modulus);\n        smaller_quotient = __increment(smaller_quotient);\n    }\n\n    (smaller_quotient, remainder)\n}\n\n/**\n* @brief compute the log of the size of the primitive root\n* @details find the maximum value k where x^k = 1, where x = primitive root\n*          This is needed for our Tonelli-Shanks sqrt algorithm\n**/\npub(crate) unconstrained fn __primitive_root_log_size<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> u32 {\n    let mut one: [u128; N] = [0; N];\n    one[0] = 1;\n    let mut target = __helper_sub(params.modulus, one);\n    let mut result: u32 = 0;\n    for _ in 0..MOD_BITS {\n        let lsb_is_one = (target[0] & 1) == 1;\n        if (lsb_is_one) {\n            break;\n        }\n        result += 1;\n        target = __shr1(target);\n    }\n    result\n}\n\n/**\n* @brief inner loop fn for `find_multiplive_generator`\n* @details recursive function to get around the lack of a `while` keyword\n**/\nunconstrained fn __recursively_find_multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    target: [u128; N],\n    p_minus_one_over_two: [u128; N],\n) -> (bool, [u128; N]) {\n    let exped = __pow(params, target, p_minus_one_over_two);\n    let one: [u128; N] = __one();\n    let neg_one = __neg(params.modulus, one);\n    let found = exped == neg_one;\n    let mut result: (bool, [u128; N]) = (found, target);\n    if (!found) {\n        let _target: [u128; N] = __add(params.modulus, target, one);\n        result = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n            params,\n            _target,\n            p_minus_one_over_two,\n        );\n    }\n    result\n}\n\n/**\n* @brief find multiplicative generator `g` where `g` is the smallest value that is not a quadratic residue\n*        i.e. smallest g where g^2 = -1\n* @note WARNING if multiplicative generator does not exist, this function will enter an infinite loop!\n**/\npub(crate) unconstrained fn __multiplicative_generator<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n) -> [u128; N] {\n    let mut target: [u128; N] = __one();\n    let p_minus_one_over_two = __shr1(__helper_sub(params.modulus, __one()));\n    let (_, target) = __recursively_find_multiplicative_generator::<_, MOD_BITS>(\n        params,\n        target,\n        p_minus_one_over_two,\n    );\n    target\n}\n\npub(crate) unconstrained fn __tonelli_shanks_sqrt_inner_loop_check<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    t2m: [u128; N],\n    i: u32,\n) -> u32 {\n    let one: [u128; N] = __one();\n    let is_one = t2m == one;\n    let mut result = i;\n    if (!is_one) {\n        let t2m = __mul::<_, MOD_BITS>(params, t2m, t2m);\n        let i = i + 1;\n        result = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, i);\n    }\n    result\n}\n\npub(crate) unconstrained fn __increment<let N: u32>(val: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 1;\n    for i in 0..N {\n        let mut add_term = (val[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = (120 - limb_shift);\n    let mask: u128 = (((1 as u128) << limb_shift) - 1) << remainder_shift;\n    result[0] = (input[0 + num_shifted_limbs] >> (limb_shift));\n    for i in 1..(N - num_shifted_limbs) {\n        let value = input[i + num_shifted_limbs];\n        result[i] = value >> limb_shift;\n        let remainder: u128 = (value << remainder_shift) & mask;\n        result[i - 1] = result[i - 1] + remainder;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shl<let N: u32>(input: [u128; N], shift: u32) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n\n    let num_shifted_limbs = shift / 120;\n    let limb_shift = (shift % 120) as u128;\n    let remainder_shift = 120 - limb_shift;\n\n    // 83\n    // limb shift = 1\n    // inside shift = 19 bits to the left\n    // meaning we have 19 carry bits and 41 remainder bits\n    let mask: u128 = (1 as u128 << 120) - 1;\n    //   let mask: u64 = (((1 as u64) << limb_shift as u8) - 1) << remainder_shift as u8;\n    let value = input[0];\n\n    let mut remainder = (value >> remainder_shift);\n    result[num_shifted_limbs] = (value << limb_shift) & mask;\n\n    // shift 84. num shifted = 1\n    for i in 1..((N) - num_shifted_limbs) {\n        let value = input[i];\n        let upshift = ((value << limb_shift) + remainder) & mask;\n        result[i + num_shifted_limbs] = upshift;\n        remainder = (value >> remainder_shift);\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_sub<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut borrow: u128 = 0;\n    let mut borrow_in: u128 = 0;\n    for i in 0..N {\n        borrow = ((rhs[i] + borrow_in) > lhs[i]) as u128;\n        let sub = (borrow << 120) + lhs[i] as u128 - rhs[i] as u128 - borrow_in;\n        result[i] = sub;\n        borrow_in = borrow;\n    }\n    result\n}\n\npub(crate) unconstrained fn __helper_add<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    result\n}\n\npub(crate) unconstrained fn __shr1<let N: u32>(mut input: [u128; N]) -> [u128; N] {\n    let value = input[N - 1];\n    input[N - 1] = value >> 1;\n\n    let mut remainder = (value & 1) << 119;\n\n    for i in 1..N {\n        let value = input[N - 1 - i];\n        input[N - 1 - i] = (value >> 1) + remainder;\n        remainder = (value << 119) & TWO_POW_119;\n    }\n    input\n}\n\npub(crate) unconstrained fn __get_msb<let N: u32>(val: [u128; N]) -> u32 {\n    let mut count = 0;\n    for i in 0..N {\n        let v = val[(N - 1 - i)];\n        if (v > 0) {\n            count = 120 * (N - 1 - i) + get_msb(v);\n            break;\n        }\n    }\n    count\n}\n\npub(crate) fn __get_bit<let N: u32>(input: [u128; N], bit: u32) -> bool {\n    let segment_index: u32 = bit / 120;\n    let uint_index = (bit % 120) as u128;\n    let limb: u128 = input[segment_index];\n    let value = (limb >> uint_index) & 1;\n    value == 1\n}\n\npub(crate) fn __into_field_array<let N: u32>(input: [u128; N]) -> [Field; N] {\n    let mut result: [Field; N] = [0; N];\n    for i in 0..N {\n        result[i] = input[i] as Field;\n    }\n    result\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_helpers.nr"},"99":{"source":"use crate::fns::constrained_ops::derive_from_seed;\nuse crate::fns::unconstrained_helpers::{\n    __barrett_reduction, __get_bit, __get_msb, __helper_add, __helper_sub, __increment,\n    __multiplicative_generator, __primitive_root_log_size, __shl, __shr,\n    __tonelli_shanks_sqrt_inner_loop_check,\n};\nuse crate::params::BigNumParams as P;\nuse crate::utils::split_bits;\nuse super::unconstrained_helpers::__shr1;\n\npub(crate) unconstrained fn __one<let N: u32>() -> [u128; N] {\n    let mut limbs: [u128; N] = [0; N];\n    limbs[0] = 1;\n    limbs\n}\n\n/// Deterministically derives a big_num from a seed value.\n///\n/// Takes a seed byte array and generates a big_num in the range [0, modulus-1].\n///\n/// ## Value Parameters\n///\n/// - `params`: The BigNum parameters containing modulus and reduction info\n/// - `seed`:  Input seed bytes to derive from.\n///\n/// ## Returns\n///\n///  An array of field elements derived from the seed (the limbs of the big_num)\npub(crate) unconstrained fn __derive_from_seed<let N: u32, let MOD_BITS: u32, let SeedBytes: u32>(\n    params: P<N, MOD_BITS>,\n    seed: [u8; SeedBytes],\n) -> [u128; N] {\n    let out = derive_from_seed::<N, MOD_BITS, SeedBytes>(params, seed);\n    out\n}\n\npub(crate) unconstrained fn __eq<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    lhs == rhs\n}\n\npub(crate) unconstrained fn __is_zero<let N: u32>(limbs: [u128; N]) -> bool {\n    let mut result: bool = true;\n    for i in 0..N {\n        result = result & (limbs[i] == 0);\n    }\n\n    result\n}\n\n/**\n* @brief given an input `x`, compute `2p - x` (unconstrained)\n*\n* @description we subtract the input from double the modulus, because all constrained BigNum operations\n*              only guarantee that the output is in the range [0, ceil(log2(p))].\n*              I.E. the input may be larger than the modulus `p`.\n*              In order to ensure this operation does not underflow, we compute `2p - x` instead of `p - x`.\n*              N.B. constrained BigNum operations do not fully constrain outputs to be in the range [0, p-1]\n*              because such a check is expensive and usually unneccesary.\n*/\npub(crate) unconstrained fn __neg<let N: u32>(modulus: [u128; N], limbs: [u128; N]) -> [u128; N] {\n    __helper_sub(modulus, limbs)\n}\n\npub(crate) unconstrained fn __add<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (lhs[i] + rhs[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n    // check if the result is greater than the modulus\n    if __gte(result, modulus) {\n        __helper_sub(result, modulus)\n    } else {\n        result\n    }\n}\n\n/**\n* @brief given inputs `x, y` compute 2p + x - y (unconstrained)\n* @description see `__neg` for why we use 2p instead of p\n**/\npub(crate) unconstrained fn __sub<let N: u32>(\n    modulus: [u128; N],\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    __add(modulus, lhs, __neg(modulus, rhs))\n}\n\npub(crate) unconstrained fn __mul_with_quotient<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut mul: [Field; 2 * N] = [0; 2 * N];\n    for i in 0..N {\n        for j in 0..N {\n            mul[i + j] += (lhs[i] as Field * rhs[j] as Field);\n        }\n    }\n    let to_reduce: [u128; (N * 2)] = split_bits::__normalize_limbs(mul, 2 * N);\n    let (q, r) = __barrett_reduction(to_reduce, params.redc_param, MOD_BITS, params.modulus);\n    (q, r)\n}\n\npub(crate) unconstrained fn __mul<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    lhs: [u128; N],\n    rhs: [u128; N],\n) -> [u128; N] {\n    let (_, b) = __mul_with_quotient::<_, MOD_BITS>(params, lhs, rhs);\n    b\n}\n\npub(crate) unconstrained fn __div<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> [u128; N] {\n    let inv_divisor: [u128; N] = __invmod::<_, MOD_BITS>(params, divisor);\n    __mul::<_, MOD_BITS>(params, numerator, inv_divisor)\n}\n\n/**\n* @brief __udiv_mod performs *unconstrained* integer division between numerator, divisor \n*\n* i.e. 1. floor(numerator / divisor) = quotient\n*      2. numerator % divisor = remainder\n*      3. divisor * quotient + remainder = numerator\n**/\npub(crate) unconstrained fn __udiv_mod<let N: u32>(\n    numerator: [u128; N],\n    divisor: [u128; N],\n) -> ([u128; N], [u128; N]) {\n    let mut quotient: [u128; N] = [0; N];\n    let mut remainder: [u128; N] = numerator;\n\n    let b = divisor;\n    let numerator_msb = __get_msb(numerator);\n    let divisor_msb = __get_msb(divisor);\n    if divisor_msb > numerator_msb {\n        ([0; N], numerator)\n    } else {\n        let mut bit_difference = __get_msb(remainder) - __get_msb(divisor);\n        let mut accumulator: [u128; N] = __one();\n        let mut divisor = __shl(divisor, bit_difference);\n        accumulator = __shl(accumulator, bit_difference);\n\n        if (__gte(divisor, __increment(remainder))) {\n            divisor = __shr1(divisor);\n            accumulator = __shr1(accumulator);\n        }\n\n        for _ in 0..(N * 120) {\n            if (__gte(remainder, b) == false) {\n                break;\n            }\n            // we've shunted 'divisor' up to have the same bit length as our remainder.\n            // If remainder >= divisor, then a is at least '1 << bit_difference' multiples of b\n            if (__gte(remainder, divisor)) {\n                remainder = __helper_sub(remainder, divisor);\n                // we can use OR here instead of +, as\n                // accumulator is always a nice power of two\n                quotient = __helper_add(quotient, accumulator);\n            }\n            divisor = __shr1(divisor); // >>= 1;\n            accumulator = __shr1(accumulator); //  >>= 1;\n        }\n\n        (quotient, remainder)\n    }\n}\n\npub(crate) unconstrained fn __invmod<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n) -> [u128; N] {\n    let one = __one();\n    let exp = __helper_sub(params.modulus, __helper_add(one, one));\n    __pow::<_, MOD_BITS>(params, val, exp)\n}\n\npub(crate) unconstrained fn __pow<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    val: [u128; N],\n    exponent: [u128; N],\n) -> [u128; N] {\n    let x = exponent;\n    let num_bits = MOD_BITS + 1;\n\n    let mut accumulator: [u128; N] = __one::<N>();\n\n    for i in 0..num_bits {\n        accumulator = __mul::<_, MOD_BITS>(params, accumulator, accumulator);\n        if __get_bit(x, num_bits - i - 1) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, val);\n        }\n    }\n    accumulator\n}\n\npub(crate) unconstrained fn batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]; M],\n) -> [[u128; N]; M] {\n    // TODO: ugly! Will fail if input slice is empty\n\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]; M] = std::mem::zeroed();\n\n    for i in 0..M {\n        temporaries[i] = accumulator;\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]; M] = [[0; N]; M];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..M {\n        let idx = M - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result[idx] = T0;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn batch_invert_slice<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    x: [[u128; N]],\n) -> [[u128; N]] {\n    // TODO: ugly! Will fail if input slice is empty\n    let mut accumulator: [u128; N] = __one::<N>();\n    let mut temporaries: [[u128; N]] = &[];\n    for i in 0..x.len() {\n        temporaries = temporaries.push_back(accumulator);\n        if (!__is_zero(x[i])) {\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[i]);\n        }\n    }\n\n    let mut result: [[u128; N]] = [];\n    accumulator = __invmod::<_, MOD_BITS>(params, accumulator);\n    for i in 0..x.len() {\n        let idx = x.len() - 1 - i;\n        if (!__is_zero(x[idx])) {\n            let T0 = __mul::<_, MOD_BITS>(params, accumulator, temporaries[idx]);\n            accumulator = __mul::<_, MOD_BITS>(params, accumulator, x[idx]);\n            result = result.push_front(T0);\n        } else {\n            result = result.push_front([0; N]);\n        };\n    }\n\n    result\n}\n\n/**\n* @brief compute a modular square root using the Tonelli-Shanks algorithm\n* @details only use for prime fields! Function may infinite loop if used for non-prime fields\n* @note this is unconstrained fn. To constrain a square root, validate that output^2 = self\n* TODO: create fn that constrains nonexistence of square root (i.e. find x where x^2 = -self)\n**/\npub(crate) unconstrained fn __tonelli_shanks_sqrt<let N: u32, let MOD_BITS: u32>(\n    params: P<N, MOD_BITS>,\n    input: [u128; N],\n) -> std::option::Option<[u128; N]> {\n    // Tonelli-shanks algorithm begins by finding a field element Q and integer S,\n    // such that (p - 1) = Q.2^{s}\n    // We can compute the square root of a, by considering a^{(Q + 1) / 2} = R\n    // Once we have found such an R, we have\n    // R^{2} = a^{Q + 1} = a^{Q}a\n    // If a^{Q} = 1, we have found our square root.\n    // Otherwise, we have a^{Q} = t, where t is a 2^{s-1}'th root of unity.\n    // This is because t^{2^{s-1}} = a^{Q.2^{s-1}}.\n    // We know that (p - 1) = Q.w^{s}, therefore t^{2^{s-1}} = a^{(p - 1) / 2}\n    // From Euler's criterion, if a is a quadratic residue, a^{(p - 1) / 2} = 1\n    // i.e. t^{2^{s-1}} = 1\n    // To proceed with computing our square root, we want to transform t into a smaller subgroup,\n    // specifically, the (s-2)'th roots of unity.\n    // We do this by finding some value b,such that\n    // (t.b^2)^{2^{s-2}} = 1 and R' = R.b\n    // Finding such a b is trivial, because from Euler's criterion, we know that,\n    // for any quadratic non-residue z, z^{(p - 1) / 2} = -1\n    // i.e. z^{Q.2^{s-1}} = -1\n    // => z^Q is a 2^{s-1}'th root of -1\n    // => z^{Q^2} is a 2^{s-2}'th root of -1\n    // Since t^{2^{s-1}} = 1, we know that t^{2^{s - 2}} = -1\n    // => t.z^{Q^2} is a 2^{s - 2}'th root of unity.\n    // We can iteratively transform t into ever smaller subgroups, until t = 1.\n    // At each iteration, we need to find a new value for b, which we can obtain\n    // by repeatedly squaring z^{Q}\n    let one = __one();\n    let primitive_root_log_size = __primitive_root_log_size::<_, MOD_BITS>(params);\n    let Q = __shr(\n        __helper_sub(params.modulus, one),\n        primitive_root_log_size - 1,\n    );\n    let two = __helper_add(one, one);\n    let Q_minus_one_over_two = __shr(__helper_sub(Q, two), 2);\n    let mut z = __multiplicative_generator::<_, MOD_BITS>(params); // the generator is a non-residue\n    let mut b = __pow::<_, MOD_BITS>(params, input, Q_minus_one_over_two);\n    let mut r = __mul::<_, MOD_BITS>(params, input, b);\n    let mut t = __mul::<_, MOD_BITS>(params, r, b);\n    let mut check: [u128; N] = t;\n    for _ in 0..primitive_root_log_size - 1 {\n        check = __mul::<_, MOD_BITS>(params, check, check);\n    }\n    let mut result = Option::none();\n    if (__eq(check, one)) {\n        let mut t1 = __pow::<_, MOD_BITS>(params, z, Q_minus_one_over_two);\n        let mut t2 = __mul::<_, MOD_BITS>(params, t1, z);\n        let mut c = __mul::<_, MOD_BITS>(params, t2, t1);\n        let mut m: u32 = primitive_root_log_size;\n        // tonelli shanks inner 1\n        // (if t2m == 1) then skip\n        // else increase i and square t2m and go again\n        // algorithm runtime should only be max the number of bits in modulus\n        for _ in 0..MOD_BITS {\n            if (__eq(t, one)) {\n                result = Option::some(r);\n                break;\n            }\n            let mut t2m = t;\n            // while loop time\n            let i = __tonelli_shanks_sqrt_inner_loop_check::<_, MOD_BITS>(params, t2m, 0);\n            let mut j = m - i - 1;\n            b = c;\n            for _ in 0..j {\n                // how big\n                if (j == 0) {\n                    break;\n                }\n                b = __mul(params, b, b);\n                //j -= 1;\n            }\n            c = __mul::<_, MOD_BITS>(params, b, b);\n            t = __mul::<_, MOD_BITS>(params, t, c);\n            r = __mul::<_, MOD_BITS>(params, r, b);\n            m = i;\n        }\n    }\n    result\n}\n\npub(crate) unconstrained fn __gte<let N: u32>(lhs: [u128; N], rhs: [u128; N]) -> bool {\n    let mut result = false;\n    let mut early_exit = false;\n    for i in 0..(N) {\n        let idx = (N) - 1 - i;\n        if (rhs[idx] == lhs[idx]) {\n            continue;\n        }\n\n        result = rhs[idx] < lhs[idx];\n        early_exit = true;\n        break;\n    }\n    if early_exit {\n        result\n    } else {\n        lhs[0] == rhs[0]\n    }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/fns/unconstrained_ops.nr"},"101":{"source":"pub struct BigNumParams<let N: u32, let MOD_BITS: u32> {\n    pub has_multiplicative_inverse: bool,\n\n    // @brief modulus: all BigNum operations are evaluated modulo this value\n    pub modulus: [u128; N],\n\n    // @brief double_modulus: used when performing negations and subtractions\n    // @note we borrow 1 from the last limb. This is for easing up the operations that might underflow\n    pub double_modulus: [u128; N],\n\n    // @brief redc_param used for __barrett_reduction. See https://en.wikipedia.org/wiki/Barrett_reduction\n    pub redc_param: [u128; N],\n}\n\nimpl<let N: u32, let MOD_BITS: u32> BigNumParams<N, MOD_BITS> {\n    pub fn new(\n        has_multiplicative_inverse: bool,\n        modulus: [u128; N],\n        redc_param: [u128; N],\n    ) -> Self {\n        Self {\n            has_multiplicative_inverse,\n            modulus,\n            double_modulus: get_double_modulus(modulus),\n            redc_param,\n        }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for BigNumParams<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        (self.has_multiplicative_inverse == other.has_multiplicative_inverse)\n            & (self.modulus == other.modulus)\n            & (self.double_modulus == other.double_modulus)\n            & (self.redc_param == other.redc_param)\n    }\n}\n\nfn get_double_modulus<let N: u32>(modulus: [u128; N]) -> [u128; N] {\n    let TWO_POW_120: u128 = 0x1000000000000000000000000000000;\n    let mut result: [u128; N] = [0; N];\n    let mut carry: u128 = 0;\n    for i in 0..N {\n        let mut add_term = (modulus[i] + modulus[i] + carry);\n        carry = add_term >> 120;\n        add_term = add_term - (carry << 120);\n        result[i] = add_term;\n    }\n\n    result[0] += TWO_POW_120;\n    for i in 1..N - 1 {\n        result[i] += (TWO_POW_120 - 1);\n    }\n    result[N - 1] -= 1;\n    result\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/params.nr"},"102":{"source":"use crate::params::BigNumParams;\nuse crate::utils::map::map;\n\nuse crate::fns::{\n    constrained_ops::{\n        add, assert_is_not_equal, cmp, derive_from_seed, div, eq, is_zero, mul, neg, sub, udiv,\n        udiv_mod, umod, validate_in_field, validate_in_range,\n    },\n    serialization::{from_be_bytes, from_le_bytes, to_be_bytes, to_le_bytes},\n    unconstrained_ops::{\n        __add, __derive_from_seed, __div, __eq, __invmod, __is_zero, __mul, __neg, __pow, __sub,\n        __tonelli_shanks_sqrt, __udiv_mod,\n    },\n};\nuse std::{cmp::Ordering, ops::Neg};\n\npub struct RuntimeBigNum<let N: u32, let MOD_BITS: u32> {\n    pub limbs: [u128; N],\n    pub params: BigNumParams<N, MOD_BITS>,\n}\n\n// All functions prefixed `__` are unconstrained!\n// They're not actually decorated as `unconstrained` because to return the `params` (as part of Self) from an `unconstrained` fn would cause range constraints. Instead, each `__` fn wraps a call to an unconstrained fn, so that the already-range-constrained `params` can be inserted into Self after the unconstrained call.\nimpl<let N: u32, let MOD_BITS: u32> RuntimeBigNum<N, MOD_BITS> {\n\n    pub fn zero(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let limbs: [u128; N] = [0; N];\n        Self { limbs, params }\n    }\n\n    pub fn one(params: BigNumParams<N, MOD_BITS>) -> Self {\n        let mut result = RuntimeBigNum::zero(params);\n        result.limbs[0] = 1;\n        result\n    }\n\n    pub fn derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub unconstrained fn __derive_from_seed<let SeedBytes: u32>(\n        params: BigNumParams<N, MOD_BITS>,\n        seed: [u8; SeedBytes],\n    ) -> Self {\n        let limbs = __derive_from_seed::<_, MOD_BITS, _>(params, seed);\n        Self { limbs, params }\n    }\n\n    pub fn from_slice(params: BigNumParams<N, MOD_BITS>, limbs: [u128]) -> Self {\n        Self { limbs: limbs.as_array(), params }\n    }\n\n    pub fn from_array(params: BigNumParams<N, MOD_BITS>, limbs: [u128; N]) -> Self {\n        Self { limbs, params }\n    }\n\n    pub fn from_be_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_be_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn from_le_bytes(params: BigNumParams<N, MOD_BITS>, x: [u8; (MOD_BITS + 7) / 8]) -> Self {\n        Self { limbs: from_le_bytes::<_, MOD_BITS>(x), params }\n    }\n\n    pub fn to_be_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_be_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn to_le_bytes(self) -> [u8; (MOD_BITS + 7) / 8] {\n        to_le_bytes::<_, MOD_BITS>(self.limbs)\n    }\n\n    pub fn modulus(self) -> Self {\n        let params = self.params;\n        Self { limbs: params.modulus, params }\n    }\n\n    pub fn modulus_bits() -> u32 {\n        MOD_BITS\n    }\n\n    pub fn num_limbs() -> u32 {\n        N\n    }\n\n    // fn get(self) -> [Field] {\n    //     self.get_limbs()\n    // }\n\n    pub fn get_limbs(self) -> [u128; N] {\n        self.limbs\n    }\n\n    pub fn get_limb(self, idx: u32) -> u128 {\n        self.limbs[idx]\n    }\n\n    pub fn set_limb(&mut self, idx: u32, value: u128) {\n        self.limbs[idx] = value;\n    }\n\n    pub unconstrained fn __eq(self, other: Self) -> bool {\n        assert(self.params == other.params);\n        __eq(self.limbs, other.limbs)\n    }\n\n    pub unconstrained fn __is_zero(self) -> bool {\n        __is_zero(self.limbs)\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __neg(self) -> Self {\n        let params = self.params;\n        let limbs = unsafe { __neg(params.modulus, self.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __add(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __sub(params.modulus, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        let limbs = unsafe { __mul::<_, MOD_BITS>(params, self.limbs, other.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        let limbs = unsafe { __div::<_, MOD_BITS>(params, self.limbs, divisor.limbs) };\n        Self { params, limbs }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = unsafe { __udiv_mod(self.limbs, divisor.limbs) };\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __invmod(self) -> Self {\n        let params = self.params;\n        assert(params.has_multiplicative_inverse);\n        let limbs = unsafe { __invmod::<_, MOD_BITS>(params, self.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __pow(self, exponent: Self) -> Self {\n        let params = self.params;\n        assert(params == exponent.params);\n        let limbs = unsafe { __pow::<_, MOD_BITS>(params, self.limbs, exponent.limbs) };\n        Self { limbs, params }\n    }\n\n    // UNCONSTRAINED! (Hence `__` prefix).\n    pub fn __tonelli_shanks_sqrt(self) -> std::option::Option<Self> {\n        let params = self.params;\n        let maybe_limbs = unsafe { __tonelli_shanks_sqrt(params, self.limbs) };\n        maybe_limbs.map(|limbs| Self { limbs, params })\n    }\n\n    pub fn validate_in_field(self: Self) {\n        let params = self.params;\n        validate_in_field::<_, MOD_BITS>(params, self.limbs);\n    }\n\n    pub fn validate_in_range(self) {\n        validate_in_range::<_, _, MOD_BITS>(self.limbs);\n    }\n\n    pub fn assert_is_not_equal(self, other: Self) {\n        let params = self.params;\n        assert(params == other.params);\n        assert_is_not_equal(params, self.limbs, other.limbs);\n    }\n\n    pub fn udiv_mod(self, divisor: Self) -> (Self, Self) {\n        let params = self.params;\n        assert(params == divisor.params);\n        let (q, r) = udiv_mod::<_, MOD_BITS>(params, self.limbs, divisor.limbs);\n        (Self { limbs: q, params }, Self { limbs: r, params })\n    }\n\n    pub fn udiv(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: udiv::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn umod(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: umod::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n\n    pub fn is_zero(self) -> bool {\n        is_zero::<N, MOD_BITS>(self.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Add for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn add(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: add::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Sub for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    fn sub(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: sub::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Mul for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Try to craft quadratic relations and directly evaluate them\n    //       via evaluate_quadratic_expression\n    // e.g. performing a sum of multiple multiplications and additions via `evaluate_quadratic_expression`\n    //      will create much fewer constraints than calling `mul` and `add` directly\n    fn mul(self, other: Self) -> Self {\n        let params = self.params;\n        assert(params == other.params);\n        Self { limbs: mul::<_, MOD_BITS>(params, self.limbs, other.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::ops::Div for RuntimeBigNum<N, MOD_BITS> {\n    // Note: this method is expensive! Witness computation is extremely expensive as it requires modular exponentiation\n    fn div(self, divisor: Self) -> Self {\n        let params = self.params;\n        assert(params == divisor.params);\n        Self { limbs: div::<_, MOD_BITS>(params, self.limbs, divisor.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> Neg for RuntimeBigNum<N, MOD_BITS> {\n    fn neg(self) -> Self {\n        let params = self.params;\n        Self { limbs: neg::<_, MOD_BITS>(params, self.limbs), params }\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Eq for RuntimeBigNum<N, MOD_BITS> {\n    fn eq(self, other: Self) -> bool {\n        let params = self.params;\n        assert(params == other.params);\n        eq::<_, MOD_BITS>(params, self.limbs, other.limbs)\n    }\n}\n\nimpl<let N: u32, let MOD_BITS: u32> std::cmp::Ord for RuntimeBigNum<N, MOD_BITS> {\n    fn cmp(self, other: Self) -> Ordering {\n        assert(self.params == other.params);\n        cmp::<_, MOD_BITS>(self.limbs, other.limbs)\n    }\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __compute_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) -> (RuntimeBigNum<N, MOD_BITS>, RuntimeBigNum<N, MOD_BITS>) {\n    let (q_limbs, r_limbs) = unsafe {\n        crate::fns::expressions::compute_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n            params,\n            map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            lhs_flags,\n            map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n            rhs_flags,\n            map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n            linear_flags,\n        )\n    };\n    (RuntimeBigNum { limbs: q_limbs, params }, RuntimeBigNum { limbs: r_limbs, params })\n}\n\npub fn evaluate_quadratic_expression<let N: u32, let MOD_BITS: u32, let LHS_N: u32, let RHS_N: u32, let NUM_PRODUCTS: u32, let ADD_N: u32>(\n    params: BigNumParams<N, MOD_BITS>,\n    lhs_terms: [[RuntimeBigNum<N, MOD_BITS>; LHS_N]; NUM_PRODUCTS],\n    lhs_flags: [[bool; LHS_N]; NUM_PRODUCTS],\n    rhs_terms: [[RuntimeBigNum<N, MOD_BITS>; RHS_N]; NUM_PRODUCTS],\n    rhs_flags: [[bool; RHS_N]; NUM_PRODUCTS],\n    linear_terms: [RuntimeBigNum<N, MOD_BITS>; ADD_N],\n    linear_flags: [bool; ADD_N],\n) {\n    crate::fns::expressions::evaluate_quadratic_expression::<_, MOD_BITS, _, _, _, _>(\n        params,\n        map(lhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        lhs_flags,\n        map(rhs_terms, |bns| map(bns, |bn| RuntimeBigNum::get_limbs(bn))),\n        rhs_flags,\n        map(linear_terms, |bn| RuntimeBigNum::get_limbs(bn)),\n        linear_flags,\n    )\n}\n\n// UNCONSTRAINED! (Hence `__` prefix).\npub fn __batch_invert<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>; M],\n) -> [RuntimeBigNum<N, MOD_BITS>; M] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = unsafe {\n        crate::fns::unconstrained_ops::batch_invert::<_, MOD_BITS, _>(\n            params,\n            x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n        )\n    };\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub unconstrained fn __batch_invert_slice<let N: u32, let MOD_BITS: u32, let M: u32>(\n    x: [RuntimeBigNum<N, MOD_BITS>],\n) -> [RuntimeBigNum<N, MOD_BITS>] {\n    let params = x[0].params;\n    assert(params.has_multiplicative_inverse);\n    let all_limbs = crate::fns::unconstrained_ops::batch_invert_slice::<_, MOD_BITS>(\n        params,\n        x.map(|bn| RuntimeBigNum::get_limbs(bn)),\n    );\n\n    all_limbs.map(|limbs| RuntimeBigNum { limbs, params })\n}\n\npub fn conditional_select<let N: u32, let MOD_BITS: u32>(\n    lhs: RuntimeBigNum<N, MOD_BITS>,\n    rhs: RuntimeBigNum<N, MOD_BITS>,\n    predicate: bool,\n) -> RuntimeBigNum<N, MOD_BITS> {\n    let params = lhs.params;\n    assert(params == rhs.params);\n    let limbs = if predicate { lhs.limbs } else { rhs.limbs };\n    RuntimeBigNum { limbs: limbs, params }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/runtime_bignum.nr"},"109":{"source":"use crate::constants::TWO_POW_120;\n\nunconstrained fn split_120_bits(mut x: Field) -> (u128, u128) {\n    // Here we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such that the field division is equivalent to integer division.\n    let low = (x as u128) % TWO_POW_120;\n    let high = ((x - low as Field) / TWO_POW_120 as Field) as u128;\n    (low, high)\n}\n\npub(crate) unconstrained fn __normalize_limbs<let N: u32>(\n    input: [Field; N],\n    range: u32,\n) -> [u128; N] {\n    let mut normalized: [u128; N] = [0; N];\n    let mut next: Field = input[0];\n    for i in 0..(range - 1) {\n        let (lo, hi) = split_120_bits(next);\n        normalized[i] = lo as u128;\n        next = input[i + 1] + hi as Field;\n    }\n    {\n        let (lo, hi) = split_120_bits(next);\n\n        normalized[range - 1] = lo as u128;\n        assert(hi == 0);\n    }\n    normalized\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir-bignum/v0.8.0/src/utils/split_bits.nr"},"116":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"141":{"source":"use dep::bignum::RuntimeBigNum;\nuse sha1::sha1;\nuse sha256;\nuse sha512::{sha384, sha512};\n\nglobal SHA1_HASH_LEN: u32 = 20;\nglobal SHA256_HASH_LEN: u32 = 32;\nglobal SHA384_HASH_LEN: u32 = 48;\nglobal SHA512_HASH_LEN: u32 = 64;\n\nfn reverse_array<let N: u32>(array: [u8; N]) -> [u8; N] {\n    let mut reversed = [0 as u8; N];\n    for i in 0..N {\n        reversed[i] = array[N - i - 1];\n    }\n    reversed\n}\n\nfn get_array_slice<let N: u32, let M: u32>(array: [u8; N], start: u32, end: u32) -> [u8; M] {\n    assert(end - start <= M);\n    let mut slice = [0 as u8; M];\n    for i in 0..M {\n        if i < end - start {\n            slice[i] = array[start + i];\n        }\n    }\n    slice\n}\n\nfn pow(base: u32, exp: u32) -> u32 {\n    let mut result = 1;\n    for _ in 0..exp {\n        result *= base;\n    }\n    result\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA1 as the hash function\n **/\nfn mgf1_sha1<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA1_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA1_HASH_LEN as Field + 1);\n\n    // SHA1_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA1_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA1_HASH_LEN] = [0; SHA1_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block using SHA-1\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha1::sha1_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA1_HASH_LEN {\n            if i * SHA1_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA1_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA256 as the hash function\n **/\nfn mgf1_sha256<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA256_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA256_HASH_LEN as Field + 1);\n\n    // SHA256_HASH_LEN bytes are added at each iteration and there is at least 1 iteration\n    // so if SHA256_HASH_LEN is not enough to fill MASK_LEN bytes in one iteration,\n    // another one is required and so on.\n    let iterations = (MASK_LEN / SHA256_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA256_HASH_LEN] = [0; SHA256_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        // Hash the block\n        // First SEED_LEN bytes are the seed, next 4 bytes are the counter\n        hashed = sha256::sha256_var(block, SEED_LEN as u64 + 4);\n\n        // Copy hashed output to mask\n        for j in 0..SHA256_HASH_LEN {\n            if i * SHA256_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA256_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA384 as the hash function\n **/\nfn mgf1_sha384<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA384_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA384_HASH_LEN as Field + 1);\n\n    // SHA384_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA384_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA384_HASH_LEN] = [0; SHA384_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha384::sha384_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA384_HASH_LEN {\n            if i * SHA384_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA384_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Generate a mask from a seed using the MGF1 algorithm with SHA512 as the hash function\n **/\nfn mgf1_sha512<let SEED_LEN: u32, let MASK_LEN: u32>(seed: [u8; SEED_LEN]) -> [u8; MASK_LEN] {\n    // MASK_LEN must be less than 2^32 * SHA512_HASH_LEN\n    dep::std::field::bn254::assert_lt(MASK_LEN as Field, 0xffffffff * SHA512_HASH_LEN as Field + 1);\n\n    // SHA512_HASH_LEN bytes are added at each iteration\n    let iterations = (MASK_LEN / SHA512_HASH_LEN) + 1;\n\n    let mut mask: [u8; MASK_LEN] = [0; MASK_LEN];\n    let mut hashed: [u8; SHA512_HASH_LEN] = [0; SHA512_HASH_LEN];\n\n    for i in 0..iterations {\n        let mut block: [u8; SEED_LEN + 4] = [0; SEED_LEN + 4];\n\n        // Copy seed to block\n        for j in 0..SEED_LEN {\n            block[j] = seed[j];\n        }\n\n        // Add counter to block\n        let counter_bytes: [u8; 4] = (i as Field).to_be_bytes();\n        for j in 0..4 {\n            block[SEED_LEN + j] = counter_bytes[j];\n        }\n\n        let block_vec = BoundedVec::from_parts(block, SEED_LEN + 4);\n        hashed = sha512::sha512_var(block_vec);\n\n        // Copy hashed output to mask\n        for j in 0..SHA512_HASH_LEN {\n            if i * SHA512_HASH_LEN + j < MASK_LEN {\n                mask[i * SHA512_HASH_LEN + j] = hashed[j];\n            }\n        }\n    }\n\n    mask\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-1 to the original message hash\n **/\nfn compare_signature_sha1<let N: u32>(padded_sha1_hash: [u8; N], msg_hash: [u8; 20]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..20 {\n        // Padded hash is reversed\n        assert(padded_sha1_hash[19 - i] == msg_hash[i]);\n    }\n\n    // SHA-1 ASN.1 DER identifier\n    let hash_prefix: [u8; 15] = [20, 4, 0, 5, 26, 2, 3, 14, 43, 5, 6, 9, 48, 33, 48];\n\n    for i in 20..35 {\n        assert(hash_prefix[i - 20] == padded_sha1_hash[i]);\n    }\n\n    assert(padded_sha1_hash[35] == 0);\n\n    // Sub 20 bytes for hash, 15 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 38;\n    for i in 36..N {\n        if i < 36 + ps_len {\n            // PS padding\n            assert(padded_sha1_hash[i] == 255);\n        } else if i == 36 + ps_len {\n            // Pad 0x01\n            assert(padded_sha1_hash[i] == 1);\n        } else if i == 37 + ps_len {\n            // 0x00\n            assert(padded_sha1_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha1_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature to the original message hash\n * @details Taken from https://github.com/richardliang/noir-rsa\n **/\nfn compare_signature_sha256<let N: u32>(padded_sha256_hash: [u8; N], msg_hash: [u8; 32]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    // NOTE: Assume MAX_BYTES < 2^32 bit number. MAX_BYTES of 259 > 2^8 bits so need to cast it to u32\n    for i in 0..32 {\n        // Padded hash is reversed\n        assert(padded_sha256_hash[31 - i] == msg_hash[i]);\n    }\n\n    let hash_prefix: [u8; 19] =\n        [32, 4, 0, 5, 1, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 49, 48];\n\n    for i in 32..51 {\n        assert(hash_prefix[i - 32] == padded_sha256_hash[i]);\n    }\n\n    assert(padded_sha256_hash[51] == 0);\n\n    // Sub 32 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 54;\n    for i in 52..N {\n        if i < 52 + ps_len {\n            // PS padding which depends on RSA modulus / sig length. 1024 bits = 128 bytes = 128 - 54 = 74 bytes of 0xFF padding\n            assert(padded_sha256_hash[i] == 255);\n        } else if i == 52 + ps_len {\n            // Pad 0x01\n            assert(padded_sha256_hash[i] == 1);\n        } else if i == 53 + ps_len {\n            // 0x00\n            assert(padded_sha256_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha256_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-384 to the original message hash\n **/\nfn compare_signature_sha384<let N: u32>(padded_sha384_hash: [u8; N], msg_hash: [u8; 48]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..48 {\n        // Padded hash is reversed\n        assert(padded_sha384_hash[47 - i] == msg_hash[i]);\n    }\n\n    // SHA-384 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [48, 4, 0, 5, 2, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 65, 48];\n\n    for i in 48..67 {\n        assert(hash_prefix[i - 48] == padded_sha384_hash[i]);\n    }\n\n    assert(padded_sha384_hash[67] == 0);\n\n    // Sub 48 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 70;\n    for i in 68..N {\n        if i as u32 < 68 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha384_hash[i] == 255);\n        } else if i as u32 == 68 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha384_hash[i] == 1);\n        } else if i as u32 == 69 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha384_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha384_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Compare a recovered byte hash from an RSA signature using SHA-512 to the original message hash\n **/\nfn compare_signature_sha512<let N: u32>(padded_sha512_hash: [u8; N], msg_hash: [u8; 64]) -> bool {\n    // Get length of sig (e.g. 1048 = 128 bytes, 2048 = 256 bytes)\n    for i in 0..64 {\n        // Padded hash is reversed\n        assert(padded_sha512_hash[63 - i] == msg_hash[i]);\n    }\n\n    // SHA-512 ASN.1 DER identifier\n    let hash_prefix: [u8; 19] =\n        [64, 4, 0, 5, 3, 2, 4, 3, 101, 1, 72, 134, 96, 9, 6, 13, 48, 81, 48];\n\n    for i in 64..83 {\n        assert(hash_prefix[i - 64] == padded_sha512_hash[i]);\n    }\n\n    assert(padded_sha512_hash[83] == 0);\n\n    // Sub 64 bytes for hash, 19 bytes for prefix, 1 byte for 0, 1 byte for 1, 1 byte for 0\n    let ps_len = N - 86;\n    for i in 84..N {\n        if i as u32 < 84 + ps_len as u32 {\n            // PS padding\n            assert(padded_sha512_hash[i] == 255);\n        } else if i as u32 == 84 + ps_len as u32 {\n            // Pad 0x01\n            assert(padded_sha512_hash[i] == 1);\n        } else if i as u32 == 85 + ps_len as u32 {\n            // 0x00\n            assert(padded_sha512_hash[i] == 0);\n        } else {\n            // Padded with 0 until MAX_BYTES\n            assert(padded_sha512_hash[i] == 0);\n        }\n    }\n\n    true\n}\n\n/**\n * @brief Exponentiate a signature by a given exponent using binary exponentiation\n * @details This function handles the exponentiation of a signature by any given exponent.\n * Uses the square-and-multiply algorithm for efficient modular exponentiation.\n * @param sig The signature to exponentiate\n * @param exponent The exponent to use (any positive integer)\n * @return The exponentiated signature\n */\nfn exponentiate_signature<let NumLimbs: u32, let ModBits: u32>(\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> RuntimeBigNum<NumLimbs, ModBits> {\n    assert((exponent > 0) & (exponent < 131072), \"Exponent must be positive and less than 2^17\");\n\n    // Binary exponentiation (square-and-multiply algorithm)\n    let mut result = RuntimeBigNum::one(sig.params);\n    let mut base = sig;\n    let mut exp = exponent;\n\n    // We assume the exponent won't be more than to 2^17 so we can\n    // have less iterations\n    for _ in 0..17 {\n        if exp > 0 {\n            // If the exponent is odd, multiply result by current base\n            if exp % 2 == 1 {\n                result = result * base;\n            }\n\n            // Square the base for the next bit\n            base = base * base;\n\n            // Divide exponent by 2 (move to the next bit)\n            exp = exp / 2;\n        }\n    }\n\n    result\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-1\n *\n * @param msg_hash The SHA-1 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha1_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha1_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha1(padded_sha1_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature generated via the pkcs1v15 signature scheme with SHA-256\n * @note The `exponent` can be any positive integer (commonly 3 or 65537 are used for RSA)\n * Rough cost: 2,048 bit RSA: 26,888 gates per verification\n *             1,024 bit RSA: 11,983 gates per verification\n * A circuit that verifies 1 signature (and does nothing else) will cost ~32k due to initialization costs of lookup tables\n **/\npub fn verify_sha256_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha256_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha256(padded_sha256_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-384\n *\n * @param msg_hash The SHA-384 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha384_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha384_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha384(padded_sha384_hash_bytes, msg_hash)\n}\n\n/**\n * @brief Verify an RSA signature using the PKCS#1 v1.5 padding scheme with SHA-512\n *\n * @param msg_hash The SHA-512 hash of the message being verified\n * @param sig The RSA signature\n * @param exponent The public exponent (any positive integer)\n * @return True if the signature is valid, false otherwise\n */\npub fn verify_sha512_pkcs1v15<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n    let mut padded_sha512_hash_bytes: [u8; (ModBits + 7) / 8] = exponentiated.to_le_bytes();\n    compare_signature_sha512(padded_sha512_hash_bytes, msg_hash)\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-1.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha1_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 20],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 20; // SHA-1 produces 20-byte hashes\n    let s_len = 20; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 20 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 21 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 21 = 235 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 21 = 107 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 21] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-1\n    let db_mask: [u8; (ModBits + 7) / 8 - 21] = mgf1_sha1(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 21];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 20] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 48]; // 8 + h_len + s_len = 8 + 20 + 20 = 48\n    for i in 8..28 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 28..48 {\n        m_prime[i] = salt[i - 28];\n    }\n\n    // Compute H' using SHA-1\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 48);\n    let h_prime = sha1::sha1_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha256_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 32],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 32;\n    let s_len = 32;\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L242\n    let offset = key_len - em_len;\n    // As the hash is 32 bytes and we also remove the 0xBC at the end, we have up to NumBytes - 33 bytes left for DB\n    // For example, for 2048 bit RSA (i.e. 256 bytes), we have 256 - 33 = 223 bytes left for DB\n    // and for 1024 bit RSA (i.e. 128 bytes), we have 128 - 33 = 95 bytes left for DB\n    let masked_db: [u8; (ModBits + 7) / 8 - 33] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    // c.f. https://github.com/RustCrypto/RSA/blob/aeedb5adf5297892fcb9e11f7c0f6c0157005c58/src/algorithms/pss.rs#L205\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1\n    let db_mask: [u8; (ModBits + 7) / 8 - 33] = mgf1_sha256(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 33];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 32] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 72]; // 8 + h_len + s_len\n    for i in 8..40 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 40..72 {\n        m_prime[i] = salt[i - 40];\n    }\n\n    // Compute H'\n    let h_prime = sha256::sha256_var(m_prime, 72);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-384.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha384_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 48],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 48; // SHA-384 produces 48-byte hashes\n    let s_len = 48; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-384 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 49] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-384\n    let db_mask: [u8; (ModBits + 7) / 8 - 49] = mgf1_sha384(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 49];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 48] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 104]; // 8 + h_len + s_len = 8 + 48 + 48 = 104\n    for i in 8..56 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 56..104 {\n        m_prime[i] = salt[i - 56];\n    }\n\n    // Compute H' using SHA-384\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 104);\n    let h_prime = sha384::sha384_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\n/**\n    * @brief Verify an RSA signature generated via the PSS signature scheme using SHA-512.\n    *\n    * @note The exponent `e` can be any positive integer (commonly 3 or 65537 are used for RSA)\n    **/\npub fn verify_sha512_pss<let NumLimbs: u32, let ModBits: u32>(\n    msg_hash: [u8; 64],\n    sig: RuntimeBigNum<NumLimbs, ModBits>,\n    exponent: u32,\n) -> bool {\n    let exponentiated = exponentiate_signature(sig, exponent);\n\n    // Convert the exponentiated signature to a byte array and reverse it to\n    // get it in big endian order, which is much easier to work with for\n    // the rest of the verification process\n    let em: [u8; (ModBits + 7) / 8] = reverse_array(exponentiated.to_le_bytes());\n\n    // The modulus size in bits minus 1\n    let em_bits = ModBits - 1;\n    // The actual length of the encoded message without any of the leftmost 0s\n    let em_len = (em_bits + 7) / 8;\n    // The length of the modulus in bytes\n    let key_len = (ModBits + 7) / 8;\n    let h_len = 64; // SHA-512 produces 64-byte hashes\n    let s_len = 64; // Salt length is typically equal to hash length\n\n    // Check if emLen < hLen + sLen + 2\n    assert(em_len >= h_len + s_len + 2);\n\n    // Check if eM ends with 0xBC\n    assert_eq(em[em.len() - 1], 0xBC);\n\n    let db_mask_len = em_len - h_len - 1;\n    // In some rare cases, em_len is not equal to key_len (e.g. 1025 bit RSA)\n    // In this case, we'll have a leading zero byte in em that we need to ignore\n    let offset = key_len - em_len;\n\n    // The array slice sizes will be different for SHA-512 compared to SHA-256\n    let masked_db: [u8; (ModBits + 7) / 8 - 65] = get_array_slice(em, offset, db_mask_len + offset);\n    let h = get_array_slice(em, db_mask_len + offset, em.len() - 1);\n\n    // Make sure the 8 * em_len - em_bits leftmost bits are 0\n    let bits_to_mask = 8 - (8 * em_len - em_bits);\n    let mask_value = pow(2, bits_to_mask as u32);\n    assert_eq(masked_db[0] as u32 / mask_value, 0);\n\n    // Generate dbMask using MGF1 with SHA-512\n    let db_mask: [u8; (ModBits + 7) / 8 - 65] = mgf1_sha512(h);\n\n    // Compute DB = maskedDB xor dbMask\n    let mut db = [0 as u8; (ModBits + 7) / 8 - 65];\n    for i in 0..db_mask_len {\n        db[i] = masked_db[i] ^ db_mask[i];\n    }\n\n    // Set leftmost byte of DB to 0\n    db[0] = 0;\n\n    // Check if the leftmost octets of DB are zero\n    for i in 0..(em_len - h_len - s_len - 2) {\n        assert_eq(db[i], 0);\n    }\n\n    // Check if the octet at position emLen - hLen - sLen - 2 is 1\n    assert_eq(db[em_len - h_len - s_len - 2], 1);\n\n    // Extract salt\n    let salt: [u8; 64] = get_array_slice(db, db_mask_len - s_len, db_mask_len);\n\n    // Construct M'\n    // M' = (0x)00 00 00 00 00 00 00 00 || msg_hash || salt\n    let mut m_prime = [0 as u8; 136]; // 8 + h_len + s_len = 8 + 64 + 64 = 136\n    for i in 8..72 {\n        m_prime[i] = msg_hash[i - 8];\n    }\n    for i in 72..136 {\n        m_prime[i] = salt[i - 72];\n    }\n\n    // Compute H' using SHA-512\n    let m_prime_vec = BoundedVec::from_parts(m_prime, 136);\n    let h_prime = sha512::sha512_var(m_prime_vec);\n\n    // Compare H and H'\n    h == h_prime\n}\n\nmod tests {\n\n    use crate::types::{\n        Params1024, Params1025, Params2048, Params4096, RBN1024, RBN1025, RBN2048, RBN4096,\n    };\n    use super::{\n        mgf1_sha1, mgf1_sha256, mgf1_sha384, mgf1_sha512, verify_sha1_pkcs1v15, verify_sha1_pss,\n        verify_sha256_pkcs1v15, verify_sha256_pss, verify_sha384_pkcs1v15, verify_sha384_pss,\n        verify_sha512_pkcs1v15, verify_sha512_pss,\n    };\n    use bignum::params::BigNumParams;\n    use bignum::RuntimeBigNum;\n    use sha1::sha1;\n    use sha512::{sha384, sha512};\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_1024() {\n        // Output of `cargo run -- --msg \"hello world! test#123\" --bits 1024` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            220, 155, 229, 143, 122, 133, 55, 215, 75, 44, 132, 111, 57, 33, 248, 84, 213, 170, 193,\n            96, 253, 57, 124, 13, 251, 42, 92, 147, 105, 172, 233, 85,\n        ];\n\n        let params: BigNumParams<9, 1024> = BigNumParams::new(\n            false,\n            [\n                0xab238ad9cb37979a43aefbf10be8fb,\n                0x31347febe45fe8c2dac1dd30900704,\n                0xa5a9a6b9cd0cc2b9d13bbd4e068263,\n                0x5eac6390f7873fe97ff9bb14a173ea,\n                0xbc41f700c91fd733a2c63177bbdbd4,\n                0x41442bd58769a3595b659a2ec9c6be,\n                0x4ddc91395f330382aa2e2d3fbe147,\n                0x3d008ff255a0bc71c7887f5728ba1,\n                0xb640c3a8f511c64e,\n            ],\n            [\n                0x5d53d2634c6a0918266043968ce263,\n                0x5dd4be3dce0323a492ee9340aec4db,\n                0xf82d0e2e5c8319f01a460c72c01854,\n                0x236e6fc6e62e8a1d522acda5fb3892,\n                0xdaf755619d66e580901aa224d03174,\n                0x8366291616480e7e1f202dbcedda87,\n                0x40ba1202537d1e94561ccc05265586,\n                0x69b993d857ba89ea5de9822aeb4b93,\n                0x167968c0000761a273,\n            ],\n        );\n\n        let signature: RuntimeBigNum<9, 1024> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xc3850e84ea02da3f028ff422f4d6a9,\n                0x9761f0bd9021f76d45c60df0670a19,\n                0xc1ede421a43607ab623ed4d5a17fc8,\n                0x86197b4315206f4d53200b42555831,\n                0xe95783b69db28c26a83706f39d04cd,\n                0x18b178dc1a9ec76fb22b57e4dfa703,\n                0xdd0e19cd5a09ab48e7af4d0e3470e3,\n                0x10004dfab1cf91304e80e6baa4dfc7,\n                0x241c3fd77b90adef,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048() {\n        // Output of `cargo run -- --msg \"Hello World! This is Noir-RSA\"` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            91, 207, 46, 60, 22, 153, 217, 144, 2, 127, 224, 143, 181, 45, 32, 120, 122, 131, 166,\n            79, 166, 183, 43, 158, 116, 105, 73, 207, 196, 77, 33, 5,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0x8d5e7d9daedd6cfd1c9bdf0227e05b,\n                0xbfb937fc4d3cf02cc0af780f3cab44,\n                0xd20637ef7adcf5d238ee87bccc9bca,\n                0xb9db4f2663108e2f8b673f7612ae8b,\n                0x85f894ef669b36bfd3d86b0a28873,\n                0xdcc70e1884e38b8229cce3b884121d,\n                0x35488d1138e0b03e1676f7f5d8a5b3,\n                0xe1a97820e7dcbb4eab35c9b71bb273,\n                0x97d19eb3c63249ddbfcff915863f54,\n                0x3a78c7af6da0f6af0d67b1ca4b6065,\n                0xd7a3c433c020f624821e5e678c7d69,\n                0x52d5b53240feae82ffea3d2a3d9b09,\n                0xb8aad5e19e2163f68997c6fdd71906,\n                0x5db432d06e8b0bf59511100c7894e2,\n                0xadc0bbc4c54da10d1cc88438ea3127,\n                0xece1cf6a1501109cd2734d5893c8d9,\n                0x7196b90acdf06c31b1288064fd0c27,\n                0xc8,\n            ],\n            [\n                0x1b1deccf4dbde852c34a5d6908a0f,\n                0xbc9e5bdab22f023fbcca58692bccf5,\n                0x1f65439685623e45396ff55751c3bf,\n                0x2b6ad2c5f8e3aac15d0ccbab816bfa,\n                0x5ca2e8e3048243c16c708a8030ab0d,\n                0x30079bfeb1fa51e5501581173ca19c,\n                0xff8d5f6bea485fdcc2716327f69ab4,\n                0x36b599d81589416b5b5f037986b999,\n                0x75612e34a4ff29f0a19a7823512f58,\n                0x288b6897929b54c3b26a5faa07c00f,\n                0x4b5675fa13ab7444f1f047d3eb1bbe,\n                0x6ba0ac610ef9f267ab30fe25bb1c84,\n                0xa386b48ee03168d5cea3ecb9dc901f,\n                0xacf1a01f7dba44e050c976142fb1f6,\n                0x97a63b5cb7efc60d3502946aec63cf,\n                0x12cc1d5cab10a1e9e2398d29b9e3ef,\n                0x4635cf25c66e76bba8034df46204fb,\n                0x146f,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xad29e07d16a278de49a371b9760a27,\n                0x86311920cc0e17a3c20cdff4c56dbb,\n                0x863556c6c5247dd83668dd825716ae,\n                0xc247c960945f4485b46c33b87425ca,\n                0x7326463c5c4cd5b08e21b938d9ed9a,\n                0x4f89fe0c82da08a0259eddb34d0da1,\n                0x43a74e76d4e1bd2666f1591889af0d,\n                0x240f7b80f0ff29f4253ee3019f832d,\n                0xc6edd131fbaaf725fd423dac52b362,\n                0x85f9732679242163e8afff44f6104d,\n                0xd3c3bbcb1757013fd6fb80f31dd9a6,\n                0x9008633f15df440e6df6d21ee585a2,\n                0x324df3425ed256e283be5b6b761741,\n                0xc60c1302929bd0e07caa4aeff4e8fd,\n                0x600d804ff13ba8d0e1bc9508714212,\n                0x50f7e75e5751d7edd61167027926be,\n                0x0db41d39442023e1420a8a84fe81d9,\n                0xab,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_3() {\n        // Output of `cargo run -- --msg \"hello world\" -e 3` in the `signature_gen` directory\n        let sha256_hash: [u8; 32] = [\n            185, 77, 39, 185, 147, 77, 62, 8, 165, 46, 82, 215, 218, 125, 171, 250, 196, 132, 239,\n            227, 122, 83, 128, 238, 144, 136, 247, 172, 226, 239, 205, 233,\n        ];\n\n        let params: BigNumParams<18, 2048> = BigNumParams::new(\n            false,\n            [\n                0xe40ee47801326543c8e84b85d567c1,\n                0x5b54ea87f0ce29de1995697b0696fd,\n                0x457078f8fdce68b437cac0970b2452,\n                0x473ec776fee3731b6ab06e35875ddc,\n                0x62dedd594e5f12c80c3ccb5791a6cd,\n                0xecb934b9d8272c5e3a418145345499,\n                0xd1af643b3d785470ed0c6cd633f706,\n                0xb58a57b9e96eccbdfc7c17f0333d4,\n                0x2ebd34b5039fc596504927c282c60d,\n                0x3a44928a74f25fc1043bb37ce4dfa8,\n                0x91448459f9617fac33a2816162ac9e,\n                0x70cb910d9f3e1a78864640ec6c8240,\n                0x9aed33f6b31f1c9de67248a98c180,\n                0x7f1416e032c79488c94b311e87bd9c,\n                0x7191b4ebb1b3fffa949fa48ed01e5,\n                0x350a75cbaeca6bfdd71ca83cdbcae9,\n                0xfb1d274fa207457c6814d42c09f9cf,\n                0xd4,\n            ],\n            [\n                0x803bf4d38110a7d37fdd05f590dee9,\n                0xa68d317c933f37cab5ab4e7c00a3b9,\n                0x476a05a536bf5f2aa1b8850146cba7,\n                0xca297ea8b5528d91d4836ff27c30ab,\n                0x75cf2eaab76eefa12bbd570f1aea9f,\n                0x8f6a8ab877d9c5bcd98c37bdc5c2d3,\n                0xd497db1f6ebe83decacaa647fabea6,\n                0x686b27ca330e25e7a7cf197f6433ef,\n                0xfde04d2225c8308b07580af0058a0f,\n                0xa29fb69777c0e916976243b2b09855,\n                0xf983592285852e7e1c2cb3ae968323,\n                0x673608017f9f5acf67a01b73728d70,\n                0xeeff82521c0bc432a05f4b7444fac0,\n                0x85a89c4d229f60aaa3aa7ac7dac1e2,\n                0xcfecff93bc9fbfe0d6dff6091f2db8,\n                0xf20f047dcb224b4447bd098c07f8c2,\n                0x554bb53cadeb3eaab911a189f90227,\n                0x133b,\n            ],\n        );\n\n        let signature: RuntimeBigNum<18, 2048> = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa250eff812c63eaaeaa3f04641c05f,\n                0xecc09613cb8b289c1f37c8f92e6a05,\n                0x2c0a0510058360c07af65d46f594fd,\n                0x943d67513363d3de430c94a1dafe7c,\n                0x511ec8e9b10bc6c6ff0d6c232ccf92,\n                0x50ffd07b3c093b3f5fc027de847731,\n                0xc268e1489449943fdafdf89ff168c3,\n                0x0b8b7f9f49b492f78fda58d252f23a,\n                0x491c6c4ef836a6a8730b7bf81e865e,\n                0x8746c75fb079d014e419543f56d7f0,\n                0x65804c417d6168a8bc0025d255cebf,\n                0xf695e91b77890b8e3fd775fa56e627,\n                0x5e90001c0218550f4083ae28025a2f,\n                0x526bd4eff34f25f62a698f0470e0a6,\n                0x7f224306a7d9daf536b1559434c6c6,\n                0x88809f16fe1fcea3c87511d9319735,\n                0x7694685fee0bfab4a9196b92ec6f2e,\n                0xa7,\n            ],\n        };\n\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 3));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_38129() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x4f79aee9e865ee89b9695c2ac44903,\n                0xe33ac311e740f4dfc39492d38186d4,\n                0xf513677b71c4cdf88b9011d109402d,\n                0x940eba50ebc0a50b539268b2c9edee,\n                0x6d7b7dc633b0ba7deb34669da59af9,\n                0x69f0b92bd973d83643b54c86302bc8,\n                0xbee39cd038bb54491cab410bc1382d,\n                0xe59688c01aa8491c6522aa467fbdba,\n                0x8731b6ff98f9e1f792d4a4dff8c81d,\n                0x9d1773f064f1ce81301053e3abcc43,\n                0xe80e6137f3ccf06ca669e0d0f14c30,\n                0xefbf9d55ae96471f9fef8d5ac29c46,\n                0x284807c893f7e7af1a39d9c599ba76,\n                0x17491bdeafd3a2c796dd50f2444997,\n                0x21742c4e2dc66d064e36abb50f9c67,\n                0x58f1503ad765979883692dcff55252,\n                0xf613ad8641b9195cb742ac5d3ff778,\n                0xad,\n            ],\n            [\n                0xbd864af583a9911c93c5b92ab68568,\n                0x10d63ed8c0c83e91e945683061045b,\n                0xf38982278a43cfae6438348ae94c9b,\n                0x75133ea58bac5abff54a6e7a165283,\n                0xd3449474e97738f4c6a2d843722783,\n                0x9e3b3c08f360d9f967416af9becf84,\n                0xcd40081688aedd976009f34a964356,\n                0xa27adea282e0227e69ff47203440cb,\n                0x99f812956fd9377b0bed8deb543ede,\n                0x5f655415ed123df19398d5d479401d,\n                0x587d5cae3d0a5b34e3f8b2ca43ade1,\n                0xa4fde6c7f37ea8267d2183519ceb1,\n                0x1ba5bec0bb36c67251aa7678f7c169,\n                0x2e1ddae393d6a4f1a320b15b23b974,\n                0xfc61518efd066b5912b60cfd1d7474,\n                0xf854c457bf3908af1e4934d7c72d1f,\n                0xa44257cffc0c579bf0addd3c75d4df,\n                0x178b,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x98156ae7cbad0e0fbaa9b254c445cf,\n                0x6f3ea82d1faf48ecb60f3f7481f020,\n                0xea0f2df747bbe8a8629c9dc6246da7,\n                0xb635b9de66aa7e600e924c0932b43b,\n                0xa010df8938db4c035c8473f0fd167d,\n                0xe37d1709aae17c76199c99efa5e5a7,\n                0xf8336b32c807dfb62d149fb8353f4e,\n                0xf852a4cc6a84981cd8a0d9eef5510f,\n                0x10c5cae74e75c83e3835906e5eea2a,\n                0xd83e21dc7e49277c86d81144837750,\n                0x72e367e8e2db3320145626438e6e93,\n                0x2129c9c0c2ce89e77661a15c8c7647,\n                0xe9c0b584a2ed003dbe4cadd2cfd87f,\n                0x6e5bd7521c235ab9e18356d089863a,\n                0x28e861ed03b6acc39fa7af5c068fa7,\n                0x4d1a681de2ce54f0d19eb736723af8,\n                0x2042cf79eb42702aab8526c68a64fd,\n                0x90,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 38129));\n    }\n\n    #[test]\n    fn test_verify_sha256_pkcs1v15_2048_exponent_107903() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xf2bc2f4fd3637bb9ccc7e163324dbf,\n                0x88ac5e7a9abee89a393533168e8743,\n                0xa9d1ef7f5677329e23336052001928,\n                0x2fa85860b512fed4ecc0c94388e4dc,\n                0x61b27bbdb48fd8dcf155a1d3242029,\n                0x8119d20bb357bee95c9e6038448ea2,\n                0x4e8759208ccbfc555d32e3fa487af4,\n                0x7608d025ac5a266c1e795b7dc0840b,\n                0xd9df24711a6d2fed0d9248057cf278,\n                0xfbcd7907dc0dacc66a855324c5ae85,\n                0xcf3eca7c8405dfaf7ce39c1b1e526d,\n                0xf2c0a24eb8fd5b2b49eb261b01e5cb,\n                0xb7be784d951012ec79c8df7bb35e10,\n                0x2f7a97fe187189f04fead5f1b00850,\n                0x8246d382cd0821b066e801665eb949,\n                0xbca14eae9a7d4b426639eb99d15c3e,\n                0xfd0f6549b224f1be363e496501a0d8,\n                0xd0,\n            ],\n            [\n                0x66eb2aa6aa1141cacc9004c4aaafcb,\n                0x3983dda53fcc7548cac5070988d128,\n                0xa94b8ccd7bc37c9c6c074ec9dc418e,\n                0x57d6ec9504d4f025839a764cc80cd6,\n                0x5a99da586dd573c790ad0b0cf4048f,\n                0x4c7432020677232539d08b80c4d3,\n                0x338f75091af189cb1d224bd37c6249,\n                0xee6a89be24e36b5f7f1e7c38fae7ba,\n                0x1464843dcb6adf79a5775db61a461c,\n                0x6040e8536fcfa579e6058fe8fe2faf,\n                0x493b2bb04dd77744a5adc46d90652c,\n                0xef49699688680f2bed603abb89bf31,\n                0x5d86fdb1035de7023db8815fea79ef,\n                0x36e4b0aca5531d5c0da94709ba17a4,\n                0xa4327a03320a6982a60603abc981cb,\n                0x5d54032f69977241b356abc4590887,\n                0x62bf97079a59e9ce6320da47988e99,\n                0x1399,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x4b2f40b350af5cf9b4cd5e4a48484b,\n                0x2d45da942f02e9c1ca4d0b5c8891eb,\n                0x95e181ee7a25546bb5f06881ed06ab,\n                0x96daf6f89a37583781ac3cadc3b474,\n                0xca3d251f57ab831e38da4a72febd6b,\n                0xd331a8762354c7a21a205bd00a56e4,\n                0x30e1612ca0c22b20df7e3b13ce20ab,\n                0x0e44e8752d7f365a5be65666a695c7,\n                0x2f9371a16fac95bdbe2bdd29fe3660,\n                0xb5aa14bd29c9cead7fe248cc8d8fef,\n                0x5152b5458eac4871b2dad8ae6f82a9,\n                0xb440d47429dfc47c83afa416a4f6e2,\n                0x6c71eb1897abe36235364ea0257868,\n                0xd2d51b57e037b494d663d8238f7ee5,\n                0xcc7fdf728797297df1292e63fd6e3c,\n                0x4eaf8992cf23b65390e2dfa7b012d7,\n                0xe84bdde98147a17f3a9297786a9b84,\n                0xaa,\n            ],\n        };\n        assert(verify_sha256_pkcs1v15(sha256_hash, signature, 107903));\n    }\n\n    #[test]\n    fn smoke_test() {\n        // Output of `cargo run -- --msg \"hello world\"` in the `signature_gen` directory\n        // Create runtime params:\n        let modulus_limbs = [\n            0x65af46d235241cf0e8fbe8cff4abb7,\n            0xeead39ba3f377ddd5ccb2ef2085190,\n            0xe483f94c0a98e8b618d92fb926f596,\n            0x1fa8c1b2c62cca6db090cd74a29db2,\n            0xc38e22042fcb74585a7e535301f50f,\n            0xcbc4378e5212752743ae78a75a44a9,\n            0xf5acc41788d9a346a0f75630a8b2b6,\n            0xf7a741bb3ecf1aadd5a327f362abd8,\n            0x4d5f24e815db43a1b2cc2ba40f8715,\n            0xe501f1a01305cb198475a4bff0da2e,\n            0xd541b78cfbc2b314083c340840c82c,\n            0xa0ab069c26b2a0458f4c642bf72526,\n            0x2ccb676d8f22517116fee0d2340533,\n            0x7cf2a7cf772025c0a83747bbc18228,\n            0xf9475f17988a56f17b3bdf88dc72dc,\n            0x4ff228bee24415fae7a7c05771e830,\n            0x55acd96b485515c38906106cf0d189,\n            0xb9,\n        ];\n        let redc_limbs = [\n            0x172c8f156f020ad88d30fa3ba47f03,\n            0x1740a43a67cb9a7be1ac1422d77246,\n            0x2d967be1edf369834317e04856e591,\n            0x65d9fa0de5fdab598c04d9a515156a,\n            0xc6791a661ea7621db7e6c4ec48f466,\n            0xa4a1a7c06d3e8a0bcbc540c6af6788,\n            0xdcaffeb149f5bf646caa00d7355715,\n            0xb75471630a9d0fefb5cb61e66991a1,\n            0x97c041a0fc30fdff3d5ed16997da02,\n            0xbfbe7d217694b269e1ed37819c2f17,\n            0x1b44ffc3180531e2ab8bdf7848a3a9,\n            0x9f004af11132cb68bb55998ed7616a,\n            0x1b15dbbb96ce80f479724bbd768a0c,\n            0x59ba1419093ae6ed2592ffb3065867,\n            0xa35b69affa3bb3f4713f315e50b584,\n            0xa873210f83a6de0d8cbb816af3e37,\n            0xbe4fe7cf98da87ec87638030797e92,\n            0x1619,\n        ];\n\n        let signature_limbs = [\n            0x2f397c4611d4a4271453e1e50e1578,\n            0xe506a7f47c721a4943783e8ad459e6,\n            0x6cc4ae1d91cb381cba9673470999fb,\n            0x1e127364d07f94e58227f50fbf5687,\n            0xf64a2579c7189f882d68832d16faa4,\n            0x3b014b74c6c6f76f2f8af170fa0fe4,\n            0x7df41e68c86815a6fdc33968c66b67,\n            0x6a57ac06282527242fddb6ed08dbdc,\n            0xac40d37b819c4b6193f90a634e4fc7,\n            0x96606ed166a7f032d858cd40ac73a5,\n            0x8eb7d4351159a46733f92610d5c597,\n            0xc8e8e9faa9738e82dbe774a3f5cf07,\n            0x89ca84fd54ee3d5cca87c9f178375e,\n            0xdb7a1465fc76507ea498a351af70dd,\n            0x6ac6fe14f51c711f983125c776f712,\n            0x3254c17fef51bf4194a8a1674634e3,\n            0xee38c83c77c6e1ff7b70a5d9d1dd0f,\n            0x26,\n        ];\n\n        let hash: [u8; 32] = [\n            0xb9, 0x4d, 0x27, 0xb9, 0x93, 0x4d, 0x3e, 0x08, 0xa5, 0x2e, 0x52, 0xd7, 0xda, 0x7d,\n            0xab, 0xfa, 0xc4, 0x84, 0xef, 0xe3, 0x7a, 0x53, 0x80, 0xee, 0x90, 0x88, 0xf7, 0xac,\n            0xe2, 0xef, 0xcd, 0xe9,\n        ];\n\n        let has_multiplicative_inverse = false;\n        let params: BigNumParams<18, 2048> =\n            BigNumParams::new(has_multiplicative_inverse, modulus_limbs, redc_limbs);\n\n        let signature: RBN2048 = RBN2048::from_array(params, signature_limbs);\n\n        assert(verify_sha256_pkcs1v15(hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pkcs1v15_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1dccbc1b553aef560cd665aa2ca411,\n                0xdf1b70d8f0ff39013065a5a886490f,\n                0xc3952220c2f6ba45b86fd1842f6db5,\n                0x13403323f2e86127e7d30ca5c3741f,\n                0xdd9593e1b80868ee660cff6aed224d,\n                0xa768ff67951f621cf220c3f11fb7d0,\n                0x827a30c8fc6da6d9e0002ccbab7354,\n                0xd4f4b3326c1822490ba84bf7d8f2ff,\n                0xbc1aed9983525cf9795c5ee886efbe,\n                0x95eca388e0ef68d9e1b51bfdb3f38b,\n                0x5f250161202b7d91724180734cd057,\n                0x5f6a6e4b2adf9db128af321e90bc61,\n                0x2b395ebbeaaf0c6c40a8e7ab2f041b,\n                0x8fea1754c39077bbc232d8380c4eac,\n                0xa113212c3d6ba516cdf08b1c0c0cae,\n                0x9ba6c1d51332cd846f88cfe28dabb,\n                0x57a8d8bfcb8839f3ef85c7ee2dc2e0,\n                0xb4,\n            ],\n            [\n                0xeb993de4326322c7d2e7979b705653,\n                0x1d611f18aa83085ef385333ec454c3,\n                0xb7a3bee73153dae2577781e9a435b0,\n                0xee599bc9d964a749c73673b0559c2c,\n                0x35c1adbbcbfe860f721aa7a0fc3f13,\n                0xa8c28cff73d6ab769ff07f77246062,\n                0xa6263efec60ed7d395f486a0a96b2d,\n                0xa6da86e3c3abd7bec42b6fab8927bf,\n                0xc5a27d894e67e310bc4490762e53dd,\n                0xea29c3c6430885ae7b68d1399dd42e,\n                0xb5a82288241107dcc02e4d04cc0fd,\n                0xf9dbe42935c2111913f05933346bb8,\n                0xc82f5eca04e0b6ab27cdbc55ed1cf6,\n                0xbc6d3e01593e9d1c9399245a306ccd,\n                0xf5da9e23e54b7ace54fc14e9b8fe89,\n                0xc087aabdf746e1a12a8792cf7ac5d1,\n                0x5c825b2c8353558dd371d57b1d31af,\n                0x16b6,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x0d643395f61610f78e0965ff28b34a,\n                0x991a18b16cd776f8ba0dc7d3a2c0ac,\n                0x59ad92fdc6573338573a5ec3a8ac1f,\n                0x39fa3c545c220904560f89449e0cb6,\n                0x77c0492bb5f8faeab6484258164fef,\n                0x32f66a824fc81c4bc3a10228c9d875,\n                0xaf5a933d03c5c769af3e1c43112418,\n                0xe4b3c71e29d230dbcd784dfd344cc6,\n                0x08f5fd6f3b0782eaae154fe56fbe0f,\n                0x9b785970ee35b2cd656cd9f098565c,\n                0xc6c649021334fff3d4ba072255eb0e,\n                0x1fb7d5c84e2fc4e975ea5793a92fc9,\n                0xcbb718f2f6c780b4f6e3a17575b89f,\n                0x04f7eb7174814ff492727916397bb8,\n                0x77790f451d53ce4d4229791f142d38,\n                0xd9ab6403501d48c29b3abbad760d43,\n                0x20d90ee7975dcbd1761fa7f6487391,\n                0x17,\n            ],\n        };\n        assert(verify_sha384_pkcs1v15(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pkcs1v15_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x56acc9475dd0568166f6d519d2b123,\n                0x4388e4291f2a16d58441e4c966d869,\n                0x3b6cbbf6524f2e12e274d96a598cf3,\n                0xcb7b28845e13e53fc8827fadcbf5c2,\n                0xc2f20ecad4360634ca81a3f2700df9,\n                0x71b5ed85f3cc58e9820fa9cdabf2b4,\n                0x8e15d0237c7dbee5369ccbf8f6e25e,\n                0x280d4771bcddaebaa691b4870d4a92,\n                0x3f8ab4c278a35f45149814c95c1c6a,\n                0x4b88bb3a4f16adaa8a9ffa781086ad,\n                0xb4e8dad6bc3fd7d666683e872832e1,\n                0x3135b2958becadcb9e25ec25e55b23,\n                0x405ef523d210399f9def6302a36221,\n                0xb9aaf3a3c5b2e3f4f86393bde7b852,\n                0x5f66a3d278b5759b92269481eb94ca,\n                0xb0ae491acfb3d0a8a46a92b7adffb7,\n                0xa61f0e1720a3cc4594121de7aedf34,\n                0xc0,\n            ],\n            [\n                0xa1818833c46a2c4799148d9f1264d9,\n                0x91008bc32d17f31c4f28b53cf3b9a,\n                0xbf512971ab01254af711f37837279b,\n                0x4f98e0725dbc7d52fba2f5d5482d5,\n                0xc06343b59716c402d33ae0d15ce9b,\n                0x96e236079ec038a21029aba4ff7ffb,\n                0x76e91c4ee8870b1d1c06b73a00f0f9,\n                0xc5018d4394283930ab64cc401b3809,\n                0xc8b4f3f863b01b0fe223822f163552,\n                0x6a94ec6a63708552ac0ab6a824f380,\n                0xc3cf47d1d72b08284f9c04e265a5bc,\n                0xa9d863c6820f2ec1cd35de9327b153,\n                0x85983ec02cffd866801e790bbfa7d2,\n                0x5ee89f7c98ece0aaf4150b6c5b6abe,\n                0x7255ef31994f3cb4b731d0bbf76c57,\n                0x3aba2e537e9003f447c62153c3dcd7,\n                0xf005726db837e60cff0feaac8d326d,\n                0x1542,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x8c1ac22b4f25479bd4d63adc5647a5,\n                0xc226d235d17e3ce2d6303804edd317,\n                0x75992147cd0883367aac32c28927e2,\n                0x7f131d0a5dc76ac9a3982bc3430a66,\n                0x1e5c5471a794bede59e42c5125df77,\n                0x7d4d8bffa69b08eb5a9338c96eb042,\n                0x44bc5745bdb2ed1944e61939c9b325,\n                0xa9c536593f93201b1493257bfceedb,\n                0x9f00b9f27e424f9724c1486fb54314,\n                0xeae7e1250521e254ee2d31f94002f9,\n                0x9ee4db7dbe46139670393a1250fa79,\n                0x014039fcd5bcfa3db273bf7188b3ce,\n                0x4967a88c2ddaf359c3c813cfa3ccc6,\n                0x9c3f74383a8c3326b47401d5815c45,\n                0x2f666d5fbe8464dcfaf569bffa0248,\n                0xfeccacb7e9e0e44320651e58344e8e,\n                0x8942c708df7e40a175d44fee7cf5ec,\n                0x4c,\n            ],\n        };\n        assert(verify_sha512_pkcs1v15(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_mgf1_sha256() {\n        let seed: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let expected_mask: [u8; 32] = [\n            106, 93, 232, 46, 236, 203, 51, 228, 103, 104, 145, 29, 197, 74, 26, 194, 135, 200, 40,\n            232, 179, 172, 220, 135, 51, 185, 209, 35, 194, 131, 176, 190,\n        ];\n        let mask: [u8; 32] = mgf1_sha256(seed);\n        assert(mask == expected_mask);\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xb2cae9b4d726643aef459696fb80d7,\n                0x46585d789783e6f0ea6a4a17001b8e,\n                0xfdf7476659c117564ca991f3d635f4,\n                0x9bb5835a63f78d2ff06927d5f5a64d,\n                0x18ce92c21c9a7dad5ed41c66790811,\n                0x38003b2699273864cc87b363714855,\n                0x7c19d41f8dbe41e03505fe1e061a5a,\n                0xd63a7a6d91625495e46db9161b0d7c,\n                0x3dffb1f7121946f6e04dc642a85da9,\n                0x389eabe29dbf38c1be95c9b9c0c029,\n                0x77a14dc6452603a154cc463e4c2a3a,\n                0x68eaeef1963fa3866c934d1225ac67,\n                0x3a66b9b64048ed95cec6bbe4235189,\n                0x113fd1c23822a8dd63e7d97b034eeb,\n                0x28b7376afc6109602ed94eb40284f6,\n                0x4d331f4da82c798979e7d9d2c5f7bf,\n                0x716d8b401bea115cf1265f976aaccf,\n                0xaf,\n            ],\n            [\n                0x399ea4dac74d4757a7a2956b5b0493,\n                0x954c409a53ce8d70f35be10b94d284,\n                0xee4d330032d52a65e66f54f9e091f4,\n                0x7522b6ca940bfc5133b8fd77ca4bc8,\n                0x43485c2c6ac94d8041c5a056da794b,\n                0xa464924f3a28ab23c5ffa0493dddee,\n                0x8fe3f1bc6a09e1103acbb53acbf6f1,\n                0x5e47597909e86c168b5748cc089ce1,\n                0xc86b6b4de2aa786e144d0ef5556c30,\n                0xf45a9d9d93fbe0cd5f2ddca2316648,\n                0x5edab2328b0b639407f9c773a06c5c,\n                0xb61d4e287c0c6a969f5decfd036ea5,\n                0xd47864f47e49cd0e0ec34f120ba0a4,\n                0x3eaa94f799b276ef6a790eb61722d4,\n                0x5c18da1341811cee5de6f76ed1a186,\n                0x5ef0641da7cac0c45ba74d4355befa,\n                0xbb04586630e92ea5ece8e5db45caea,\n                0x1758,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x6d3125fde00a57fb5971460c38a826,\n                0xba2092dd58c4de8ffff2bf13f5ef57,\n                0xf0ad4ed46727881e7e7f6a103d7713,\n                0x7e8b2203a7a6e3a3a30219d6edf8a2,\n                0x9b0b861dd1cb2751f30d54d07ad167,\n                0x4373e863b15edba97439182a6a9043,\n                0x61621211db5f34a0786d5ef38cd90c,\n                0x63001609f7dffdc70761c67617b580,\n                0x8b2b817a0508e4be6f2c50df23962d,\n                0x6d6f9396978782a90fe06ca78c4f88,\n                0xc567a9fe5f7175225384d7c1e4c991,\n                0x38926dfee8636b9e36728c1cf51198,\n                0x0eb84e90f89a0bd21536a537618b92,\n                0x23dbdcda1fee2b57c8dc2e605777b7,\n                0x6acac69b2fc1c12c204e790034a01e,\n                0xee44b77264385863ccef2e133241cd,\n                0xe9c67049c219997cc8c43b0b1f420b,\n                0x78,\n            ],\n        };\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha384_pss_2048() {\n        let sha384_hash: [u8; 48] = sha384::sha384_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0xc3034c17b5578d9c029b22158a8e45,\n                0xa84c80b43a68c9eb7cde67f1f60e07,\n                0xa8d82a4aef2cd733a9fdf43439ffbb,\n                0xa1b9aae31832c2815b81f0db70962e,\n                0xcfcbc51338d691443e702bd18354a7,\n                0xaa2c5f465a247efc9d97fb052579b8,\n                0x571f3c233fa322a933a4cfc0c4b213,\n                0x3280f1f7238a3416c5e1140077537a,\n                0x8685f03e3076c1bb62550cb363ae08,\n                0x55ebdcb84073ad2dfd3553c5e2d21a,\n                0x1e5a0a662b44f5250377abcd1069e6,\n                0x178357493184215e38603004f6c9f3,\n                0x75cb8889b33c6b78bab0a378453376,\n                0x4f5f7baa56492d5ac52c1bf7b998b,\n                0x16cf48a7c416bbf67657a263376e22,\n                0x1d8ab41c7021ebcb15da705dab5343,\n                0xc5e43d48377059df0aa5d7e5441586,\n                0xc7,\n            ],\n            [\n                0x721a52a87ca82263e96fd6d2bf3417,\n                0x74bfd742af70020df01f6cae960793,\n                0x1091edcad411cdbfc254bbb2ab2906,\n                0x9d1a2951a8e50de9c90b803c3d4931,\n                0x506ad1760d06b52708ccc0ed9fe629,\n                0x11b96266505a62523f9cfa1101a9c8,\n                0xbe5243b0f30ee090c4181e19f45f1a,\n                0xa2a56edaec8f9fe12d4d07d725931e,\n                0x50723b780f7ef18393031ced4f1489,\n                0x1ef7d8dc5b567db0b1a65b745625f2,\n                0xf9f37b5efea9a93029d7d5dda26bc2,\n                0x759247cff5570cb9075ae0e8b5cfee,\n                0xfb2e6c00b4ce0feedc40f3633d354e,\n                0xc9051ad4f912e7a5753e614d892320,\n                0x3cf78d852f5f76bc267b0ebcf13c39,\n                0x7b3cb2df2619a3020f2080dd555657,\n                0xd649e6032585f42250ac6c95111c09,\n                0x1480,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x06d24f9dbd859780c7684e7733ebb1,\n                0x3acb7e4bd7c9f42a5f9649e1fef5c4,\n                0x67878f2493de5cb48ae107df08dbf1,\n                0xf268bc940d64e42b8719216fef188e,\n                0x2c4701120db41532e6d195ba1f8faa,\n                0x03d3b537eefd6f0c99fbb7c1f359d9,\n                0x35b732ca45b03bb17b1f3564f18464,\n                0x468584d7dac0a4ba51032e2a5f95e2,\n                0xe10042eb30d1662517aed3b89e1154,\n                0x0e5743acb366c6251627e64f751256,\n                0xb06e6af3e06ed5c656e66aa0295f63,\n                0x67378aabfe17e33e305825eb4f6c5a,\n                0x8cd4c7aa81b660325dba4b0d899a9c,\n                0x40c83a9c74f99c026aa845fa222b69,\n                0xd52f8e19032a33a1d9a01063fff8f9,\n                0x7dc36972054edf46bbfe918711e693,\n                0xb035fca3baf4329ff5d588baf7b034,\n                0x1c,\n            ],\n        };\n\n        assert(verify_sha384_pss(sha384_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha512_pss_2048() {\n        let sha512_hash: [u8; 64] = sha512::sha512_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x928a173c3947c058b084e258b8a4c1,\n                0x5f1179c22cfacb440464695cfa393e,\n                0xc409e532b3077ce4d90e66e913f125,\n                0x29e8696374f86380ff45d0f29a98d5,\n                0xf931d155d89d3753ee931433a8e2fd,\n                0xfc3d1c2a999f0112f5c5416c2e0428,\n                0x4d21692b210bec2ab8e1b52fe78e66,\n                0x9df364fad350d314b146e84f114203,\n                0x8511a74031596831dda8ac9d18dcf7,\n                0xab5f9ad71b33284aae738988284229,\n                0x3332aa31681f69a5f470caadad7469,\n                0xf1fcad281e0fea144e1f4208d38e38,\n                0xe83d3b0afb20bc39814ea22df000ef,\n                0x3d9244664808f54fc4f0702adc9399,\n                0xc087b5dc693953e6371b9c7c175a21,\n                0xd5910d0d4232e8f92148482a72baec,\n                0x44e57b58ec4e75250116ce2f1abf3b,\n                0xd2,\n            ],\n            [\n                0x74b3f4c907125a6150549b8b5a387e,\n                0x9c2ecc9981d5fc27f5a6a7b4f23756,\n                0x57ee194ec44b4a44df198809f8d673,\n                0x7ffa9a1ec7d9a9b915e1abc75c493f,\n                0xde339596c27c993135a7ee132cf774,\n                0xfdb788951d3777aeea6afee171b569,\n                0x8dda93126970270ed42ae605e9824f,\n                0x3fa6e07b4429f0ee8370c988553ee3,\n                0x26d95e43ed1e1960a316eebf6b3b0b,\n                0xfd155b9025d16ecdbdac73725d9a89,\n                0x2f5a47107ec03b05f5a10fba4fa1df,\n                0x61a45285c5dc3355741713d6d71a24,\n                0x8644f1f46cecd803e531110da3bd5f,\n                0xaf989d56c5412bee6598af25829723,\n                0x52f7827f7aee453f9c3eb9753fbe4b,\n                0x9f38d6f5f1a3ff0d40c601d799dbb0,\n                0xd401bd1620fdd206413a8977de6375,\n                0x137a,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x2058f7115f339e55a93f8dcefe81b9,\n                0x38a20cdbfc439a1fea423c119f2879,\n                0x7ac4e03a5fa662754e6e21a78984d4,\n                0x69d714829d29b235d588476152b5af,\n                0xce3db2102990c27bb66bc32da8dec4,\n                0xb4914f6f0e73718b5f1e422fac6ddf,\n                0x7d812b554c81ccb7932d1e78c6e002,\n                0x438fe60d9e0912328374513ab91b69,\n                0x56abaf2b8d9a6dcb9201586d2f0d0a,\n                0x4151c524481066bd81b4cd17829481,\n                0x7c63b445e245d09ca91057032ad22b,\n                0x9f242d5a655035a028a68d337ae40d,\n                0xb5f91b99b495862044bc7122913806,\n                0xc123aa56dff5b23d7d8ad097748efb,\n                0x6892e3a32a7b6963d97b3bdd81b91d,\n                0xcd7aa9e3e77f68f0ed195bff92a162,\n                0x583a32fd5a399f3acd867dd7d6a1b6,\n                0x7f,\n            ],\n        };\n\n        assert(verify_sha512_pss(sha512_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_4096() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params4096 = BigNumParams::new(\n            false,\n            [\n                0xd78653b3d43a72784415fc0537129b,\n                0xc725d4fb19419a03b58e0fb5ea4ad2,\n                0x1d866cfc050224a0eb317e835ee283,\n                0xd298018e86d3225a264a449c63d69d,\n                0x824db5365a077bf704acd2446baa7f,\n                0x5c419e562b5b5ccb0dcb151a3f48c9,\n                0x198a6627edcbc2afce1893217c2e25,\n                0x29a693a0bb3f6f02d80e660f681d6d,\n                0x5656562a9622f87bfb969db2542f63,\n                0xb9408b08a3ee3b25b6dc6ae12899ef,\n                0x4ce9b767219e1e0593782ce46a041f,\n                0xc5a4f318b34ff79121677f283ceea1,\n                0xbd5e62c599453a94e0bf5f48c6b58a,\n                0x6ce23c4978ae07af4c46ea9b9964ad,\n                0x68d4db6209ac89538e6d986cb77459,\n                0xf2ada72cff01696e2efdf123ab60f3,\n                0xf951c3c1965c355f460fa815587ed2,\n                0x6063ac0275e6592b878d5a66e68501,\n                0x594eb3db288ad091bc1db2b2a90101,\n                0xb72899c91edcdf890053f87d5b1dab,\n                0xdfd45eab0c435e275202bff1e22f5d,\n                0x3da05e1d0d3cd0012e6c40e1878ab7,\n                0x4fe053feaf486a27dd119cbee9ce1e,\n                0xa3781b036bd3a3411c2af8377ad0d9,\n                0xdf4410ba8397cbe580fc5eca7d230d,\n                0xdc34151036d459fc3c21d8ba0702fc,\n                0x4ea71eb1b0b1a2f36741b61e8765d8,\n                0x22cb66b4eb0b34b34320402ef652dd,\n                0xd19167b88620fc6b60709fd39cd48b,\n                0x524e4fbe4d75e4817de075ac70c72f,\n                0xd0de26679602cd331c3e5534ce668a,\n                0xf5aa120ff51d4bd3d57c1d68359f95,\n                0xaa06f0791b623cddd53d787035bd66,\n                0x122e014d565fa26417a5ed0f786fbb,\n                0xb95e,\n            ],\n            [\n                0xc4c3bf6cc9335c4bb7199f9eb47a5d,\n                0x7bcbe7b5b3cfb697c6b77fe1aa066f,\n                0x3e936bb516c60dec6e7bde90a54056,\n                0x78a92edbea967a370dc928b2f4cb53,\n                0x99df0977952d4278e6b4c792b31c39,\n                0x7d894ebed8702b158c7a51dff502b8,\n                0x6da93f37eabadd8e55d4f450bf48a6,\n                0xfb59acbad033856be388bf59b73c4a,\n                0x8644dd32dc773e5e12e03380dbff01,\n                0xdff59e8aefb7acc81bde30f7b22890,\n                0xa646c3f6a98819547eae677e99679,\n                0xc777d7da058b7a0d88b7ec84400a6,\n                0xc6ba50b7cc4d0aebf8a25d1eaca0ec,\n                0x6f2cc8babdde75a318872b952885fa,\n                0x6fc91aadc8ce227e9039c8f3148d9c,\n                0x67773f804221d4f58ca3bd11952bc7,\n                0xcf5a20affc5a099ad25abb5b9cc622,\n                0xf60a9108eb36c8068e93e524c23512,\n                0x8b67af87617dcd94e38a62a7297673,\n                0x656343f8e1802e8c043b2621f5b08d,\n                0xd82c8e1a8d3e458e7979a77cd76424,\n                0xd2bf783c787be340bd66fb8a07d1d7,\n                0xc94d16e2ea48369f57abca5909b81c,\n                0x2ff442542b4e904ad3ca20d06ee11f,\n                0xa1fa20565627dd7eb96b4027b6714f,\n                0xd3a82d484df4983db5fadd7b93048a,\n                0x5f4e993b09d0ab81b8312bc09f069,\n                0xcd135a6daa623b906fb62c6e28e9e1,\n                0x1a5abe5655f62a0a0d0d9479ae7675,\n                0xcfa89adba08b924725c940a56ad9e,\n                0x6023b1d30936eb9ee54bf789026e22,\n                0x9e91f11aa269f381122653c704cd5,\n                0x2116e976d592737e0c57dc12269efc,\n                0xe88a3202a09bdeaa3db69af98a651,\n                0x1618be,\n            ],\n        );\n        let signature: RBN4096 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x5d9212d0c25acc14b61c6ce61a844e,\n                0x9d369ae765eb0545f83f552b8d7bb6,\n                0x5f0f5d383bd70d7726a851c422fe29,\n                0xcff5886575636efcde5d9843e59a10,\n                0x5820fa1e3158154641adb2c28a8954,\n                0x03ce0301512be13c0317fb679e6348,\n                0x13ec0af966303ca69b6f7fece6c2f4,\n                0x58dcc592b80e4756a8d01224e6174f,\n                0x73610ba199750de1e35cd658cbae92,\n                0xeb1d49f1ecc3bf332b4048d978a46a,\n                0x8c9ad13691accdce88ce1e6fda0bf5,\n                0x425e80441351444e751cd86b97b464,\n                0xd25a9581921c44fba102ed92a75658,\n                0x698c73a7fc85fee22b1c7f04fb4600,\n                0x70267fc50db236dfcf1e9405e25856,\n                0x1a35b94cf56f801be96defed712afe,\n                0xa3ecae6965b3bdee416f8d506f64fd,\n                0xc875faf0fb4e4fa47ff65aba633529,\n                0x3ca01bcaf3c4a5eee7fa8fdf0e98,\n                0xa666b5d8c9f3217c412610ae91c862,\n                0x517ccc77102fa7799e521ef0e6d4e7,\n                0x7a50f7e553db75f0e0bd18d43bd622,\n                0x98e8da14444b6cf3d2b91d84da3506,\n                0xd1f5e4f7a725babc988cc7822c3d0a,\n                0x09ee2caa2e6f8b02db37ebe2352624,\n                0xd500b790312328a681b89b5de51b4f,\n                0x5ce0ebb445d4c82c3ecf21134c00bf,\n                0x83b6fafae79bc59f07e9b6802ef018,\n                0x8efd78556c637f8af6299ace0cd790,\n                0x5e99cf54d0f7e491cd72bcf20701fe,\n                0x19f15da137fe1bbe44c5531300829a,\n                0x0aae159f54317b49ec6b083292f57e,\n                0x37c2bba2237a59a35556f2d351c728,\n                0x7ec51821f03bde0c862e19e6ebe62c,\n                0x2081,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha256_pss_2048_exponent_3() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x1c961b234309c24fdab3f3e8a09da1,\n                0xf4aa851a30a198c359f3779b6bf4e0,\n                0x844034a1488c79edf31b1711a5e547,\n                0xc83ad2f9b30cfcb6d5f7c152a78e62,\n                0x16e97e0f8d8bad08da76d859c575c6,\n                0x6a85158069b211820a596359d0dc47,\n                0x1b834ed69818f1aa7d9944dee07b20,\n                0x4d7148da361f1881cd4fd396ef46d2,\n                0xc4cf36bbfa2781703699abf19a1e6d,\n                0xca4bd632c8eb2c8051915c3530aef9,\n                0x9cbfd5681aa95ade8eb256925d60ea,\n                0x3b8153585ff5f1d7b1ed37ac709dc6,\n                0x7d741c118fd653af3c21848f789ed8,\n                0x7aefa65093c124e46405849ca82ad1,\n                0xf9dbb9414e8eb849e2532d3f55d0b9,\n                0x35aeee862ac76c20be58527220f6a,\n                0xa3b6f81f07963c34ff0168634f8a99,\n                0xc4,\n            ],\n            [\n                0xaf8e2d749a5966b98ffa10ea071d41,\n                0x83704b0ef8ae71e3f1a7d24d871556,\n                0x82903be42859c5bd5cbb935d1097fb,\n                0x5bdc4e1e26670ed73580e2c8c144c1,\n                0xce5178ff7019c4a6c0a2743ab2fae1,\n                0xfd9ba73654ecf2020bdfa6ed9dc777,\n                0x9ba95e3e7551ee261a4f10eca35f05,\n                0x9e09b71274e5df10e06a6ce6319c3f,\n                0xb14781efad91be0888f5150771eea5,\n                0x15d2f490d6ba3cf25ad91e5e2539b0,\n                0x7887aca3df2194cdbed904e6d42977,\n                0xb797f21802a052c11e5c205bcb7d21,\n                0x94d15b35eaf46e2fe69f2b60c02922,\n                0x73814f1d160107a3ff1081b0cd1fea,\n                0xaa4c31b61839c41980a8bb9c922a0c,\n                0x123cc9f0ad08747529171a2e286eb6,\n                0x7a8b658fe4e9b448debf21d8ea0cc0,\n                0x14d4,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x091a8c417287e046ec96c62b5ac66f,\n                0xbe71db0fe3122ea5624e8e7a0a72dc,\n                0xf35e5f3537c0ad0e938fdedd454de9,\n                0xd53c652cc3aac5d11fe6f5bc7ec536,\n                0x5d6869f0dd8b00697743f956b9b112,\n                0x5d46286274a1128a8fe0d96e859837,\n                0x951ee9dcb59dacebba972e9b9d7cfd,\n                0xd22245a462bff840a882f6869689a5,\n                0xcf7605b64a20dc2c3e6d5ceb88a03a,\n                0x7831aa25052c11411c3e5bdbe7dc10,\n                0x8e3bce799814987c984a2cc0e5d283,\n                0x7fdb0ce6e413e0f32742f4652f14a2,\n                0xa896a360bd70243209390e00761c57,\n                0x0d326051ac677371678f92bd182f13,\n                0xfcc593faaa9f45448ab756d70def,\n                0x2fd6d46ec8d25a6648dadf8246daf0,\n                0xe4aea2700222e610c1d94d82dd0f52,\n                0x9b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 3));\n    }\n\n    // Test an unusual key length that is not a multiple of 8\n    /*#[test]\nfn test_verify_sha256_pss_1964() {\n    let sha256_hash: [u8; 32] = sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n    let params: Params1964 = BigNumParams::new(\n        false,\n        [\n            0x75ac0d9987aebebd25983ab5a48fdf,\n            0xae0a5ffc69f51e789ea8f90a72745b,\n            0x9b8c92fb6ea3ca021a894ae52025f1,\n            0x50de84cce0d856376083aa1785fd38,\n            0xa912e3aabd4191e143128ce89e2086,\n            0xcf361d0e7f4fb458b950ca7f58414e,\n            0xe27bbefff3820e512b05a07d2d7e1c,\n            0x7a2fd42d837098a67f056f1b15ed33,\n            0x4ebeddd5d6fde42dc68ba5bb2a3732,\n            0x2d1cbcf87c37b430c33b04aa35ce2b,\n            0x9e9cd702ef1e7191c78e712ac6e151,\n            0x9aef318e4318c313c0cf0c71ba378b,\n            0xc1cd2e631f327acf58dca9f4e63bfd,\n            0xc828e43ce8acda48fa1fff12de4df4,\n            0x2d91364c2a898031a0ea615c82fe50,\n            0x3fed935e1e73af131b48aafef030d7,\n            0xc278be706ab,\n        ],\n        [\n            0xd4343ba7542877db4a663c12d159c,\n            0xb7f3ebb5e9a7e46abb5fa5ebebf068,\n            0x6f2ab6c72bbdcd87bf3cd5343f7059,\n            0xa437eae960f2ac5714f7a35b803598,\n            0xae01beec10904488485933615d62b6,\n            0xf9509a6004d765dfa27536888f2757,\n            0x57dbdd558fa8831a632849dbaecdfa,\n            0xe7c4027a23af2ef309461db1f95629,\n            0x388a2b780c78da825692f1cec5055e,\n            0xd064ac53ec3c505b8e8e25b9350ce7,\n            0x529b1374876a3bbf8e83e5d239cd69,\n            0x7206c8bf4a0d11655219207de991b4,\n            0x5fe1135077b5b760d31bdbfcb4f698,\n            0xdb00d1d10cdb6c91c0f93f4b1a18c8,\n            0x8329224ca1e3c5ef415cb1629f82d8,\n            0xecca0fb0c3e52adfd165bbf85b34eb,\n            0x150fec084e187,\n        ],\n    );\n    let signature: RBN1964 = RuntimeBigNum {\n        params,\n        limbs: [\n            0xbd4bab3d5a9af46cac40fc2f6c9547,\n            0xd3e04f0b8e833f1e80a4022684694f,\n            0xbb4267e4fc29ec83dc8398dc547fca,\n            0xba625b4fdf379883f6ccabede3574a,\n            0xc9736193ab3cc0d1ef8ea63fdba46f,\n            0x72dc058e8abcbe15ed09e97c1bb58a,\n            0x98d8c915cb9447bcce3bbfc0f92032,\n            0x9a0778461e9dec09e41c0ea354a41f,\n            0xe4a6b80a5f62abf93268cde64b5e9c,\n            0xd36dc0ccfdc6d9d8e8a939a3e762d0,\n            0x1b2593bff17ff433ee20f1a60c6861,\n            0x78115ebfd2484df0b59abfa3222e79,\n            0x7693ac9aa8acfb4b5379c0adbcb7d1,\n            0xd76979aa97b41f1f58c65ad896f1cf,\n            0xe1f7c4fa2dc6cbe0162be9adb01c14,\n            0x5f5a8f5b9ca6fe12c4fe3c00795f10,\n            0x8b4a98cedd,\n        ],\n    };\n\n    assert(verify_sha256_pss(sha256_hash, signature, 65537));\n}*/\n\n    // Test an edge case where the key length in bytes is greater than the encoded message length\n    #[test]\n    fn test_verify_sha256_pss_1025() {\n        let sha256_hash: [u8; 32] =\n            sha256::sha256_var(\"Hello World! This is Noir-RSA\".as_bytes(), 29);\n        let params: Params1025 = BigNumParams::new(\n            false,\n            [\n                0xf278b138628000b2652c779e852235,\n                0x6d0676977e76ef0429002673ce9be2,\n                0x6cfc0db4d97f20ad2a1ad48cd899a0,\n                0x64024c19a1b1540e23ba4531e677f2,\n                0x3696125dd256ffed9567fccff06be6,\n                0x2dc09476b0c7629eed3c7c2cb591e3,\n                0x2e007f2f978504c5cfea0ec51ba0e9,\n                0x84ec9458cc6d0e95e06a7f404f26b4,\n                0x174fd186dca48668a,\n            ],\n            [\n                0x7ab08c63fb6eeee6204bd814d3134a,\n                0x20d51c551c06e8ae471cc43e84d131,\n                0x5eac3eae8238c6c2c37c1ce5bec407,\n                0xcff61632bd2ea6bc1dc8da002aa0c5,\n                0x801c1e85137856c4a6dc8c25078a59,\n                0x5ce8ee248cac12cbc3faa426acd58b,\n                0xe72384bb8302bbb78a3766fc61c5f0,\n                0x6ea716c0a657933b91b2d488b29cec,\n                0x2bed1ff958b58c194c,\n            ],\n        );\n\n        let signature: RBN1025 = RuntimeBigNum {\n            params,\n            limbs: [\n                0xa90e06eff7cbd20dd9c1241fe89290,\n                0x9ff719ce8f34229cd248e1f0ef4246,\n                0xd1d032dbf236cd711aa4fb49f0c71f,\n                0x454abf136ae14c7617df3b4d505e08,\n                0x45f30ac2c023205d35803f114f8ee3,\n                0xc8b1265c786d6da808ab31d35795a1,\n                0x1f75005a85f3636b099c58edd9fb8e,\n                0xac251bf9bb342b551c0f5c80449a3f,\n                0x03e2bc114292962b,\n            ],\n        };\n\n        assert(verify_sha256_pss(sha256_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pkcs1v15_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x156ceaf444d8819f2aedf0ba175481,\n                0xd3bf95380882ed1e760191e383dc84,\n                0x8585e65def5c89b3b3aeab9ceb6c80,\n                0xf215a93f61d5165db91d88a871368c,\n                0x5274e088a95fb4053f26fcc5619e6d,\n                0xf4494a491b66f30025ee633bed7a72,\n                0x801bdf85598a082dbac2b26a4fbff9,\n                0x9cd2905057dcca8c319d294785aa89,\n                0xb155d5581ec0bfd4096e6878b3bc25,\n                0xa0cfdf3decd16f8dde113e85a38c7b,\n                0x9452a725f9f2f3e82ebef589345c23,\n                0x1984df6bd68eaf0cc88b42b166ab6c,\n                0xff925851486b26af0a896eae9c7fe9,\n                0xe6fd92b72a2381389820a8ab283ff3,\n                0xbd5a35556d716ba8685d106a944555,\n                0xd9102f1ca16442372df5234fc4c23,\n                0xae1aa56a4a4e1b155af1ac4fbef88a,\n                0xdc,\n            ],\n            [\n                0x8ad3c9e65e7035db6d57a4182a4fb2,\n                0x9df5db4eabb63cb8306ba17ab7d99,\n                0x4177c0f5014aa2717306987d9ff827,\n                0xb35faed8cc169c33eecfac2341d47d,\n                0xff5faf8dbca65f1431a5d94d3a6d60,\n                0xbd49ab8984a0739a666a81bcf41f4,\n                0xb97ef986aa48a3f9c5160b1a9165c5,\n                0x3b34d06a7867dc8c0e9411bb389f30,\n                0x66ccff351294c073811e0e018e0917,\n                0x4bb0ee68c1f5ddebb71a9dd3a6df38,\n                0x29d2d550ec2d549320fec501d71108,\n                0x6609e5236bb550a30e29378259ed01,\n                0x4c33e3f52407cc796ba41acfaa3007,\n                0x6e6ec514bb4f26c0ac197aa2f995f2,\n                0x47967368b344f7c4fe0e84bdddc040,\n                0x1dc9219753dbeb4aa003c81b210e0e,\n                0x90dbe39955df1d4aa7c6efce2a8b3d,\n                0x128f,\n            ],\n        );\n\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x1999f7717a7fd287d0b3e2d66a3437,\n                0xc8fb6805554123679c362e6f002aae,\n                0x3facdc5f1def4f49606b908e2a2538,\n                0xc05aa4965a11190493a6f4e7fd5984,\n                0x1672f3416fb95821efcb5375f1779e,\n                0x2f81eb13f1894268f4acb1b0ae7513,\n                0x15d997bac63df6624c2603e93cb0fa,\n                0x536c959eea6cb9fc3980b86d9877b7,\n                0x4296d1c42936c208b6ae13cd06d60b,\n                0x39144ec79fc42ccc160b14c8b793e4,\n                0xc40a783835d9df4c5f69ba68faaa,\n                0xde2af88216d83b8136f094d8945b95,\n                0x4ecac07a39171bd9a01383a4919924,\n                0x737d8ffc839f4a503c431c507ba5f3,\n                0x844f4957cf4b01c277f67a7591b7f5,\n                0x0291a8afc7cda7e4c6e73e011c181f,\n                0x7afcd49577ffbc75fbe9a2e2959b82,\n                0x83,\n            ],\n        };\n\n        assert(verify_sha1_pkcs1v15(sha1_hash, signature, 65537));\n    }\n\n    #[test]\n    fn test_verify_sha1_pss_2048() {\n        let sha1_hash: [u8; 20] = sha1::sha1_var(BoundedVec::from_parts(\n            \"Hello World! This is Noir-RSA\".as_bytes(),\n            29,\n        ));\n        let params: Params2048 = BigNumParams::new(\n            false,\n            [\n                0x8076ee27cf6ed266e737de20b03e47,\n                0xbd07415cda0752a917b4f40d19c992,\n                0xd473ccfa4dc8a5690c17eceab674d4,\n                0xdf2645d4e31531b5e68d7b30152182,\n                0xe4e6d87d9b3222f56ddc48b46dc544,\n                0x587c5d66e6970f42fe18afa99b5e5b,\n                0x30261d8162c75fe7ba96ab0c2a6dd3,\n                0xdc69073390846c7fb3c98c9c316d60,\n                0x4b6a2bc2c1e5131129539c38b0ac3b,\n                0xf05187e8d7cf34d2c1685409173080,\n                0x2d26be5b0d792a3d92b7d4062b3d44,\n                0x4eb7f21f6c4e3df8d2829f6b3e6eaa,\n                0x9f1cd4d18bd53d4bbcf804651435f3,\n                0x3d266b2f1223e08dd2159d58cb48d4,\n                0x873625d48c8244c51924bfdee0c6ac,\n                0xfcbf5c61a9d3cf2d0e13686af8d0de,\n                0xb4345e8b5be7510698390901722861,\n                0xba,\n            ],\n            [\n                0x51b40d9d6a288a5396a16f9fc85f2a,\n                0xbc36a9bf43ffceed626f118da3b290,\n                0xdcff05073f93178b589ab93edcfa9d,\n                0x42fe8b2c11fb9eb89432cd017ecae3,\n                0x7c74c2b03dc0a6ef97319821e6adaa,\n                0xf35c6951909aa944366d8e5f8f435f,\n                0x211b51cea0e9e9db01a1803ff9d995,\n                0xe9632ae2bbff5ecfb13344716976aa,\n                0x5ac98d1f7f9796c5f4360a6c53c0ac,\n                0x21cad5d27ccd949ab83384e613df0f,\n                0x7305d4a53c3121804a7e563663ac19,\n                0x42f7f8514dc823f5cec8029950f51d,\n                0x88af0d59283ad9e8ceadd7275f9665,\n                0xe377f531eb845e3ae55cb1f4f00845,\n                0x863da2aa3bd54edc8b6da777626340,\n                0xe92dc9d46715752498a8eda776a039,\n                0x401e4c6793f0bc7f5da805da5cd5bb,\n                0x15f0,\n            ],\n        );\n        let signature: RBN2048 = RuntimeBigNum {\n            params,\n            limbs: [\n                0x835c0b9302499888acedea4013ec92,\n                0xe1f4b56b2ca0ad8c1ee3b8a9a85d93,\n                0x5d4fecc54034eb1091ca9fc28e3ff1,\n                0xab316868780469b1621c789b8d8b75,\n                0x13205cae60d93b387ef282c901bb,\n                0x776e846d321b59b584c6de6ae6da18,\n                0x6170c33330baeaee6a3de84e32f031,\n                0x3862d9f28a50c32f0f09a6e5e60560,\n                0x83e54c8d5a9522e5addc4cb35078b1,\n                0xf4cd91425b0b042fb1cbb81d0ce6d6,\n                0x33c49780bb4c00637bfd9f5de1d1cc,\n                0xcbd14e26c78a769ff0e47854ff9d72,\n                0x459db8d780c5287c894d8d419ec583,\n                0x19909716db20e09223fbc169d58ed4,\n                0x62efd0331023145d761b8568fc93c9,\n                0xcac052c722d08645d4ad31464f665a,\n                0x33c6a0e25cd27dbfd1d15fc2197aa5,\n                0x89,\n            ],\n        };\n\n        assert(verify_sha1_pss(sha1_hash, signature, 65537));\n    }\n\n}\n","path":"/Users/lancelot/nargo/github.com/zkpassport/noir_rsa/saleel/sha-version/src/rsa.nr"},"157":{"source":"mod utils;\n\npub use utils::{conditional_select, DebugRandomEngine};\nuse std::collections::bounded_vec::BoundedVec;\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"haystack\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @details the \"body\" parameter contains some input bytes, zero-padded to the nearest multiple of 31\n *          We pack \"bytes\" into 31-byte \"chunks\", as this is the maximum number of bytes we can fit\n *          into a field element without overflowing.\n *          TODO: once we can derive generics via arithmetic on other generics, we want this \"31\" parameter\n *          to be defined by the backend being used instead of being hardcoded to 31\n *\n * @note We perform this 31-byte packing because it dramatically reduces the number of constraints required for substring matching. See (chicken)\n *\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunks: the number of 31-byte chunks needed to represent MaxPaddedBytes\n **/\npub struct StringBody<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    chunks: [Field; PaddedChunks],\n    pub byte_length: u32,\n}\n\n/**\n * @brief represents a byte-array of up to MaxBytes, that is used as a \"needle\" array,\n *        where we want to validate a substring \"needle\" is present in the \"haystack\"\n * @tparam MaxBytes: the maximum number of bytes that StringBody can contain\n * @tparam MaxPaddedBytes: the maximum number of bytes after zero-padding to the nearest multiple of 31\n * @tparam PaddedChunksMinusOne: the number of 31-byte chunks needed to represent MaxPaddedBytes minus one!\n *\n * @note PaddedChunksMinusOne is because we are going to do the following:\n *                            1. align the SubString bytes according to the StringBody bytes being matched against\n *                            2. split the aligned bytes into 31-byte chunks. The 1st and last chunks might contain\n *                               fewer than 31 bytes due to the above alignment\n *                            3. validate the aligned-byte-chunks match the StringBody byte chunks\n *       To account for the fact that the 1st and last chunks might have fewer bytes we treat those separately\n *       The param PaddedChunksMinusOne is the number of 31-byte chunks required to represent SubString *EXCLUDING* the initial and final chunks\n */\npub struct SubString<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> {\n    pub body: [u8; MaxPaddedBytes],\n    pub byte_length: u32,\n}\n\npub type StringBody32 = StringBody<62, 2, 32>;\npub type StringBody64 = StringBody<93, 3, 64>;\npub type StringBody128 = StringBody<155, 5, 128>;\npub type StringBody256 = StringBody<279, 9, 256>;\npub type StringBody512 = StringBody<527, 17, 512>;\npub type StringBody1024 = StringBody<1054, 34, 1024>;\npub type StringBody2048 = StringBody<2077, 67, 2048>;\npub type StringBody4096 = StringBody<4123, 133, 4096>;\npub type StringBody8192 = StringBody<8215, 265, 8192>;\npub type StringBody16384 = StringBody<16399, 529, 16384>;\n\npub type SubString32 = SubString<62, 1, 32>;\npub type SubString64 = SubString<93, 2, 64>;\npub type SubString128 = SubString<155, 4, 128>;\npub type SubString256 = SubString<279, 8, 256>;\npub type SubString512 = SubString<527, 16, 512>;\npub type SubString1024 = SubString<1054, 33, 1024>;\n\npub trait SubStringTrait {\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        num_bytes_in_first_chunk: u32,\n        body_chunk_offset: u32,\n        num_full_chunks: u32,\n    );\n\n    fn len(self) -> u32;\n    fn get(self, idx: u32) -> u8;\n    fn get_body(self) -> [u8];\n}\n\n// ######################################################\n// S U B S T R I N G\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    /**\n     * @brief construct a SubString object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(input: [u8; InputBytes], input_length: u32) -> Self {\n        assert(MaxBytes <= MaxPaddedBytes);\n        assert(input_length <= MaxBytes);\n        assert(InputBytes <= MaxBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = input[i];\n        }\n        SubString { body, byte_length: input_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together\n     * @details each SubString can have different MaxBytes sizes, however we need OtherBytes <= MaxBytes\n     *          (use concat_into for cases where this is not the case)\n     **/\n    pub fn concat<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> Self {\n        assert(\n            OtherPaddedBytes <= MaxPaddedBytes,\n            \"SubString::concat. SubString being concatted has larger max length. Try calling concat_into\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= MaxPaddedBytes,\n            \"SubString::concat, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body = self.body;\n        let offset: u32 = self.byte_length;\n        for i in 0..MaxPaddedBytes {\n            if (i + offset < MaxPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n\n    /**\n     * @brief concatenate two SubString objects together. Return type has OtherPaddedBytes max bytes\n     * @details each SubString can have different MaxBytes sizes, however we need MaxBytes <= OtherBytes\n     *          (use concat for cases where this is not the case)\n     **/\n    pub fn concat_into<let OtherPaddedBytes: u32, let OtherPaddedChunks: u32, let OtherMaxBytes: u32>(\n        self,\n        other: SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes>,\n    ) -> SubString<OtherPaddedBytes, OtherPaddedChunks, OtherMaxBytes> {\n        assert(\n            MaxPaddedBytes <= OtherPaddedBytes,\n            \"SubString::concat_into. SubString being concat has larger max length. Try calling concat\",\n        );\n        assert(\n            self.byte_length + other.byte_length <= OtherPaddedBytes,\n            \"SubString::concat_into, concatenated string exceeds MaxPaddedBytes\",\n        );\n        let mut body: [u8; OtherPaddedBytes] = [0; OtherPaddedBytes];\n        for i in 0..MaxBytes {\n            body[i] = self.body[i];\n        }\n\n        let offset: u32 = self.byte_length;\n        for i in 0..OtherPaddedBytes {\n            if (i + offset < OtherPaddedBytes) {\n                body[i + offset] = other.body[i];\n            }\n        }\n        SubString { body, byte_length: self.byte_length + other.byte_length }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> SubStringTrait for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n\n    fn len(self) -> u32 {\n        self.byte_length\n    }\n    fn get(self, idx: u32) -> u8 {\n        self.body[idx]\n    }\n    fn get_body(self) -> [u8] {\n        let x = self.body.as_slice();\n        x\n    }\n\n    /**\n     * @brief given some `haystack` 31-byte chunks, validate that there exist `num_full_chunks`\n     *        in the SubString, starting at byte position `starting_needle_byte`.\n     *        The selected chunks must be equal to the haystack chunks starting at `starting_haystack_chunk`\n     **/\n    fn match_chunks<let HaystackChunks: u32>(\n        self,\n        haystack: [Field; HaystackChunks],\n        starting_needle_byte: u32,\n        starting_haystack_chunk: u32,\n        num_full_chunks: u32,\n    ) {\n        let mut substring_chunks: [Field; PaddedChunksMinusOne] = [0; PaddedChunksMinusOne];\n        // pack the substring into 31 byte chunks.\n        // This is fairly expensive as we need a ROM table to access the SubString.body\n        // which is 2 gates per byte\n        for i in 0..PaddedChunksMinusOne {\n            let mut slice: Field = 0;\n            for j in 0..31 {\n                slice *= 256;\n                let substring_idx = starting_needle_byte + (i * 31) + j;\n                let mut byte = self.body[substring_idx];\n                slice += byte as Field;\n            }\n            std::as_witness(slice);\n            substring_chunks[i] = slice;\n        }\n        // iterate over the needle chunks and validate they match the haystack chunks\n        for i in 0..PaddedChunksMinusOne {\n            let predicate = i < num_full_chunks;\n            let lhs = substring_chunks[i];\n            let rhs = haystack[predicate as u32 * (i + starting_haystack_chunk)];\n            assert(predicate as Field * (lhs - rhs) == 0);\n        }\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for SubString<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n// ######################################################\n// S T R I N G   B O D Y\n// ######################################################\nimpl<let MaxPaddedBytes: u32, let PaddedChunks: u32, let MaxBytes: u32> StringBody<MaxPaddedBytes, PaddedChunks, MaxBytes> {\n\n    /**\n     * @brief construct a StringBody object from an input byte array\n     * @details the input byte array must have a number of bytes less than or equal to MaxBytes\n     **/\n    pub fn new<let InputBytes: u32>(data: [u8; InputBytes], length: u32) -> Self {\n        assert(length <= MaxBytes);\n        assert(length <= InputBytes);\n        let mut body: [u8; MaxPaddedBytes] = [0; MaxPaddedBytes];\n        for i in 0..InputBytes {\n            body[i] = data[i];\n        }\n        StringBody { body, chunks: compute_chunks(body), byte_length: length }\n    }\n\n    /**\n     * @brief Validate a substring exists in the StringBody. Returns a success flag and the position within the StringBody that the match was found\n     **/\n    pub fn substring_match<NeedleSubString>(self, substring: NeedleSubString) -> (bool, u32)\n    where\n        NeedleSubString: SubStringTrait,\n    {\n        // use unconstrained function to determine:\n        // a: is the substring present in the body text\n        // b: the position of the first match in the body text\n        let position: u32 = unsafe {\n            // Safety: The rest of this function checks this.\n            utils::search(\n                self.body,\n                substring.get_body(),\n                self.byte_length,\n                substring.len(),\n            )\n        };\n\n        assert(\n            position + substring.len() <= self.byte_length,\n            \"substring not present in main text (match found if a padding text included. is main text correctly formatted?)\",\n        );\n        let substring_length = substring.len();\n\n        // chunk_index = which 31-byte haystack chunk does the needle begin in?\n        let chunk_index: u32 = position / 31;\n        // chunk_offset = how many haystack bytes are present in the 1st haystack chunk?\n        let chunk_offset: u32 = position % 31;\n        // how many needle bytes are in 1st haystack chunk?\n        let num_bytes_in_first_chunk: u32 = 31 - chunk_offset;\n        let mut starting_needle_byte_index_of_final_chunk: u32 = 0;\n        let mut chunk_index_of_final_haystack_chunk_with_matching_needle_bytes: u32 = 0;\n        let mut num_full_chunks = 0;\n\n        // is there only one haystack chunk that contains needle bytes?\n        let merge_initial_final_needle_chunks = substring_length < num_bytes_in_first_chunk;\n\n        // if the above is false...\n        if (!merge_initial_final_needle_chunks) {\n            // compute how many full 31-byte haystack chunks contain 31 needle bytes\n            num_full_chunks = (substring_length - num_bytes_in_first_chunk) / 31;\n            // for the final haystack chunk that contains needle bytes, where in the needle does this chunk begin?\n            starting_needle_byte_index_of_final_chunk =\n                num_full_chunks * 31 + num_bytes_in_first_chunk;\n\n            // what is the index of the final haystack chunk that contains needle bytes?\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes =\n                num_full_chunks + chunk_index + 1;\n        } else {\n            starting_needle_byte_index_of_final_chunk = 0;\n            // if the needle bytes does NOT span more than 1 haystack chunk,\n            // the final haystack index will be the same as the initial haystack index\n            chunk_index_of_final_haystack_chunk_with_matching_needle_bytes = chunk_index;\n        }\n\n        // To minimize the number of comparisons between the haystack bytes and the needle bytes,\n        // we pack both the haystack bytes and needle bytes into 31-byte Field \"chunks\" and compare chunks.\n        // To do this correctly, we need to align the needle chunks with the haystack chunks\n        /*\n            e.g. consider a toy example where we pack 3 bytes into a chunk\n            haystack: [VWXZYABCDEQRSTU]\n            needle: [ABCDE]\n        when constructing needle chunks, we need to align according to where the needle is located in the haystack\n            haystack chunks:   [VWX] [ZYA] [BCD] [EQR] [STU]\n                                      _..   ...   .__\n            processed needle chunks: [ZYA] [BCD] [EQR]\n        a \"_\" symbole means that a chunk byte has been sourced from the haystack bytes,\n            a \".\" symbol means a byte is sourced from the needle bytes\n        Both the initial and final chunks of the processed needle are \"composite\" constructions.\n            If chunk byte index < `position` or is > `position + needle length\", byte is sourced from haystack, otherwise byte is sourced from needle\n        The way we execute this in code is to define an \"initial\" needle chunk and a \"final\" needle chunk.\n            Num needle bytes in initial chunk = position % 31\n            Num needle bytes in final chunk = (needle_length - (position % 31)) % 31\n        If needle_length < 31 then the \"initial\" and \"final\" chunks\n            are actually the *same* chunk and we must perform a merge operation\n            (see later in algo for comments)\n        */\n        // instead of directly reading haystack bytes, we derive the bytes from the haystack chunks.\n        // This way we don't have to instantiate the haystack bytes as a ROM table, which would cost 2 * haystack.length gates\n        let offset_to_first_needle_byte_in_chunk: u32 = chunk_offset;\n        let initial_haystack_chunk = self.chunks[chunk_index];\n        let final_haystack_chunk =\n            self.chunks[chunk_index_of_final_haystack_chunk_with_matching_needle_bytes];\n\n        let initial_body_bytes: [u8; 31] = initial_haystack_chunk.to_be_bytes();\n        let final_body_bytes: [u8; 31] = final_haystack_chunk.to_be_bytes();\n\n        // When defining the initial chunk bytes, we can represent as Field elements as we are deriving values from known bytes.\n        // This saves us a few gates\n        let mut initial_chunk: [Field; 31] = [0; 31];\n        let mut final_chunk: [Field; 31] = [0; 31];\n        for i in 0..31 {\n            // if i < offset_to_first_needle_byte_in_chunk, we read from the haystack\n            // otherwise we read from the needle\n            // n.b. this can be done with an if statement, but the following code produces fewer constraints\n            let idx: u32 = i;\n            let predicate = i < offset_to_first_needle_byte_in_chunk;\n            let lhs: Field = initial_body_bytes[i] as Field;\n            // if i < offset_to_first_needle_byte_in_chunk then `idx - offset_to_first_needle_byte_in_chunk` is negative\n            // to ensure we access array correctly we need to set the lookup index to 0 if predicate = 0\n            let substring_idx = if predicate {\n                0\n            } else {\n                idx - offset_to_first_needle_byte_in_chunk\n            };\n            let rhs: Field = substring.get(substring_idx) as Field;\n            let byte: Field = predicate as Field * (lhs - rhs) + rhs;\n            initial_chunk[i] = byte;\n        }\n\n        // If `merge_initial_final_needle_chunks = true`, `final_chunk` will contain the full needle data,\n        // this requires some complex logic to determine where we are sourcing the needle bytes from.\n        // Either they come from the `initial_chunk`, the haystack bytes or the substring bytes.\n        for i in 0..31 {\n            let mut lhs_index = starting_needle_byte_index_of_final_chunk + i;\n            let predicate = lhs_index < substring_length;\n            /*\n                | merge_initial_final_needle_chunks | predicate | byte_source              |\n                | false                             | false     | body_bytes[i]            |\n                | false                             | true      | substring[lhs_idx]       |\n                | true                              | false     | body_bytes[i]            |\n                | true                              | true      | initial_chunk[lhs_index] |\n            NOTE: if `merge = true` and `predicate = true`, we read from `initial_chunk` to short-circuit some extra logic.\n                      if `initial_chunk` did not exist, then we would need to validate whether `i < offset_to_first_needle_byte_in_chunk`.\n                      if true, the byte source would be body_bytes, otherwise the source would be substring bytes\n            */\n            let substring_idx = (predicate as u32) * lhs_index;\n            let byte_from_substring = substring.get(substring_idx) as Field;\n            let byte_from_initial_chunk = initial_chunk[i] as Field;\n            let byte_from_haystack = final_body_bytes[i] as Field;\n\n            // TODO: find out why this cuts 1 gate per iteration\n            std::as_witness(byte_from_initial_chunk);\n\n            let p = predicate as Field;\n            let m = merge_initial_final_needle_chunks as Field;\n            // p * (m * (a - b) + (b - c)) + c\n            let ab = byte_from_initial_chunk - byte_from_substring;\n            std::as_witness(ab);\n            let bc = byte_from_substring - byte_from_haystack;\n            let t0 = m * ab + bc;\n            let destination_byte = p * t0 + byte_from_haystack;\n\n            final_chunk[i] = destination_byte;\n        }\n\n        // TODO: moving this above the previous code block adds 31 gates. find out why? :/\n        let mut initial_needle_chunk: Field = 0;\n        let mut final_needle_chunk: Field = 0;\n\n        // Construct the initial and final needle chunks from the byte arrays we previously built.\n        // Validate they match the initial and final haystack chunks\n        for i in 0..31 {\n            initial_needle_chunk *= 256;\n            initial_needle_chunk += initial_chunk[i];\n            final_needle_chunk *= 256;\n            final_needle_chunk += final_chunk[i];\n        }\n\n        std::as_witness(initial_needle_chunk);\n        std::as_witness(final_needle_chunk);\n\n        initial_needle_chunk = merge_initial_final_needle_chunks as Field\n            * (final_needle_chunk - initial_needle_chunk)\n            + initial_needle_chunk;\n        assert(initial_needle_chunk == initial_haystack_chunk);\n        assert(final_needle_chunk == final_haystack_chunk);\n\n        // Step 3: Construct needle chunks (for all but the 1st and last chunks) and validate they match the haystack chunks.\n        //         This part is much simpler as we know that all bytes in the chunk are sourced from the needle chunk.\n        // NOTE:   If we chose to not pack bytes into 31-byte chunks, the string matching algorithm would be simpler but more expensive.\n        //         Instead of matching chunks with each other, we would match individual byte values.\n        //         i.e. the number of iterations in this loop would be 31x greater\n        //         each loop iteration would also require a predicate, to check whether the byte index was within the needle range or not\n        //         Combined these two operations would add about 10 gates per loop iteration,\n        //         combined with a 31x iteration length would make this algorithm much more costly than the chunked variant\n        let body_chunk_offset = chunk_index + 1;\n        substring.match_chunks(\n            self.chunks,\n            num_bytes_in_first_chunk,\n            body_chunk_offset,\n            num_full_chunks,\n        );\n        (true, position)\n    }\n}\n\nimpl<let MaxPaddedBytes: u32, let PaddedChunksMinusOne: u32, let MaxBytes: u32> From<BoundedVec<u8, MaxBytes>> for StringBody<MaxPaddedBytes, PaddedChunksMinusOne, MaxBytes> {\n    fn from(input: BoundedVec<u8, MaxBytes>) -> Self {\n        Self::new(input.storage(), input.len() as u32)\n    }\n}\n\n/// Given an input byte array, convert into 31-byte chunks\n///\n/// Cost: ~0.5 gates per byte\nfn compute_chunks<let MaxPaddedBytes: u32, let PaddedChunks: u32>(\n    body: [u8; MaxPaddedBytes],\n) -> [Field; PaddedChunks] {\n    let mut chunks: [Field; PaddedChunks] = [0; PaddedChunks];\n    for i in 0..PaddedChunks {\n        let mut limb: Field = 0;\n        for j in 0..31 {\n            limb *= 256;\n            limb += body[i * 31 + j] as Field;\n        }\n        chunks[i] = limb;\n        std::as_witness(chunks[i]);\n    }\n    chunks\n}\n\n#[test]\nfn test() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_small_needle() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \"olor\".as_bytes();\n    let mut haystack: StringBody512 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString32 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_aligned_on_byte_boundary() {\n    let haystack_text = \"the quick brown fox jumped over the lazy dog\".as_bytes();\n    let needle_text = \" the lazy dog\".as_bytes();\n\n    let mut haystack: StringBody256 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString256 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_needle_haystack_equal_size() {\n    let haystack_text =\n        \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n    let needle_text = \"the quick brown fox jumped over the lazy dog lorem ipsum blahhhh\".as_bytes();\n\n    let mut haystack: StringBody64 = StringBody::new(haystack_text, haystack_text.len());\n    let mut needle: SubString64 = SubString::new(needle_text, needle_text.len());\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_concat() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString128 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nfn test_concat_into() {\n    let email_text = \"account recovery for Bartholomew Fibblesworth\".as_bytes();\n    let username = \"Bartholomew Fibblesworth\".as_bytes();\n    let mut padded_email_text: [u8; 256] = [0; 256];\n    let mut padded_username: [u8; 100] = [0; 100];\n    for i in 0..username.len() {\n        padded_username[i] = username[i];\n    }\n    for i in 0..email_text.len() {\n        padded_email_text[i] = email_text[i];\n    }\n    let needle_text_init = \"account recovery for \".as_bytes();\n\n    let needle_start: SubString32 = SubString::new(needle_text_init, needle_text_init.len());\n    let needle_end: SubString128 = SubString::new(padded_username, username.len());\n    let needle = needle_start.concat_into(needle_end);\n\n    for i in 0..45 {\n        assert(needle.body[i] == email_text[i]);\n    }\n\n    let haystack: StringBody256 = StringBody::new(padded_email_text, 200);\n    let (result, _): (bool, u32) = haystack.substring_match(needle);\n    assert(result == true);\n}\n\n#[test]\nunconstrained fn test_partial_match() {\n    let mut Engine = DebugRandomEngine { seed: 0 };\n    let mut foo: [u8; 1024] = Engine.get_random_bytes();\n    let mut bar: [u8; 128] = [0; 128];\n    for i in 0..128 {\n        bar[i] = foo[i + 123];\n    }\n    let position = utils::search(foo, bar.as_slice(), 1024, 128);\n\n    assert(position == 123);\n}\n\n#[test]\nfn test_substring_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn test_string_body_from_bounded_vec() {\n    let haystack_text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\"\n        .as_bytes();\n\n    let mut haystack: StringBody512 = BoundedVec::from(haystack_text).into();\n    let needle_text = \" dolor in reprehenderit in voluptate velit esse\".as_bytes();\n    let mut needle: SubString64 = BoundedVec::from(needle_text).into();\n\n    let result = haystack.substring_match(needle);\n    assert(result.0 == true);\n}\n\n#[test]\nfn regression_20() {\n    let haystack: [u8; 128] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x92, 0x00, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x6e, 0x00, 0x00, 0x00, 0x00, 0x57, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x84,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    ];\n\n    let needle: [u8; 32] = [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00,\n    ];\n    let needle_len: u32 = 0x20;\n    let id_haystack: StringBody128 = StringBody::new(haystack, 128);\n    let pk_needle: SubString32 = SubString::new(needle, needle_len);\n    let (result, _): (bool, u32) = id_haystack.substring_match(pk_needle);\n    assert(result);\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/lib.nr"},"158":{"source":"pub unconstrained fn search<let N: u32>(\n    haystack: [u8; N],\n    needle: [u8],\n    haystack_length: u32,\n    needle_length: u32,\n) -> u32 {\n    assert(needle_length > 0, \"needle length of size 0 not supported\");\n    assert(haystack_length > 0, \"haystack length of size 0 not supported\");\n    let mut found = false;\n    let mut found_index: u32 = 0;\n    for i in 0..haystack_length - needle_length + 1 {\n        if (found == true) {\n            break;\n        }\n        for j in 0..needle_length {\n            if haystack[i + j] != needle[j] {\n                break;\n            } else if (j == needle_length - 1) {\n                found = true;\n            }\n            if (found == true) {\n                found_index = i;\n                break;\n            }\n        }\n    }\n    assert(found == true, \"utils::search could not find needle in haystack\");\n    found_index\n}\n\nunconstrained fn __conditional_select(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    if (predicate) {\n        lhs\n    } else {\n        rhs\n    }\n}\n\npub fn conditional_select<T>(lhs: u8, rhs: u8, predicate: bool) -> u8 {\n    // Safety: This is all just a very verbose `if (predicate) { lhs } else { rhs }`\n    // formulated as `rhs + (lhs - rhs) * predicate`\n    unsafe {\n        let result = __conditional_select(lhs, rhs, predicate);\n        let result_f = result as Field;\n        let lhs_f = lhs as Field;\n        let rhs_f = rhs as Field;\n\n        let diff = lhs_f - rhs_f;\n        std::as_witness(diff);\n        assert_eq((predicate as Field) * diff + rhs_f, result_f);\n        result\n    }\n}\n\npub struct DebugRandomEngine {\n    pub seed: Field,\n}\n\nimpl DebugRandomEngine {\n    unconstrained fn get_random_32_bytes(&mut self) -> [u8; 32] {\n        self.seed += 1;\n        let input: [u8; 32] = self.seed.to_be_bytes();\n        let hash: [u8; 32] = std::hash::blake3(input);\n        hash\n    }\n    unconstrained fn get_random_field(&mut self) -> Field {\n        let hash = self.get_random_32_bytes();\n        let mut result: Field = 0;\n        for i in 0..32 {\n            result *= 256;\n            result += hash[i] as Field;\n        }\n        result\n    }\n\n    pub unconstrained fn get_random_bytes<let NBytes: u32>(&mut self) -> [u8; NBytes] {\n        let num_chunks = (NBytes / 32) + ((NBytes % 32) != 0) as u32;\n\n        let mut result: [u8; NBytes] = [0; NBytes];\n        for i in 0..num_chunks - 1 {\n            let bytes = self.get_random_32_bytes();\n            for j in 0..32 {\n                result[i * 32 + j] = bytes[j];\n            }\n        }\n\n        let bytes = self.get_random_32_bytes();\n        for j in 0..(NBytes - (num_chunks - 1) * 32) {\n            result[(num_chunks - 1) * 32 + j] = bytes[j];\n        }\n        result\n    }\n}\n","path":"/Users/lancelot/nargo/github.com/noir-lang/noir_string_search/v0.3.3/src/utils.nr"}},"names":["main"],"brillig_names":["build_msg_block_iter","pad_msg_block","attach_len_to_msg_block","__mul","compute_quadratic_expression_with_borrow_flags","extract_claim_unconstrained","__boundary_check","__validate_decoded","search","extract_claim_unconstrained","extract_claim_unconstrained","directive_integer_quotient","directive_invert","directive_to_radix"]}